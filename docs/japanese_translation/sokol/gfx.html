
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>gfx · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="app.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">目次</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    はじめに
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">コアライブラリ</li>
        
        
    
        <li class="chapter active" data-level="2.1" data-path="gfx.html">
            
                <a href="gfx.html">
            
                    
                    gfx
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="app.html">
            
                <a href="app.html">
            
                    
                    app
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="time.html">
            
                <a href="time.html">
            
                    
                    time
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="audio.html">
            
                <a href="audio.html">
            
                    
                    audio
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="fetch.html">
            
                <a href="fetch.html">
            
                    
                    fetch
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="args.html">
            
                <a href="args.html">
            
                    
                    args
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="glue.html">
            
                <a href="glue.html">
            
                    
                    glue
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">ユーティリティ</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="imgui.html">
            
                <a href="imgui.html">
            
                    
                    imgui
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="nuklear.html">
            
                <a href="nuklear.html">
            
                    
                    nuklear
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="gl.html">
            
                <a href="gl.html">
            
                    
                    gl
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="fontstash.html">
            
                <a href="fontstash.html">
            
                    
                    fontstash
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="gfx_imgui.html">
            
                <a href="gfx_imgui.html">
            
                    
                    gfx_imgui
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="debugtext.html">
            
                <a href="debugtext.html">
            
                    
                    debugtext
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.7" data-path="memtrack.html">
            
                <a href="memtrack.html">
            
                    
                    memtrack
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.8" data-path="shape.html">
            
                <a href="shape.html">
            
                    
                    shape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.9" data-path="color.html">
            
                <a href="color.html">
            
                    
                    color
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.10" data-path="spine.html">
            
                <a href="spine.html">
            
                    
                    spine
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >gfx</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="sokolgfxh">sokol_gfx.h</h1>
<p>シンプルな 3D API ラッパー</p>
<p>プロジェクトURL: <a href="https://github.com/floooh/sokol" target="_blank">https://github.com/floooh/sokol</a></p>
<p>コード例: <a href="https://github.com/floooh/sokol-samples" target="_blank">https://github.com/floooh/sokol-samples</a></p>
<p>このファイルをCまたはC++ファイルにインクルードして実装を作成する前に、</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_IMPL</span>
</code></pre>
<p>または</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_GFX_IMPL</span>
</code></pre>
<p>を定義してください。</p>
<p>同じ場所で、レンダリングバックエンドを選択するために、以下のいずれかを定義します。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_GLCORE33</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_GLES2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_GLES3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_D3D11</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_METAL</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_WGPU</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_DUMMY_BACKEND</span>
</code></pre>
<p>例えば、GL 3.3 Core Profileの場合、次のようになります。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_IMPL</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOKOL_GLCORE33</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;sokol_gfx.h&quot;</span></span>
</code></pre>
<p>ダミーバックエンドは、プラットフォーム固有のバックエンドコードを空のスタブ関数で置き換えます。これは、コマンドラインで実行する必要があるテストを書くときに便利です。</p>
<p>オプションで、以下の定義を独自の実装で提供します。</p>
<ul>
<li>SOKOL_ASSERT(c)             - 独自のアサートマクロ (デフォルト: assert(c))</li>
<li>SOKOL_UNREACHABLE()         - 到達不可能なコードのためのガードマクロ (デフォルト: assert(false))</li>
<li>SOKOL_GFX_API_DECL          - 公開関数宣言のプレフィックス (デフォルト: extern)</li>
<li>SOKOL_API_DECL              - SOKOL_GFX_API_DECLと同じです。</li>
<li>SOKOL_API_IMPL              - public 関数実装の接頭辞（デフォルト：-）。</li>
<li>SOKOL_TRACE_HOOKS           - トレースフックコールバックを有効にする (以下、TRACE HOOKS で検索)</li>
<li>SOKOL_EXTERNAL_GL_LOADER    - 独自のGLローダーを使用していることを示します。この場合、sokol_gfx.hは、いかなるプラットフォームGLヘッダーも含まず、統合されたWin32 GLローダーを無効化します。</li>
</ul>
<p>sokol_gfx.hがDLLとしてコンパイルされる場合、宣言または実装を含む前に以下を定義してください。</p>
<p><code>SOKOL_DLL</code></p>
<p>Windowsでは、SOKOL_DLLは、必要に応じて、SOKOL_GFX_API_DECLを<strong>declspec(dllexport) または </strong>declspec(dllimport) として定義します。</p>
<p>非推奨の構造体や関数を使わずにコンパイルしたい場合は、定義します。</p>
<p><code>SOKOL_NO_DEPRECATED</code></p>
<p>オプションで以下を定義すると、リリースモードでもデバッグチェックとバリデーションを強制的に行うことができます。</p>
<p><code>SOKOL_DEBUG</code></p>
<p>デフォルトでは、_DEBUG が定義されている場合に定義されます。</p>
<h2 id="sokolgfx-does-not">sokol_gfx DOES NOT:</h2>
<ul>
<li>ウィンドウまたは3D-APIコンテキスト/デバイスを作成する。sokol_gfxが初期化される前にこれを行い、必要な情報（3Dデバイスポインタなど）をsokol_gfxの初期化コールに渡す必要があります。</li>
<li>レンダリングされたフレームを表示します。これが正確に行われる方法は、通常、ウィンドウと3D-APIコンテキスト/デバイスの作成方法に依存します。</li>
<li><p>統一されたシェーダー言語を提供する代わりに、3D-API固有のシェーダーソースコードまたはシェーダーバイトコードを提供する必要があります（「公式」オフラインシェーダークロスコンパイラーについては、こちらを参照してください）。</p>
</li>
<li><p><a href="https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md" target="_blank">https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md</a>)</p>
</li>
</ul>
<h2 id="ステップバイステップ">ステップバイステップ</h2>
<p>を呼び出して sokol_gfx を初期化し、ウィンドウと 3D-API コンテキスト/デバイスを作成した後、これを呼び出します。</p>
<pre><code class="lang-c">sg_setup(<span class="hljs-keyword">const</span> sg_desc*)
</code></pre>
<p>リソースオブジェクト（少なくともバッファ、シェーダ、パイプライン、オプションでイメージとパス）を作成します。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_buffer <span class="hljs-title">sg_make_buffer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_buffer_desc*)</span>
sg_image <span class="hljs-title">sg_make_image</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_image_desc*)</span>
sg_shader <span class="hljs-title">sg_make_shader</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_shader_desc*)</span>
sg_pipeline <span class="hljs-title">sg_make_pipeline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_pipeline_desc*)</span>
sg_pass <span class="hljs-title">sg_make_pass</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_pass_desc*)</span>
</span></code></pre>
<p>デフォルトフレームバッファへのレンダリングを開始します。</p>
<pre><code class="lang-c">sg_begin_default_pass(<span class="hljs-keyword">const</span> sg_pass_action* action, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)
</code></pre>
<p>...または、その代わりに。</p>
<pre><code class="lang-c">sg_begin_default_passf(<span class="hljs-keyword">const</span> sg_pass_action* action, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height)
</code></pre>
<p>...フレームバッファの幅と高さをfloat値として受け取ります。</p>
<p>または、オフスクリーンフレームバッファへのレンダリングを開始します。</p>
<pre><code class="lang-c">sg_begin_pass(sg_pass pass, <span class="hljs-keyword">const</span> sg_pass_action* action)
</code></pre>
<p>で次の描画呼び出しのためのパイプラインの状態を設定します。</p>
<pre><code class="lang-c">sg_apply_pipeline(sg_pipeline pip)
</code></pre>
<p>sg_bindings 構造体に、次の描画呼び出しのためのリソースバインディング（1〜N個の頂点バッファ、0個または1個のインデックスバッファ、頂点シェーダおよびフラグメントシェーダステージでそれぞれテクスチャとして使用する0〜N個のイメージオブジェクト）を詰め、以下を呼び出します。</p>
<pre><code class="lang-c">sg_apply_bindings(<span class="hljs-keyword">const</span> sg_bindings* bindings)
</code></pre>
<p>でリソースバインディングを更新します。</p>
<p>オプションでシェーダーユニフォームデータを更新する。</p>
<pre><code class="lang-c">sg_apply_uniforms(sg_shader_stage stage, <span class="hljs-keyword">int</span> ub_index, <span class="hljs-keyword">const</span> sg_range* data)
</code></pre>
<p>sg_apply_uniforms() に渡されるユニフォームデータの期待されるメモリレイアウトについて学ぶために、セクション &apos;UNIFORM DATA LAYOUT&apos; を読んでみてください。</p>
<p>で描画呼び出しをキックオフします。</p>
<pre><code class="lang-c">sg_draw(<span class="hljs-keyword">int</span> base_element, <span class="hljs-keyword">int</span> num_elements, <span class="hljs-keyword">int</span> num_instances)
</code></pre>
<p>sg_draw() 関数は、プリミティブをレンダリングするすべての異なる方法(インデックス付きレンダリングと非インデックス付きレンダリング、インスタンス付きレンダリングと非インスタンス付きレンダリング)を1つの呼び出しで統一しています。インデックス付きレンダリングの場合、base_element と num_element は、現在結合されているインデックスバッファのインデックスを指定します。インデックスなしレンダリングの場合、base_element と num_elements は、現在結合されている頂点バッファの頂点を指定します。インスタンスレンダリングを行うには、レンダリングパイプラインがインスタンス用に設定され（下記の sg_pipeline_desc 参照）、インスタンス毎のデータを含む別の頂点バッファがバインドされ、num_instancesパラメータが&gt; 1 でなければなりません。</p>
<p>現在のレンダリングパスを終了します。</p>
<pre><code class="lang-c">sg_end_pass()
</code></pre>
<p>を呼び出し、現在のフレームを終了させる。</p>
<pre><code class="lang-c">sg_commit()
</code></pre>
<p>でsokol_gfxをシャットダウンしてください。</p>
<pre><code class="lang-c">sg_shutdown()
</code></pre>
<p>sg_shutdown() の前にリソースを破棄する必要がある場合、呼び出す。</p>
<pre><code class="lang-c">sg_destroy_buffer(sg_buffer buf)
sg_destroy_image(sg_image img)
sg_destroy_shader(sg_shader shd)
sg_destroy_pipeline(sg_pipeline pip)
sg_destroy_pass(sg_pass pass)
</code></pre>
<p>を呼び出して、新しいビューポート矩形を設定します。</p>
<pre><code class="lang-c">sg_apply_viewport(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">bool</span> origin_top_left)
</code></pre>
<p>...または、ビューポートの矩形をfloat値で指定したい場合。</p>
<pre><code class="lang-c">sg_apply_viewportf(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">bool</span> origin_top_left)
</code></pre>
<p>をクリックすると、新しいシザーレートを設定することができます。</p>
<pre><code class="lang-c">sg_apply_scissor_rect(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">bool</span> origin_top_left)
</code></pre>
<p>...またはfloat値で。</p>
<pre><code class="lang-c">sg_apply_scissor_rectf(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">bool</span> origin_top_left)
</code></pre>
<p>sg_apply_viewport() と sg_apply_scissor_rect() の両方はレンダリングパスの内部で呼び出されなければなりません。</p>
<blockquote>
<p>sg_begin_default_pass() と sg_begin_pass() はフレームバッファ全体をカバーするためにビューポートとシザーの矩形をリセットすることに注意してください。</p>
</blockquote>
<p>を呼び出して、バッファと画像リソースの内容を更新(上書き)してください。</p>
<pre><code class="lang-c">sg_update_buffer(sg_buffer buf, <span class="hljs-keyword">const</span> sg_range* data)
sg_update_image(sg_image img, <span class="hljs-keyword">const</span> sg_image_data* data)
</code></pre>
<p>更新するバッファとイメージは、SG_USAGE_DYNAMIC または SG_USAGE_STREAM で作成されている必要があります。</p>
<p>sg<em>update</em>*() 関数を使用するとき、バッファとイメージリソースに対してフレームあたり1回のみ更新が許可されます。その根拠は、CPU が GPU が現在使用しているデータを上書きしたり、CPU が GPU を待たせたりしないようにするための簡単な対策です。</p>
<p>バッファと画像の更新は、レンダリング操作がバッファまたは画像内の有効な （更新された）データだけを参照する限り、部分的であってもかまいません。</p>
<p>バッファリソースにデータのチャンクを追加するには、以下を呼び出します。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sg_append_buffer</span><span class="hljs-params">(sg_buffer buf, <span class="hljs-keyword">const</span> sg_range* data)</span>
</span></code></pre>
<p>sg_update_buffer() との違いは、 sg_append_buffer() がフレームごとに複数回呼び出されて、新しいデータを少しずつバッファに追加できることで、オプションで前に書き込んだデータを参照する描画の呼び出しとインターリーブされています。</p>
<p>sg_append_buffer() は書き込まれたデータの開始へのバイトオフセットを返します。このオフセットは sg_bindings.vertex_buffer_offsets[n] または sg_bindings.index_buffer_offset に代入することが可能です。</p>
<p>コード例</p>
<pre><code class="lang-c"><span class="hljs-keyword">for</span> (...) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* data = ...;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num_bytes = ...;
    <span class="hljs-keyword">int</span> offset = sg_append_buffer(buf, &amp;(sg_range) { .ptr=data, .size=num_bytes });
    bindings.vertex_buffer_offsets[<span class="hljs-number">0</span>] = offset;
    sg_apply_pipeline(pip);
    sg_apply_bindings(&amp;bindings);
    sg_apply_uniforms(...);
    sg_draw(...);
}
</code></pre>
<p>sg_append_buffer() で使用するバッファは、SG_USAGE_DYNAMIC または SG_USAGE_STREAM で作成されている必要があります。</p>
<p>アプリケーションが、バッファに収まるより多くのデータをバッファに追加した場合、バッファは、フレームの残りのために &quot;オーバーフロー&quot; 状態になります。</p>
<p>オーバーフローしたバッファをレンダリングしようとする描画コールはすべて、サイレントドロップされます（デバッグモードでは、これは検証エラーにもなります）。</p>
<p>バッファがオーバーフロー状態にあるかどうかを手動で確認することもできます。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">sg_query_buffer_overflow</span><span class="hljs-params">(sg_buffer buf)</span>
</span></code></pre>
<p>バッファにデータを追加する前に、オーバーフローが発生するかどうかを手動で確認するには、以下のように呼び出します。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">sg_query_buffer_will_overflow</span><span class="hljs-params">(sg_buffer buf, <span class="hljs-keyword">size_t</span> size)</span>
</span></code></pre>
<blockquote>
<p>注: 基礎となる 3D-API の制限のため、追加されたデータのチャンクは、宛先バッファで 4 バイトにアラインされます。これは、sg_append_buffer()の呼び出しのインデックスの数が奇数であるとき、16ビットインデックスを含むインデックスバッファにギャップがあることを意味します。sg_append_buffer() の各呼び出しが1つの描画呼び出しに関連している場合、これは問題ではありませんが、1つのインデックス付き描画呼び出しがインデックスのいくつかの追加チャンクにまたがる場合は問題になるでしょう。</p>
</blockquote>
<p>を呼び出して、オプション機能、制限、pixelformatのサポートを実行時にチェックします。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_features <span class="hljs-title">sg_query_features</span><span class="hljs-params">()</span>
sg_limits <span class="hljs-title">sg_query_limits</span><span class="hljs-params">()</span>
sg_pixelformat_info <span class="hljs-title">sg_query_pixelformat</span><span class="hljs-params">(sg_pixel_format fmt)</span>
</span></code></pre>
<p>を直接呼び出す必要がある場合、その基礎となる3D-APIを呼び出す必要があります。</p>
<pre><code class="lang-c">sg_reset_state_cache()
</code></pre>
<p>...再びsokol_gfxの関数を呼び出す前に</p>
<p>sg_query_desc() を呼び出すことによって、 sg_setup() に渡されたオリジナルの sg_desc 構造体を検査することができます。これは、ゼロ初期化された値の代わりに、デフォルト値がパッチされた sg_desc 構造体を返します。</p>
<p>を介して、様々な内部リソースの属性を検査することができます。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_buffer_info <span class="hljs-title">sg_query_buffer_info</span><span class="hljs-params">(sg_buffer buf)</span>
sg_image_info <span class="hljs-title">sg_query_image_info</span><span class="hljs-params">(sg_image img)</span>
sg_shader_info <span class="hljs-title">sg_query_shader_info</span><span class="hljs-params">(sg_shader shd)</span>
sg_pipeline_info <span class="hljs-title">sg_query_pipeline_info</span><span class="hljs-params">(sg_pipeline pip)</span>
sg_pass_info <span class="hljs-title">sg_query_pass_info</span><span class="hljs-params">(sg_pass pass)</span>
</span></code></pre>
<p>...返される情報構造体は sokol_gfx.h の内部と密接に結びついており、他の公開 API 関数や構造体よりも頻繁に変更される可能性があることに注意してください。</p>
<p>sokol_gfx.hがどのバックエンド用にコンパイルされたか、あるいはGLES3バックエンドがGLES2にフォールバックしなければならなかったかをランタイムに尋ねることができます。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_backend <span class="hljs-title">sg_query_backend</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>という関数で、デフォルトのリソース作成パラメータを問い合わせることができます。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_buffer_desc <span class="hljs-title">sg_query_buffer_defaults</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_buffer_desc* desc)</span>
sg_image_desc <span class="hljs-title">sg_query_image_defaults</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_image_desc* desc)</span>
sg_shader_desc <span class="hljs-title">sg_query_shader_defaults</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_shader_desc* desc)</span>
sg_pipeline_desc <span class="hljs-title">sg_query_pipeline_defaults</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_pipeline_desc* desc)</span>
sg_pass_desc <span class="hljs-title">sg_query_pass_defaults</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_pass_desc* desc)</span>
</span></code></pre>
<p>これらの関数は、デフォルト値のためにゼロ初期化された項目を含むことができる desc 構造体へのポインタを取ります。これらのゼロ初期化された値は、返された desc 構造体の具体的な値に置き換えられます。</p>
<h2 id="on-initialization">ON INITIALIZATION:</h2>
<p>sg_setup() を呼び出すとき、初期化オプションを含む sg_desc 構造体へのポインタを提供しなければなりません。これらのオプションは sokol-gfx に2つのタイプの情報を提供します。</p>
<p>(1) 様々な内部リソースを割り当てるために必要な上限と下限</p>
<p>データ構造</p>
<ul>
<li>同時にアライブできる各タイプのリソースの最大数、これは内部プールを割り当てるために使用されます。</li>
<li>フレームごとに更新できる均一なデータの最大サイズ、均一な更新ごとの最悪のケースのアライメントを含む（この最悪のケースのアライメントは256バイトです）</li>
<li>フレームごとのすべての動的なリソースの更新（sg_update_buffer、sg_append_buffer、sg_update_image）の最大サイズ。</li>
<li>テクスチャサンプラーキャッシュの最大エントリ数（同時にいくつのユニークなテクスチャサンプラーが存在できるのか）</li>
</ul>
<p>これらの制限値のすべてが、すべてのバックエンドで使用されるわけではありません。
を提供するのはよい習慣です。</p>
<p>(2) 3D-APIの「コンテキスト情報」（「バインディング」とも呼ばれることがある）。</p>
<p>sokol_gfx.h は、プレゼンテーション層に密接に関連する 3D API オブジェクトを作成または初期化しません (これは、「レンダリングデバイス」、スワップチェーン、およびスワップチェーンに依存する任意のオブジェクトを含みます)。これらの API オブジェクト（または、フレーム間でオブジェクトが変更される可能性がある場合、それらを取得するコールバック関数）は、sg_desc 構造体の中に入れ子された sg_context_desc 構造体で提供されなければなりません。sokol_gfx.h が sokol_app.h と共に使用される場合、 sokol_app.h によって提供されるコンテキスト情報で満たされた sg_context_desc 構造体を得るための便利な関数を提供する sokol_glue.h ヘッダーを見てみてください。</p>
<p>より詳細な情報は、以下の sg_desc 構造体のドキュメントブロックを参照してください。</p>
<h2 id="uniform-data-layout">UNIFORM DATA LAYOUT:</h2>
<blockquote>
<p>注：シェーダーコンパイラツール sokol-shdc を使用する場合、以下の詳細について心配する必要はありません。</p>
</blockquote>
<p>sg_apply_uniforms() 関数に渡されるデータは、GPU シェーダが正しいオフセットでユニフォームブロックアイテムを見つけるように、特定のレイアウトルールに従わなければなりません。</p>
<p>D3D11 と Metal バックエンドでは、sokol-gfx はユニフォームブロックのサイズにのみ関 心があり、内部レイアウトには関心がありません。データは一回の操作で均一/定数バッファにコピーされ、GPU側のレイアウトと一致するようにCPU側のレイアウトをアレンジするのはあなた次第です。これは、D3D11 と Metal バックエンドでは、ユニフォーム変数タイプの「クロスプラッ トフォーム」サブセットに制限されないということでもあります。</p>
<p>D3D11、Metal <em>または</em> WebGPUバックエンドのいずれか1つだけを使用する場合は、ここで読むのをやめてもかまいません。</p>
<p>GLバックエンドでは、ユニフォームブロックの内部レイアウトが重要で、ユニフォーム変数の型は少数に制限されます。これは、glUniformXXX()呼び出しでGPUにアップロードするために、sokol-gfxがユニフォームブロックメンバーの位置を特定できる必要があるためです。</p>
<p>ユニフォームブロックのレイアウトを sokol-gfx に記述するために、 sg_make_shader() の呼び出しに、以下の情報を sg_shader_desc 構造体で渡す必要があります。</p>
<ul>
<li>使用されるパッキングルールに関するヒント (SG_UNIFORMLAYOUT_NATIVE または SG_UNIFORMLAYOUT_STD140 のいずれか)</li>
<li>CPU 側に表示される正しい順序での均一ブロックメンバーの型のリスト</li>
</ul>
<p>例えば、GLSL シェーダが以下のユニフォーム宣言を持つ場合。</p>
<pre><code class="lang-glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> mvp;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> offset0;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> offset1;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> offset2;
</code></pre>
<p>...そして、CPU側には、同様のC構造体があります。</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">float</span> mvp[<span class="hljs-number">16</span>];
    <span class="hljs-keyword">float</span> offset0[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">float</span> offset1[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">float</span> offset2[<span class="hljs-number">2</span>];
} <span class="hljs-keyword">params_t</span>;
</code></pre>
<p>...sg_shader_descのユニフォームブロックの記述は、次のようなものでなければなりません。</p>
<pre><code class="lang-c">sg_shader_desc desc = {
    .vs.uniform_blocks[<span class="hljs-number">0</span>] = {
        .size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">params_t</span>),
        .layout = SG_UNIFORMLAYOUT_NATIVE,  <span class="hljs-comment">// this is the default and can be omitted</span>
        .uniforms = {
            <span class="hljs-comment">// order must be the same as in &apos;params_t&apos;:</span>
            [<span class="hljs-number">0</span>] = { .name = <span class="hljs-string">&quot;mvp&quot;</span>, .type = SG_UNIFORMTYPE_MAT4 },
            [<span class="hljs-number">1</span>] = { .name = <span class="hljs-string">&quot;offset0&quot;</span>, .type = SG_UNIFORMTYPE_VEC2 },
            [<span class="hljs-number">2</span>] = { .name = <span class="hljs-string">&quot;offset1&quot;</span>, .type = SG_UNIFORMTYPE_VEC2 },
            [<span class="hljs-number">3</span>] = { .name = <span class="hljs-string">&quot;offset2&quot;</span>, .type = SG_UNIFORMTYPE_VEC2 },
        }
    }
};
</code></pre>
<p>この情報により、sokol-gfxはユニフォームブロック構造内のデータアイテムの正しいオフセットを計算することができます。</p>
<p>SG_UNIFORMLAYOUT_NATIVEパッキングルールは、GLバックエンドのみが使用される場合はうまく機能しますが、適切なD3D11/Metal/GLでは、次のセクションで説明するstd140レイアウトのサブセットを使用しなければなりません。</p>
<h2 id="クロスバックエンド共通の統一データレイアウト">クロスバックエンド共通の統一データレイアウト</h2>
<p>クロスプラットフォーム/クロス3Dバックエンドのコードでは、CPU側のブロックレイアウトがすべてのsokol-gfxバックエンドで同じ統一されたものを使用できることが重要です。これを実現するためには、std140レイアウトの共通のサブセットを使用しなければなりません。</p>
<ul>
<li>sg_shader_desc の均一ブロックレイアウトヒントは、明示的に SG_UNIFORMLAYOUT_STD140 に設定する必要があります。</li>
<li>以下のGLSLユニフォームタイプのみが使用可能です（関連するsokol-gfx enumもあります）。<ul>
<li>float =&gt; SG_UNIFORMTYPE_FLOAT</li>
<li>vec2  =&gt; SG_UNIFORMTYPE_FLOAT2</li>
<li>vec3  =&gt; SG_UNIFORMTYPE_FLOAT3</li>
<li>vec4  =&gt; SG_UNIFORMTYPE_FLOAT4</li>
<li>int   =&gt; SG_UNIFORMTYPE_INT</li>
<li>ivec2 =&gt; SG_UNIFORMTYPE_INT2</li>
<li>ivec3 =&gt; SG_UNIFORMTYPE_INT3</li>
<li>ivec4 =&gt; SG_UNIFORMTYPE_INT4</li>
<li>mat4  =&gt; SG_UNIFORMTYPE_MAT4</li>
</ul>
</li>
<li>これらの型のアライメントは、以下の通り（バイト単位）でなければならない。<ul>
<li>float =&gt; 4</li>
<li>vec2  =&gt; 8</li>
<li>vec3  =&gt; 16</li>
<li>vec4  =&gt; 16</li>
<li>int   =&gt; 4</li>
<li>ivec2 =&gt; 8</li>
<li>ivec3 =&gt; 16</li>
<li>ivec4 =&gt; 16</li>
<li>mat4  =&gt; 16</li>
</ul>
</li>
<li>配列は、vec4, int4, mat4 の型にのみ許されます。</li>
</ul>
<blockquote>
<p>HLSL の cbuffer のレイアウト規則は std140 のレイアウト規則と若干異なるので，HLSL コードの cbuffer 宣言は std140 と互換性があるように調整しなければならないことに注意してください．</p>
</blockquote>
<p>一般的な均一ブロックレイアウトの問題を解決する最も簡単な方法は、sokol-shdc シェーダクロスコンパイラツールを使用することです!</p>
<h2 id="バックエンドに特化したトピック">バックエンドに特化したトピック</h2>
<p>GLバックエンドは、ユニフォームブロックの内部構造、テクスチャサンプラー名と-typeについて知る必要があります。ユニフォームレイアウトの詳細は、上記のUNIFORM DATA LAYOUTセクションで説明されています。</p>
<pre><code class="lang-c"><span class="hljs-comment">// uniform block structure and texture image definition in sg_shader_desc:</span>
sg_shader_desc desc = {
    <span class="hljs-comment">// uniform block description (size and internal structure)</span>
    .vs.uniform_blocks[<span class="hljs-number">0</span>] = {
        ...
    },
    <span class="hljs-comment">// one texture on the fragment-shader-stage, GLES2/WebGL needs name and image type</span>
    .fs.images[<span class="hljs-number">0</span>] = { .name=<span class="hljs-string">&quot;tex&quot;</span>, .type=SG_IMAGETYPE_ARRAY }
    ...
};
</code></pre>
<p>MetalとD3D11のバックエンドは、ユニフォームブロックのサイズだけを知っていればよく、その内部メンバー構造を知っている必要はありません。</p>
<pre><code class="lang-c">sg_shader_desc desc = {
    .vs.uniform_blocks[<span class="hljs-number">0</span>].size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">params_t</span>),
    .fs.images[<span class="hljs-number">0</span>].type = SG_IMAGETYPE_ARRAY,
    ...
};
</code></pre>
<p>シェーダオブジェクトを作成するとき、GLES2/WebGLはバーテックスシェーダで使用されるバーテックス属性名を知る必要があります。</p>
<pre><code class="lang-c">sg_shader_desc desc = {
    .attrs = {
        [<span class="hljs-number">0</span>] = { .name=<span class="hljs-string">&quot;position&quot;</span> },
        [<span class="hljs-number">1</span>] = { .name=<span class="hljs-string">&quot;color1&quot;</span> }
    }
};
</code></pre>
<p>シェーダ作成時に提供された頂点属性名は、後に sg_create_pipeline() で頂点レイアウトと頂点シェーダ入力を一致させるために使用されます。</p>
<p>D3D11 では、代わりにセマンティック名とセマンティックインデックスをシェーダ記述構造体で提供する必要があります（詳細は D3D11_INPUT_ELEMENT_DESC の D3D11 のドキュメントを参照してください）。</p>
<pre><code class="lang-c">sg_shader_desc desc = {
    .attrs = {
        [<span class="hljs-number">0</span>] = { .sem_name=<span class="hljs-string">&quot;POSITION&quot;</span>, .sem_index=<span class="hljs-number">0</span> }
        [<span class="hljs-number">1</span>] = { .sem_name=<span class="hljs-string">&quot;COLOR&quot;</span>, .sem_index=<span class="hljs-number">1</span> }
    }
};
</code></pre>
<p>提供された意味情報は、後に sg_create_pipeline() で頂点レイアウトとバーテックスシェーダ入力を一致させるために使用されます。</p>
<p>D3D11 で、（バイトコードではなく）HLSL ソースコードをシェーダ作成に渡すとき、オプションで頂点ステージにシェーダモデルターゲットを定義することができます。</p>
<pre><code class="lang-c">sg_shader_Desc desc = {
    .vs = {
        ...
        .d3d11_target = <span class="hljs-string">&quot;vs_5_0&quot;</span>
    },
    .fs = {
        ...
        .d3d11_target = <span class="hljs-string">&quot;ps_5_0&quot;</span>
    }
};
</code></pre>
<p>デフォルトのターゲットは &quot;ps_4_0 &quot;と &quot;fs_4_0 &quot;です。これらのターゲット名は、ソースからシェーダをコンパイルするときのみ使用されることに注意してください。バイトコードからシェーダを作成する場合、これらは無視されます。</p>
<p>Metal、GL 3.3、または GLES3/WebGL2 では、頂点属性はそのスロットインデックスでバインドできるため、属性名や意味名を提供する必要はありません（これは Metal では必須、GL では任意です）。</p>
<pre><code class="lang-c">sg_pipeline_desc desc = {
    .layout = {
        .attrs = {
            [<span class="hljs-number">0</span>] = { .format=SG_VERTEXFORMAT_FLOAT3 },
            [<span class="hljs-number">1</span>] = { .format=SG_VERTEXFORMAT_FLOAT4 }
        }
    }
};
</code></pre>
<h2 id="working-with-contexts">WORKING WITH CONTEXTS</h2>
<p>sokol-gfx は、異なるレンダリングコンテキストを切り替えて、リソースオブジェクトを コンテキストに関連付けることができます。これは、複数のウィンドウにレンダリングするGLアプリケーションを作成するのに便利です。</p>
<p>レンダリングコンテキストは、コンテキストがアクティブである間に作成されたすべてのリソースを追跡します。コンテキストが破棄されると、「コンテキストに属している」すべてのリソースも破棄されます。</p>
<p>デフォルトのコンテキストは sg_setup() で暗黙のうちに作成、有効化され、sg_shutdown() で破棄されます。したがって、複数のコンテキストを使用しない典型的なアプリケーションでは、何も変更されず、コンテキスト関数を呼び出す必要はありません。</p>
<p>コンテキストを扱うために、3つの関数が追加されました。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_context <span class="hljs-title">sg_setup_context</span><span class="hljs-params">()</span>:
</span></code></pre>
<p>GL コンテキストが作成され、アクティブになった後に一度だけ呼び出される必要があります。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sg_activate_context</span><span class="hljs-params">(sg_context ctx)</span>
</span></code></pre>
<p>これは、異なるGLコンテキストをアクティブにした後に呼び出す必要があります。3D-API固有の動作とは別に、sg_activate_context()の呼び出しは、内部的にsg_reset_state_cache()を呼び出すことになります。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sg_discard_context</span><span class="hljs-params">(sg_context ctx)</span>
</span></code></pre>
<p>これは GL コンテキストが破壊される直前に呼ばれなければならず，コンテキストに関連するすべてのリソース（コンテキストがアクティブだった間に作成されたもの）を破壊します． sg_discard_context(sg_context ctx) が呼ばれた時点で GL コンテキストはアクティブになっていなければなりません．</p>
<p>また、リソース（バッファ、イメージ、シェーダ、パイプライン）は、リソースが作成されたときにアクティブであったのと同じGLコンテキストがアクティブである間のみ使用または破棄されなければならないことに注意してください（例外はGLのリソース共有で、そのようなリソースは別のコンテキストがアクティブであっても使用できますが、作成時にアクティブだった同じコンテキストで破棄しなければならない）。</p>
<p>より詳しい情報は、multiwindow-glfwのサンプルをご覧ください。</p>
<p><a href="https://github.com/floooh/sokol-samples/blob/master/glfw/multiwindow-glfw.c" target="_blank">https://github.com/floooh/sokol-samples/blob/master/glfw/multiwindow-glfw.c</a></p>
<h2 id="trace-hooks">TRACE HOOKS:</h2>
<p>sokol_gfx.h は、オプションとして、各パブリック API 関数に対して &quot;trace hook&quot; コールバックをインストールすることができます。パブリックAPI関数が呼び出され、その関数にトレースフックコールバックがインストールされている場合、その関数のパラメータと結果でコールバックが呼び出されます。これは、デバッグツールやプロファイリングツール、あるいはリソースの生成と破棄を追跡するような場合に便利である。</p>
<p>トレースフック機能を使うには</p>
<p>実装をインクルードする前に SOKOL_TRACE_HOOKS を定義してください。</p>
<p>コールバック関数のポインタを持つ sg_trace_hooks 構造体を設定します (興味のない関数のポインタはすべてゼロ初期化したままにしておきます)。オプションで sg_trace_hooks 構造体の user_data メンバを設定します。</p>
<p>sg_install_trace_hooks() を呼び出してトレースフックをインストールします。この関数の戻り値は、以前に設定したトレースフックを含む、別の sg_trace_hooks 構造体です。この構造体を保持し、適切な連鎖のために、あなた自身のトレースコールバックからこれらの以前の関数のポインタを呼び出す必要があります。</p>
<p>トレースフックがどのように使用されるかの例として、 imgui/sokol_gfx_imgui.h ヘッダを見てください。これは sokol_gfx.h のリアルタイムデバッグ UI を Dear ImGui 上に実装しています。</p>
<h2 id="ポータブルパック頂点フォーマットに関するメモ">ポータブルパック頂点フォーマットに関するメモ:</h2>
<p>UBYTE4、SHORT2 などの packed vertex フォーマットを使用する場合、すべてのバックエンドで動作させる必要があるため、2 つの点を考慮する必要があります。</p>
<p>D3D11 は頂点フェッチ時に <em>normalized</em> 頂点フォーマットを浮動小数点にのみ変換でき、 normalized フォーマットは最後に &apos;N&apos; があり、範囲 -1.0 ～ +1.0 (signed フォーマット) または 0.0 ～ 1.0 (unsigned フォー マット) に &quot;normalized&quot; されます。</p>
<ul>
<li>SG_VERTEXFORMAT_BYTE4N</li>
<li>SG_VERTEXFORMAT_UBYTE4N</li>
<li>SG_VERTEXFORMAT_SHORT2N</li>
<li>SG_VERTEXFORMAT_USHORT2N</li>
<li>SG_VERTEXFORMAT_SHORT4N</li>
<li>SG_VERTEXFORMAT_USHORT4N</li>
</ul>
<p>D3D11 は <em>non-normalized</em> 頂点フォーマットを浮動小数点バーテックスシェーダ入力 に変換しません。</p>
<ul>
<li>SG_VERTEXFORMAT_BYTE4,</li>
<li>SG_VERTEXFORMAT_UBYTE4</li>
<li>SG_VERTEXFORMAT_SHORT2</li>
<li><p>SG_VERTEXFORMAT_SHORT4</p>
</li>
<li><p>WebGL/GLES2 では、整数バーテックスシェーダ入力（int または ivecn）を使用できません。</p>
</li>
<li>SG_VERTEXFORMAT_UINT10_N2 は WebGL/GLES2 でサポートされていません。</li>
</ul>
<p>したがって、すべてのプラットフォームで動作する頂点入力レイアウトには、以下の頂点フォーマットのみを使用し、必要に応じて、127.0、255.0、32767.0 または 65535.0 を乗算して、頂点シェーダで正規化した頂点入力を「拡張」してください。</p>
<ul>
<li>SG_VERTEXFORMAT_FLOAT,</li>
<li>SG_VERTEXFORMAT_FLOAT2,</li>
<li>SG_VERTEXFORMAT_FLOAT3,</li>
<li>SG_VERTEXFORMAT_FLOAT4,</li>
<li>SG_VERTEXFORMAT_BYTE4N,</li>
<li>SG_VERTEXFORMAT_UBYTE4N,</li>
<li>SG_VERTEXFORMAT_SHORT2N,</li>
<li>SG_VERTEXFORMAT_USHORT2N</li>
<li>SG_VERTEXFORMAT_SHORT4N,</li>
<li>SG_VERTEXFORMAT_USHORT4N</li>
</ul>
<h2 id="メモリ割り当てオーバーライド">メモリ割り当てオーバーライド</h2>
<p>このように初期化時にメモリ割り当て関数をオーバーライドすることができます。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">my_alloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* user_data)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">my_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">void</span>* user_data)</span> </span>{
    <span class="hljs-built_in">free</span>(ptr);
}

...
    sg_setup(&amp;(sg_desc){
        <span class="hljs-comment">// ...</span>
        .allocator = {
            .alloc = my_alloc,
            .<span class="hljs-built_in">free</span> = my_free,
            .user_data = ...,
        }
    });
...
</code></pre>
<p>オーバーライドが提供されない場合、malloc と free が使用されます。</p>
<p>これは、sokol_gfx.h 自身が行うメモリ割り当ての呼び出しにのみ影響し、 OS ライブラリでの割り当ては影響しませんが。</p>
<h2 id="ログ関数オーバーライド">ログ関数オーバーライド</h2>
<p>このように初期化時にログ関数をオーバーライドすることができます。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">my_log</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message, <span class="hljs-keyword">void</span>* user_data)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sg says: \s\n&quot;</span>, message);
}

...
    sg_setup(&amp;(sg_desc){
        <span class="hljs-comment">// ...</span>
        .logger = {
            .log_cb = my_log,
            .user_data = ...,
        }
    });
...
</code></pre>
<p>オーバーライドが提供されない場合、ほとんどのプラットフォームでputsが使用されます。Android では、代わりに __android_log_write が使用されます。</p>
<h2 id="コミットメントリスナー">コミットメントリスナー</h2>
<p>sg_commit() の内部から不特定の順序で呼び出されるコールバック関数を sokol-gfx にフックすることが可能です。これは主に、sokol_gfx.hの上に構築されるライブラリが、フレームの終了/開始について通知されるのに便利です。</p>
<p>コミットリスナーを追加するには、次のように呼び出します。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">my_commit_listener</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* user_data)</span> </span>{
    ...
}

<span class="hljs-keyword">bool</span> success = sg_add_commit_listener((sg_commit_listener){
    .func = my_commit_listener,
    .user_data = ...,
});
</code></pre>
<p>コミットリスナーの内部配列が満杯の場合、あるいは同じコミットリスナーが既に追加されていた場合、この関数は false を返します。</p>
<p>この関数が true を返した場合、sg_commit() 内から my_commit_listener() がフレームごとに呼び出されます。</p>
<p>デフォルトでは、1024の異なるコミットリスナーを追加することができますが、この数はsg_setup()呼び出しで微調整することができます。</p>
<pre><code class="lang-c">sg_setup(&amp;(sg_desc){
    .max_commit_listeners = <span class="hljs-number">2048</span>,
});
</code></pre>
<p>sg_commit_listener の項目は、関数ポインタと user_data フィールドの両方が等しい場合、他の項目と等しくなります。</p>
<p>コミットリスナーを削除するには</p>
<pre><code class="lang-c"><span class="hljs-keyword">bool</span> success = sg_remove_commit_listener((sg_commit_listener){
    .func = my_commit_listener,
    .user_data = ...,
});
</code></pre>
<p>...ここで、.func と .user_data フィールドは以前の sg_add_commit_listener() の呼び出しと同じです。この関数はコミットリスナーの項目が見つかって削除された場合はtrueを、そうでない場合はfalseを返します。</p>
<h2 id="リソースの生成と破壊の詳細">リソースの生成と破壊の詳細</h2>
<p>リソースオブジェクトを作成する「バニラ」な方法は、「make関数」を使用することです。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_buffer <span class="hljs-title">sg_make_buffer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_buffer_desc* desc)</span>
sg_image <span class="hljs-title">sg_make_image</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_image_desc* desc)</span>
sg_shader <span class="hljs-title">sg_make_shader</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_shader_desc* desc)</span>
sg_pipeline <span class="hljs-title">sg_make_pipeline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_pipeline_desc* desc)</span>
sg_pass <span class="hljs-title">sg_make_pass</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sg_pass_desc* desc)</span>
</span></code></pre>
<p>この場合、3つのケースのいずれかになります。</p>
<ol>
<li>返されたハンドルは無効である。これは、このリソースタイプのリソースプールに空きスロットがもうない場合に起こります。無効なハンドルは、例えば、INVALIDリソース状態に関連付けられます。</li>
</ol>
<pre><code class="lang-c">sg_buffer buf = sg_make_buffer(...)
<span class="hljs-keyword">if</span> (sg_query_buffer_state(buf) == SG_RESOURCESTATE_INVALID) {
    <span class="hljs-comment">// buffer pool is exhausted</span>
}
</code></pre>
<ol>
<li>返されたハンドルは有効であるが、何らかの理由で基礎となるリソースの作成に失敗した。この結果、リソースオブジェクトは FAILED 状態になる。リソースの作成に失敗した理由は、リソースの種類によって異なります。詳細については、ログメッセージをご覧ください。失敗したリソースの状態は、次のようにして確認できます。</li>
</ol>
<pre><code class="lang-c">sg_buffer buf = sg_make_buffer(...)
<span class="hljs-keyword">if</span> (sg_query_buffer_state(buf) == SG_RESOURCESTATE_FAILED) {
    <span class="hljs-comment">// creating the resource has failed</span>
}
</code></pre>
<ol>
<li>そして最後に、すべてがうまくいけば、返されたリソースはリソースステートVALIDになり、使用できるようになります。これは、次のようにして確認することができます。</li>
</ol>
<pre><code class="lang-c">sg_buffer buf = sg_make_buffer(...)
<span class="hljs-keyword">if</span> (sg_query_buffer_state(buf) == SG_RESOURCESTATE_VALID) {
    <span class="hljs-comment">// creating the resource has failed</span>
}
</code></pre>
<p>「make関数」を呼び出すと、作成されたリソースは次のような状態を経ます。
の状態を経る。</p>
<ul>
<li>INITIAL: 新しいリソースに関連付けられたリソーススロットは現在フリーです (技術的には、まだリソースは存在せず、空のプールスロットがあるだけです)。</li>
<li>ALLOC: 新しいリソースのハンドルが割り当てられました。これは単にプールスロットが予約されたことを意味します。</li>
<li>VALID or FAILED: VALIDの場合、3D APIバックエンドリソースオブジェクトは正常に作成されました、それ以外の場合、リソースはFAILEDの状態になります。</li>
</ul>
<p>時には、最初にハンドルを取得し、後で基礎となるリソースを初期化することが理にかなっていることがあります。例えば、低速のデータソースから非同期にデータをロードする場合、ロードプロセスの早い段階でどのようなバッファやテクスチャが必要かが分かるかもしれませんが、実際にバッファやテクスチャの内容をロードするのは後のタイミングになります。</p>
<p>このような状況のために、sokol-gfxリソース・オブジェクトは2つのステップで作成することができます。alloc関数」の1つを使って、前もってハンドルを確保することができます。</p>
<pre><code class="lang-c"><span class="hljs-function">sg_buffer <span class="hljs-title">sg_alloc_buffer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
sg_image <span class="hljs-title">sg_alloc_image</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
sg_shader <span class="hljs-title">sg_alloc_shader</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
sg_pipeline <span class="hljs-title">sg_alloc_pipeline</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
sg_pass <span class="hljs-title">sg_alloc_pass</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>これは、ALLOC状態の基礎となるリソースオブジェクトを持つハンドルを返します。</p>
<pre><code class="lang-C">sg_image img = sg_alloc_image();
<span class="hljs-keyword">if</span> (sg_query_image_state(img) == SG_RESOURCESTATE_ALLOC) {
    <span class="hljs-comment">// allocating an image handle has succeeded, otherwise</span>
    <span class="hljs-comment">// the image pool is full</span>
}
</code></pre>
<p>このような「不完全な」ハンドルは、ほとんどのsokol-gfxレンダリング関数で害なく使用することができ、sokol-gfxはVALID状態でないリソースを含むレンダリング操作を単にスキップします。</p>
<p>後で（例えば、テクスチャのロードが非同期で完了したら）、リソースの作成は「init関数」の一つを呼び出すことで完了します。これらの関数は、既存のリソースハンドルと「desc構造」を取ります。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sg_init_buffer</span><span class="hljs-params">(sg_buffer buf, <span class="hljs-keyword">const</span> sg_buffer_desc* desc)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_init_image</span><span class="hljs-params">(sg_image img, <span class="hljs-keyword">const</span> sg_image_desc* desc)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_init_shader</span><span class="hljs-params">(sg_shader shd, <span class="hljs-keyword">const</span> sg_shader_desc* desc)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_init_pipeline</span><span class="hljs-params">(sg_pipeline pip, <span class="hljs-keyword">const</span> sg_pipeline_desc* desc)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_init_pass</span><span class="hljs-params">(sg_pass pass, <span class="hljs-keyword">const</span> sg_pass_desc* desc)</span>
</span></code></pre>
<p>init関数はALLOC状態のリソースを想定しており、関数が戻った後、リソースはVALIDまたはFAILED状態のいずれかになる。alloc関数とそれに続くinit関数を呼び出すことは、make関数を単独で呼び出すことと完全に等価である。</p>
<p>破壊は、2段階のプロセスとして起こることもある。uninit関数」は、VALIDまたはFAILED状態からALLOC状態にリソースオブジェクトを戻す。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sg_uninit_buffer</span><span class="hljs-params">(sg_buffer buf)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_uninit_image</span><span class="hljs-params">(sg_image img)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_uninit_shader</span><span class="hljs-params">(sg_shader shd)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_uninit_pipeline</span><span class="hljs-params">(sg_pipeline pip)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_uninit_pass</span><span class="hljs-params">(sg_pass pass)</span>
</span></code></pre>
<p>VALIDまたはFAILEDの状態でないリソースで「uninit関数」を呼び出しても無駄である。</p>
<p>最終的にプールスロットを再利用のために解放するには、「dealloc関数」を呼び出します。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sg_dealloc_buffer</span><span class="hljs-params">(sg_buffer buf)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_dealloc_image</span><span class="hljs-params">(sg_image img)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_dealloc_shader</span><span class="hljs-params">(sg_shader shd)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_dealloc_pipeline</span><span class="hljs-params">(sg_pipeline pip)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_dealloc_pass</span><span class="hljs-params">(sg_pass pass)</span>
</span></code></pre>
<p>ALLOC状態でないリソースに対して「dealloc関数」を呼び出しても無駄ですが、警告のログメッセージは生成されます。</p>
<p>「uninit関数」と「dealloc関数」を連続して呼び出すことは、関連する「destroy関数」を呼び出すことと等価である。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sg_destroy_buffer</span><span class="hljs-params">(sg_buffer buf)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_destroy_image</span><span class="hljs-params">(sg_image img)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_destroy_shader</span><span class="hljs-params">(sg_shader shd)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_destroy_pipeline</span><span class="hljs-params">(sg_pipeline pip)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sg_destroy_pass</span><span class="hljs-params">(sg_pass pass)</span>
</span></code></pre>
<p>destroy 関数」はどのような状態のリソースに対しても呼び出すことができ、一般に正しい動作をします（例えば、リソースが ALLOC 状態の場合、destroy 関数は「dealloc 関数」と同等で、「uninit 部分」をスキップします）。</p>
<p>そして最後に、ALLOC状態のリソースを手動でFAILED状態にするために、「fail関数」を呼び出すことができる。</p>
<pre><code class="lang-c">sg_fail_buffer(sg_buffer buf)
sg_fail_image(sg_image img)
sg_fail_shader(sg_shader shd)
sg_fail_pipeline(sg_pipeline pip)
sg_fail_pass(sg_pass pass)
</code></pre>
<p>これは、非同期リソース作成中にsokol-gfxの外部で何か問題が発生した場合（例えば、ファイルのロード操作に失敗したなど）に推奨されます。この場合、&apos;init関数&apos;の代わりに&apos;fail関数&apos;を呼び出す必要があります。</p>
<p>ALLOC状態でないリソースに対して「fail関数」を呼び出しても無駄ですが、警告のログメッセージは生成されます。</p>
<blockquote>
<p>注: 2段階のリソース作成は通常、バッファとイメージに対してのみ意味を持ちますが、シェーダ、パイプライン、パスに対しては意味を持ちません。特に、VALID状態でないシェーダーでパイプラインオブジェクトを作成しようとすると、検証レイヤーのエラーが発生します。また、検証レイヤーが無効になっている場合は、パイプラインオブジェクトがFAILED状態になります。イメージ無効のイメージオブジェクトでパスオブジェクトを作成しようとすると、同じことが起こります。</p>
</blockquote>
<h2 id="license">LICENSE</h2>
<p>zlib/libpng license</p>
<p>Copyright (c) 2018 Andre Weissflog</p>
<p>This software is provided &apos;as-is&apos;, without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.</p>
<p>Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:</p>
<pre><code>1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software in a
product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not
be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: はじめに">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="app.html" class="navigation navigation-next " aria-label="Next page: app">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"gfx","level":"2.1","depth":1,"next":{"title":"app","level":"2.2","depth":1,"path":"app.md","ref":"app.md","articles":[]},"previous":{"title":"はじめに","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"gfx.md","mtime":"2022-12-15T06:37:33.721Z","type":"markdown"},"gitbook":{"version":"4.0.4","time":"2022-12-15T06:38:06.519Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

