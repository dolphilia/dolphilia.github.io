
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>shape · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="color.html" />
    
    
    <link rel="prev" href="memtrack.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">目次</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    はじめに
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">コアライブラリ</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="gfx.html">
            
                <a href="gfx.html">
            
                    
                    gfx
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="app.html">
            
                <a href="app.html">
            
                    
                    app
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="time.html">
            
                <a href="time.html">
            
                    
                    time
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="audio.html">
            
                <a href="audio.html">
            
                    
                    audio
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="fetch.html">
            
                <a href="fetch.html">
            
                    
                    fetch
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="args.html">
            
                <a href="args.html">
            
                    
                    args
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="glue.html">
            
                <a href="glue.html">
            
                    
                    glue
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">ユーティリティ</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="imgui.html">
            
                <a href="imgui.html">
            
                    
                    imgui
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="nuklear.html">
            
                <a href="nuklear.html">
            
                    
                    nuklear
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="gl.html">
            
                <a href="gl.html">
            
                    
                    gl
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="fontstash.html">
            
                <a href="fontstash.html">
            
                    
                    fontstash
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="gfx_imgui.html">
            
                <a href="gfx_imgui.html">
            
                    
                    gfx_imgui
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="debugtext.html">
            
                <a href="debugtext.html">
            
                    
                    debugtext
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.7" data-path="memtrack.html">
            
                <a href="memtrack.html">
            
                    
                    memtrack
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.8" data-path="shape.html">
            
                <a href="shape.html">
            
                    
                    shape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.9" data-path="color.html">
            
                <a href="color.html">
            
                    
                    color
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.10" data-path="spine.html">
            
                <a href="spine.html">
            
                    
                    spine
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >shape</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>sokol_shape.h -- create simple primitive shapes for sokol_gfx.h</p>
<p>Project URL: <a href="https://github.com/floooh/sokol" target="_blank">https://github.com/floooh/sokol</a></p>
<p>Do this:</p>
<pre><code>#define SOKOL_IMPL or
#define SOKOL_SHAPE_IMPL
</code></pre><p>before you include this file in <em>one</em> C or C++ file to create the
implementation.</p>
<p>Include the following headers before including sokol_shape.h:</p>
<pre><code>sokol_gfx.h
</code></pre><p>...optionally provide the following macros to override defaults:</p>
<p>SOKOL_ASSERT(c)     - your own assert macro (default: assert(c))
SOKOL_SHAPE_API_DECL- public function declaration prefix (default: extern)
SOKOL_API_DECL      - same as SOKOL_SHAPE_API_DECL
SOKOL_API_IMPL      - public function implementation prefix (default: -)</p>
<p>If sokol_shape.h is compiled as a DLL, define the following before
including the declaration or implementation:</p>
<p>SOKOL_DLL</p>
<p>On Windows, SOKOL_DLL will define SOKOL_SHAPE_API_DECL as <strong>declspec(dllexport)
or </strong>declspec(dllimport) as needed.</p>
<h1 id="feature-overview">FEATURE OVERVIEW</h1>
<p>sokol_shape.h creates vertices and indices for simple shapes and
builds structs which can be plugged into sokol-gfx resource
creation functions:</p>
<p>The following shape types are supported:</p>
<pre><code>- plane
- cube
- sphere (with poles, not geodesic)
- cylinder
- torus (donut)
</code></pre><p>Generated vertices look like this:</p>
<pre><code>typedef struct sshape_vertex_t {
    float x, y, z;
    uint32_t normal;        // packed normal as BYTE4N
    uint16_t u, v;          // packed uv coords as USHORT2N
    uint32_t color;         // packed color as UBYTE4N (r,g,b,a);
} sshape_vertex_t;
</code></pre><p>Indices are generally 16-bits wide (SG_INDEXTYPE_UINT16) and the indices
are written as triangle-lists (SG_PRIMITIVETYPE_TRIANGLES).</p>
<h1 id="examples">EXAMPLES:</h1>
<p>Create multiple shapes into the same vertex- and index-buffer and
render with separate draw calls:</p>
<p><a href="https://github.com/floooh/sokol-samples/blob/master/sapp/shapes-sapp.c" target="_blank">https://github.com/floooh/sokol-samples/blob/master/sapp/shapes-sapp.c</a></p>
<p>Same as the above, but pre-transform shapes and merge them into a single
shape that&apos;s rendered with a single draw call.</p>
<p><a href="https://github.com/floooh/sokol-samples/blob/master/sapp/shapes-transform-sapp.c" target="_blank">https://github.com/floooh/sokol-samples/blob/master/sapp/shapes-transform-sapp.c</a></p>
<h1 id="step-by-step">STEP-BY-STEP:</h1>
<p>Setup an sshape_buffer_t struct with pointers to memory buffers where
generated vertices and indices will be written to:</p>
<pre><code class="lang-c"><span class="hljs-keyword">sshape_vertex_t</span> vertices[<span class="hljs-number">512</span>];
<span class="hljs-keyword">uint16_t</span> indices[<span class="hljs-number">4096</span>];

<span class="hljs-keyword">sshape_buffer_t</span> buf = {
    .vertices = {
        .buffer = SSHAPE_RANGE(vertices),
    },
    .indices = {
        .buffer = SSHAPE_RANGE(indices),
    }
};
</code></pre>
<p>To find out how big those memory buffers must be (in case you want
to allocate dynamically) call the following functions:</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">sshape_sizes_t</span> <span class="hljs-title">sshape_plane_sizes</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> tiles)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_sizes_t</span> <span class="hljs-title">sshape_box_sizes</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> tiles)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_sizes_t</span> <span class="hljs-title">sshape_sphere_sizes</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> slices, <span class="hljs-keyword">uint32_t</span> stacks)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_sizes_t</span> <span class="hljs-title">sshape_cylinder_sizes</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> slices, <span class="hljs-keyword">uint32_t</span> stacks)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_sizes_t</span> <span class="hljs-title">sshape_torus_sizes</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> sides, <span class="hljs-keyword">uint32_t</span> rings)</span></span>;
</code></pre>
<p>The returned sshape_sizes_t struct contains vertex- and index-counts
as well as the equivalent buffer sizes in bytes. For instance:</p>
<pre><code class="lang-c"><span class="hljs-keyword">sshape_sizes_t</span> sizes = sshape_sphere_sizes(<span class="hljs-number">36</span>, <span class="hljs-number">12</span>);
<span class="hljs-keyword">uint32_t</span> num_vertices = sizes.vertices.num;
<span class="hljs-keyword">uint32_t</span> num_indices = sizes.indices.num;
<span class="hljs-keyword">uint32_t</span> vertex_buffer_size = sizes.vertices.size;
<span class="hljs-keyword">uint32_t</span> index_buffer_size = sizes.indices.size;
</code></pre>
<p>With the sshape_buffer_t struct that was setup earlier, call any
of the shape-builder functions:</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">sshape_buffer_t</span> <span class="hljs-title">sshape_build_plane</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf, <span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_plane_t</span>* params)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_buffer_t</span> <span class="hljs-title">sshape_build_box</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf, <span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_box_t</span>* params)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_buffer_t</span> <span class="hljs-title">sshape_build_sphere</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf, <span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_sphere_t</span>* params)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_buffer_t</span> <span class="hljs-title">sshape_build_cylinder</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf, <span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_cylinder_t</span>* params)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_buffer_t</span> <span class="hljs-title">sshape_build_torus</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf, <span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_torus_t</span>* params)</span></span>;
</code></pre>
<p>Note how the sshape_buffer_t struct is both an input value and the
return value. This can be used to append multiple shapes into the
same vertex- and index-buffers (more on this later).</p>
<p>The second argument is a struct which holds creation parameters.</p>
<p>For instance to build a sphere with radius 2, 36 &quot;cake slices&quot; and 12 stacks:</p>
<pre><code class="lang-c"><span class="hljs-keyword">sshape_buffer_t</span> buf = ...;
buf = sshape_build_sphere(&amp;buf, &amp;(<span class="hljs-keyword">sshape_sphere_t</span>){
    .radius = <span class="hljs-number">2.0f</span>,
    .slices = <span class="hljs-number">36</span>,
    .stacks = <span class="hljs-number">12</span>,
});
</code></pre>
<p>If the provided buffers are big enough to hold all generated vertices and
indices, the &quot;valid&quot; field in the result will be true:</p>
<pre><code class="lang-c">assert(buf.valid);
</code></pre>
<p>The shape creation parameters have &quot;useful defaults&quot;, refer to the
actual C struct declarations below to look up those defaults.</p>
<p>You can also provide additional creation parameters, like a common vertex
color, a debug-helper to randomize colors, tell the shape builder function
to merge the new shape with the previous shape into the same draw-element-range,
or a 4x4 transform matrix to move, rotate and scale the generated vertices:</p>
<pre><code class="lang-c"><span class="hljs-keyword">sshape_buffer_t</span> buf = ...;
buf = sshape_build_sphere(&amp;buf, &amp;(<span class="hljs-keyword">sshape_sphere_t</span>){
    .radius = <span class="hljs-number">2.0f</span>,
    .slices = <span class="hljs-number">36</span>,
    .stacks = <span class="hljs-number">12</span>,
    <span class="hljs-comment">// merge with previous shape into a single element-range</span>
    .merge = <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// set vertex color to red+opaque</span>
    .color = sshape_color_4f(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>),
    <span class="hljs-comment">// set position to y = 2.0</span>
    .transform = {
        .m = {
            { <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span> },
            { <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span> },
            { <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span> },
            { <span class="hljs-number">0.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> },
        }
    }
});
assert(buf.valid);
</code></pre>
<p>The following helper functions can be used to build a packed
color value or to convert from external matrix types:</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">sshape_color_4f</span><span class="hljs-params">(<span class="hljs-keyword">float</span> r, <span class="hljs-keyword">float</span> g, <span class="hljs-keyword">float</span> b, <span class="hljs-keyword">float</span> a)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">sshape_color_3f</span><span class="hljs-params">(<span class="hljs-keyword">float</span> r, <span class="hljs-keyword">float</span> g, <span class="hljs-keyword">float</span> b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">sshape_color_4b</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> r, <span class="hljs-keyword">uint8_t</span> g, <span class="hljs-keyword">uint8_t</span> b, <span class="hljs-keyword">uint8_t</span> a)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">sshape_color_3b</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> r, <span class="hljs-keyword">uint8_t</span> g, <span class="hljs-keyword">uint8_t</span> b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_mat4_t</span> <span class="hljs-title">sshape_mat4</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> m[<span class="hljs-number">16</span>])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sshape_mat4_t</span> <span class="hljs-title">sshape_mat4_transpose</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> m[<span class="hljs-number">16</span>])</span></span>;
</code></pre>
<p>After the shape builder function has been called, the following functions
are used to extract the build result for plugging into sokol_gfx.h:</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">sshape_element_range_t</span> <span class="hljs-title">sshape_element_range</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf)</span></span>;
<span class="hljs-function">sg_buffer_desc <span class="hljs-title">sshape_vertex_buffer_desc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf)</span></span>;
<span class="hljs-function">sg_buffer_desc <span class="hljs-title">sshape_index_buffer_desc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">sshape_buffer_t</span>* buf)</span></span>;
<span class="hljs-function">sg_buffer_layout_desc <span class="hljs-title">sshape_buffer_layout_desc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function">sg_vertex_attr_desc <span class="hljs-title">sshape_position_attr_desc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function">sg_vertex_attr_desc <span class="hljs-title">sshape_normal_attr_desc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function">sg_vertex_attr_desc <span class="hljs-title">sshape_texcoord_attr_desc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function">sg_vertex_attr_desc <span class="hljs-title">sshape_color_attr_desc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
</code></pre>
<p>The sshape_element_range_t struct contains the base-index and number of
indices which can be plugged into the sg_draw() call:</p>
<pre><code class="lang-c"><span class="hljs-keyword">sshape_element_range_t</span> elms = sshape_element_range(&amp;buf);
...
sg_draw(elms.base_element, elms.num_elements, <span class="hljs-number">1</span>);
</code></pre>
<p>To create sokol-gfx vertex- and index-buffers from the generated
shape data:</p>
<pre><code class="lang-c"><span class="hljs-comment">// create sokol-gfx vertex buffer</span>
sg_buffer_desc vbuf_desc = sshape_vertex_buffer_desc(&amp;buf);
sg_buffer vbuf = sg_make_buffer(&amp;vbuf_desc);

<span class="hljs-comment">// create sokol-gfx index buffer</span>
sg_buffer_desc ibuf_desc = sshape_index_buffer_desc(&amp;buf);
sg_buffer ibuf = sg_make_buffer(&amp;ibuf_desc);
</code></pre>
<p>The remaining functions are used to populate the vertex-layout item
in sg_pipeline_desc, note that these functions don&apos;t depend on the
created geometry, they always return the same result:</p>
<pre><code class="lang-c">sg_pipeline pip = sg_make_pipeline(&amp;(sg_pipeline_desc){
    .layout = {
        .buffers[<span class="hljs-number">0</span>] = sshape_buffer_layout_desc(),
        .attrs = {
            [<span class="hljs-number">0</span>] = sshape_position_attr_desc(),
            [<span class="hljs-number">1</span>] = ssape_normal_attr_desc(),
            [<span class="hljs-number">2</span>] = sshape_texcoord_attr_desc(),
            [<span class="hljs-number">3</span>] = sshape_color_attr_desc()
        }
    },
    ...
});
</code></pre>
<p>Note that you don&apos;t have to use all generated vertex attributes in the
pipeline&apos;s vertex layout, the sg_buffer_layout_desc struct returned
by sshape_buffer_layout_desc() contains the correct vertex stride
to skip vertex components.</p>
<h1 id="writing-multiple-shapes-into-the-same-buffer">WRITING MULTIPLE SHAPES INTO THE SAME BUFFER</h1>
<p>You can merge multiple shapes into the same vertex- and
index-buffers and either render them as a single shape, or
in separate draw calls.</p>
<p>To build a single shape made of two cubes which can be rendered
in a single draw-call:</p>
<pre><code>sshape_vertex_t vertices[128];
uint16_t indices[16];

sshape_buffer_t buf = {
    .vertices.buffer = SSHAPE_RANGE(vertices),
    .indices.buffer  = SSHAPE_RANGE(indices)
};

// first cube at pos x=-2.0 (with default size of 1x1x1)
buf = sshape_build_cube(&amp;buf, &amp;(sshape_box_t){
    .transform = {
        .m = {
            { 1.0f, 0.0f, 0.0f, 0.0f },
            { 0.0f, 1.0f, 0.0f, 0.0f },
            { 0.0f, 0.0f, 1.0f, 0.0f },
            {-2.0f, 0.0f, 0.0f, 1.0f },
        }
    }
});
// ...and append another cube at pos pos=+1.0
// NOTE the .merge = true, this tells the shape builder
// function to not advance the current shape start offset
buf = sshape_build_cube(&amp;buf, &amp;(sshape_box_t){
    .merge = true,
    .transform = {
        .m = {
            { 1.0f, 0.0f, 0.0f, 0.0f },
            { 0.0f, 1.0f, 0.0f, 0.0f },
            { 0.0f, 0.0f, 1.0f, 0.0f },
            {-2.0f, 0.0f, 0.0f, 1.0f },
        }
    }
});
assert(buf.valid);

// skipping buffer- and pipeline-creation...

sshape_element_range_t elms = sshape_element_range(&amp;buf);
sg_draw(elms.base_element, elms.num_elements, 1);
</code></pre><p>To render the two cubes in separate draw-calls, the element-ranges used
in the sg_draw() calls must be captured right after calling the
builder-functions:</p>
<pre><code class="lang-c"><span class="hljs-keyword">sshape_vertex_t</span> vertices[<span class="hljs-number">128</span>];
<span class="hljs-keyword">uint16_t</span> indices[<span class="hljs-number">16</span>];
<span class="hljs-keyword">sshape_buffer_t</span> buf = {
    .vertices.buffer = SSHAPE_RANGE(vertices),
    .indices.buffer = SSHAPE_RANGE(indices)
};

<span class="hljs-comment">// build a red cube...</span>
buf = sshape_build_cube(&amp;buf, &amp;(<span class="hljs-keyword">sshape_box_t</span>){
    .color = sshape_color_3b(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
});
<span class="hljs-keyword">sshape_element_range_t</span> red_cube = sshape_element_range(&amp;buf);

<span class="hljs-comment">// append a green cube to the same vertex-/index-buffer:</span>
buf = sshape_build_cube(&amp;bud, &amp;<span class="hljs-keyword">sshape_box_t</span>){
    .color = sshape_color_3b(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);
});
<span class="hljs-keyword">sshape_element_range_t</span> green_cube = sshape_element_range(&amp;buf);

<span class="hljs-comment">// skipping buffer- and pipeline-creation...</span>

sg_draw(red_cube.base_element, red_cube.num_elements, <span class="hljs-number">1</span>);
sg_draw(green_cube.base_element, green_cube.num_elements, <span class="hljs-number">1</span>);
</code></pre>
<p>...that&apos;s about all :)</p>
<h1 id="license">LICENSE</h1>
<p>zlib/libpng license</p>
<p>Copyright (c) 2020 Andre Weissflog</p>
<p>This software is provided &apos;as-is&apos;, without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.</p>
<p>Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:</p>
<pre><code>1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software in a
product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not
be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="memtrack.html" class="navigation navigation-prev " aria-label="Previous page: memtrack">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="color.html" class="navigation navigation-next " aria-label="Next page: color">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"shape","level":"3.8","depth":1,"next":{"title":"color","level":"3.9","depth":1,"path":"color.md","ref":"color.md","articles":[]},"previous":{"title":"memtrack","level":"3.7","depth":1,"path":"memtrack.md","ref":"memtrack.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"shape.md","mtime":"2022-12-13T01:54:37.736Z","type":"markdown"},"gitbook":{"version":"4.0.4","time":"2022-12-15T06:38:06.519Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

