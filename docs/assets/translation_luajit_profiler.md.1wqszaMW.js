import{_ as e,o as t,c as i,R as a}from"./chunks/framework.c2IVng1e.js";const m=JSON.parse('{"title":"Profiler","description":"","frontmatter":{},"headers":[],"relativePath":"translation/luajit/profiler.md","filePath":"translation/luajit/profiler.md","lastUpdated":null}'),s={name:"translation/luajit/profiler.md"},l=a('<h1 id="profiler" tabindex="-1">Profiler <a class="header-anchor" href="#profiler" aria-label="Permalink to &quot;Profiler&quot;">​</a></h1><p>LuaJIT has an integrated statistical profiler with very low overhead. It allows sampling the currently executing stack and other parameters in regular intervals.</p><ul><li>The integrated profiler can be accessed from three levels: The bundled high-level profiler, invoked by the -jp command line option.</li><li>A low-level Lua API to control the profiler.</li><li>A low-level C API to control the profiler.</li></ul><h2 id="high-level-profiler" tabindex="-1">High-Level Profiler <a class="header-anchor" href="#high-level-profiler" aria-label="Permalink to &quot;High-Level Profiler&quot;">​</a></h2><p>The bundled high-level profiler offers basic profiling functionality. It generates simple textual summaries or source code annotations. It can be accessed with the -jp command line option or from Lua code by loading the underlying jit.p module.</p><p>To cut to the chase — run this to get a CPU usage profile by function name:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">luajit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> myapp.lua</span></span></code></pre></div><p>It&#39;s not a stated goal of the bundled profiler to add every possible option or to cater for special profiling needs. The low-level profiler APIs are documented below. They may be used by third-party authors to implement advanced functionality, e.g. IDE integration or graphical profilers.</p><div class="info custom-block"><p class="custom-block-title">Note</p><p>Sampling works for both interpreted and JIT-compiled code. The results for JIT-compiled code may sometimes be surprising. LuaJIT heavily optimizes and inlines Lua code — there&#39;s no simple one-to-one correspondence between source code lines and the sampled machine code.</p></div><h4 id="jp-options-output" tabindex="-1"><code>-jp=[options[,output]]</code> <a class="header-anchor" href="#jp-options-output" aria-label="Permalink to &quot;`-jp=[options[,output]]`&quot;">​</a></h4><p>The -jp command line option starts the high-level profiler. When the application run by the command line terminates, the profiler stops and writes the results to stdout or to the specified output file.</p><p>The options argument specifies how the profiling is to be performed:</p><ul><li>f — Stack dump: function name, otherwise module:line. This is the default mode.</li><li>F — Stack dump: ditto, but dump module:name.</li><li>l — Stack dump: module:line.</li><li><code>&lt;number&gt;</code> — stack dump depth (callee ← caller). Default: 1.</li><li><code>-&lt;number&gt;</code> — Inverse stack dump depth (caller → callee).</li><li>s — Split stack dump after first stack level. Implies depth ≥ 2 or depth ≤ -2.</li><li>p — Show full path for module names.</li><li>v — Show VM states.</li><li>z — Show zones.</li><li>r — Show raw sample counts. Default: show percentages.</li><li>a — Annotate excerpts from source code files.</li><li>A — Annotate complete source code files.</li><li>G — Produce raw output suitable for graphical tools.</li><li><code>m&lt;number&gt;</code> — Minimum sample percentage to be shown. Default: 3%.</li><li><code>i&lt;number&gt;</code> — Sampling interval in milliseconds. Default: 10ms.</li></ul><div class="info custom-block"><p class="custom-block-title">Note</p><p>The actual sampling precision is OS-dependent.</p></div><p>The default output for -jp is a list of the most CPU consuming spots in the application. Increasing the stack dump depth with (say) -jp=2 may help to point out the main callers or callees of hotspots. But sample aggregation is still flat per unique stack dump.</p><p>To get a two-level view (split view) of callers/callees, use -jp=s or -jp=-s. The percentages shown for the second level are relative to the first level.</p><p>To see how much time is spent in each line relative to a function, use -jp=fl.</p><p>To see how much time is spent in different VM states or zones, use -jp=v or -jp=z.</p><p>Combinations of v/z with f/F/l produce two-level views, e.g. -jp=vf or -jp=fv. This shows the time spent in a VM state or zone vs. hotspots. This can be used to answer questions like &quot;Which time-consuming functions are only interpreted?&quot; or &quot;What&#39;s the garbage collector overhead for a specific function?&quot;.</p><p>Multiple options can be combined — but not all combinations make sense, see above. E.g. -jp=3si4m1 samples three stack levels deep in 4ms intervals and shows a split view of the CPU consuming functions and their callers with a 1% threshold.</p><p>Source code annotations produced by -jp=a or -jp=A are always flat and at the line level. Obviously, the source code files need to be readable by the profiler script.</p><p>The high-level profiler can also be started and stopped from Lua code with:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jit.p&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options, output)</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jit.p&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h4 id="jit-zone-—-zones" tabindex="-1">jit.zone — Zones <a class="header-anchor" href="#jit-zone-—-zones" aria-label="Permalink to &quot;jit.zone — Zones&quot;">​</a></h4><p>Zones can be used to provide information about different parts of an application to the high-level profiler. E.g. a game could make use of an &quot;AI&quot; zone, a &quot;PHYS&quot; zone, etc. Zones are hierarchical, organized as a stack.</p><p>The jit.zone module needs to be loaded explicitly:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zone </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jit.zone&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li>zone(&quot;name&quot;) pushes a named zone to the zone stack.</li><li>zone() pops the current zone from the zone stack and returns its name.</li><li>zone:get() returns the current zone name or nil.</li><li>zone:flush() flushes the zone stack.</li></ul><p>To show the time spent in each zone use -jp=z. To show the time spent relative to hotspots use e.g. -jp=zf or -jp=fz.</p><h2 id="low-level-lua-api" tabindex="-1">Low-level Lua API <a class="header-anchor" href="#low-level-lua-api" aria-label="Permalink to &quot;Low-level Lua API&quot;">​</a></h2><p>The jit.profile module gives access to the low-level API of the profiler from Lua code. This module needs to be loaded explicitly:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> profile </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jit.profile&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This module can be used to implement your own higher-level profiler. A typical profiling run starts the profiler, captures stack dumps in the profiler callback, adds them to a hash table to aggregate the number of samples, stops the profiler and then analyzes all captured stack dumps. Other parameters can be sampled in the profiler callback, too. But it&#39;s important not to spend too much time in the callback, since this may skew the statistics.</p><h4 id="profile-start-mode-cb-—-start-profiler" tabindex="-1">profile.start(mode, cb) — Start profiler <a class="header-anchor" href="#profile-start-mode-cb-—-start-profiler" aria-label="Permalink to &quot;profile.start(mode, cb) — Start profiler&quot;">​</a></h4><p>This function starts the profiler. The mode argument is a string holding options:</p><ul><li>f — Profile with precision down to the function level.</li><li>l — Profile with precision down to the line level.</li><li><code>i&lt;number&gt;</code> — Sampling interval in milliseconds (default 10ms).</li></ul><div class="info custom-block"><p class="custom-block-title">Note</p><p>The actual sampling precision is OS-dependent.</p></div><p>The cb argument is a callback function which is called with three arguments: (thread, samples, vmstate). The callback is called on a separate coroutine, the thread argument is the state that holds the stack to sample for profiling. Note: do not modify the stack of that state or call functions on it.</p><p>samples gives the number of accumulated samples since the last callback (usually 1).</p><p>vmstate holds the VM state at the time the profiling timer triggered. This may or may not correspond to the state of the VM when the profiling callback is called. The state is either &#39;N&#39; native (compiled) code, &#39;I&#39; interpreted code, &#39;C&#39; C code, &#39;G&#39; the garbage collector, or &#39;J&#39; the JIT compiler.</p><h4 id="profile-stop-—-stop-profiler" tabindex="-1">profile.stop() — Stop profiler <a class="header-anchor" href="#profile-stop-—-stop-profiler" aria-label="Permalink to &quot;profile.stop() — Stop profiler&quot;">​</a></h4><p>This function stops the profiler.</p><h4 id="dump-profile-dumpstack-thread-fmt-depth-—-dump-stack" tabindex="-1"><code>dump = profile.dumpstack([thread,] fmt, depth)</code> — Dump stack <a class="header-anchor" href="#dump-profile-dumpstack-thread-fmt-depth-—-dump-stack" aria-label="Permalink to &quot;`dump = profile.dumpstack([thread,] fmt, depth)` — Dump stack&quot;">​</a></h4><p>This function allows taking stack dumps in an efficient manner. It returns a string with a stack dump for the thread (coroutine), formatted according to the fmt argument:</p><ul><li>p — Preserve the full path for module names. Otherwise, only the file name is used.</li><li>f — Dump the function name if it can be derived. Otherwise, use module:line.</li><li>F — Ditto, but dump module:name.</li><li>l — Dump module:line.</li><li>Z — Zap the following characters for the last dumped frame.</li><li>All other characters are added verbatim to the output string.</li></ul><p>The depth argument gives the number of frames to dump, starting at the topmost frame of the thread. A negative number dumps the frames in inverse order.</p><p>The first example prints a list of the current module names and line numbers of up to 10 frames in separate lines. The second example prints semicolon-separated function names for all frames (up to 100) in inverse order:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(profile.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dumpstack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thread, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;l</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(profile.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dumpstack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thread, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;lZ;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><h2 id="low-level-c-api" tabindex="-1">Low-level C API <a class="header-anchor" href="#low-level-c-api" aria-label="Permalink to &quot;Low-level C API&quot;">​</a></h2><p>The profiler can be controlled directly from C code, e.g. for use by IDEs. The declarations are in &quot;luajit.h&quot; (see Lua/C API extensions).</p><h4 id="luajit-profile-start-l-mode-cb-data-—-start-profiler" tabindex="-1">luaJIT_profile_start(L, mode, cb, data) — Start profiler <a class="header-anchor" href="#luajit-profile-start-l-mode-cb-data-—-start-profiler" aria-label="Permalink to &quot;luaJIT_profile_start(L, mode, cb, data) — Start profiler&quot;">​</a></h4><p>This function starts the profiler. See above for a description of the mode argument.</p><p>The cb argument is a callback function with the following declaration:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">luaJIT_profile_callback)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data, lua_State </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">L, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> samples, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vmstate);</span></span></code></pre></div><p>data is available for use by the callback. L is the state that holds the stack to sample for profiling. Note: do not modify this stack or call functions on this stack — use a separate coroutine for this purpose. See above for a description of samples and vmstate.</p><h4 id="luajit-profile-stop-l-—-stop-profiler" tabindex="-1">luaJIT_profile_stop(L) — Stop profiler <a class="header-anchor" href="#luajit-profile-stop-l-—-stop-profiler" aria-label="Permalink to &quot;luaJIT_profile_stop(L) — Stop profiler&quot;">​</a></h4><p>This function stops the profiler.</p><h4 id="p-luajit-profile-dumpstack-l-fmt-depth-len-—-dump-stack" tabindex="-1">p = luaJIT_profile_dumpstack(L, fmt, depth, len) — Dump stack <a class="header-anchor" href="#p-luajit-profile-dumpstack-l-fmt-depth-len-—-dump-stack" aria-label="Permalink to &quot;p = luaJIT_profile_dumpstack(L, fmt, depth, len) — Dump stack&quot;">​</a></h4><p>This function allows taking stack dumps in an efficient manner. See above for a description of fmt and depth.</p><p>This function returns a const char * pointing to a private string buffer of the profiler. The int *len argument returns the length of the output string. The buffer is overwritten on the next call and deallocated when the profiler stops. You either need to consume the content immediately or copy it for later use.</p>',60),o=[l];function n(p,r,h,d,c,u){return t(),i("div",null,o)}const f=e(s,[["render",n]]);export{m as __pageData,f as default};
