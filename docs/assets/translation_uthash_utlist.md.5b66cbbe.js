import{_ as e,o as a,c as n,R as t}from"./chunks/framework.320df067.js";const C=JSON.parse('{"title":"utlist: C構造体用リンクリストマクロ","description":"","frontmatter":{},"headers":[],"relativePath":"translation/uthash/utlist.md","filePath":"translation/uthash/utlist.md","lastUpdated":1687420112000}'),s={name:"translation/uthash/utlist.md"},l=t(`<h1 id="utlist-c構造体用リンクリストマクロ" tabindex="-1">utlist: C構造体用リンクリストマクロ <a class="header-anchor" href="#utlist-c構造体用リンクリストマクロ" aria-label="Permalink to &quot;utlist: C構造体用リンクリストマクロ&quot;">​</a></h1><ul><li>Troy D. Hanson <a href="mailto:tdh@tkhanson.net" target="_blank" rel="noreferrer">tdh@tkhanson.net</a></li><li>v2.3.0, February 2021</li></ul><p><a href="https://github.com/troydhanson/uthash" target="_blank" rel="noreferrer">GitHubプロジェクトページ</a>へのリンクです。</p><h2 id="はじめに" tabindex="-1">はじめに <a class="header-anchor" href="#はじめに" aria-label="Permalink to &quot;はじめに&quot;">​</a></h2><p><code>utlist.h</code>には、uthashと一緒にCの構造体のための汎用の「リンクリスト」マクロが含まれている。これらのマクロを自分のCプログラムで使うには、<code>utlist.h</code>をソースディレクトリにコピーして、自分のプログラムで使うだけでよい。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">utlist.h</span><span style="color:#89DDFF;">&quot;</span></span></code></pre></div><p>これらのマクロは、基本的なリンクリストの操作（要素の追加と削除、ソート、繰り返し）をサポートしている。</p><h3 id="ダウンロード" tabindex="-1">ダウンロード <a class="header-anchor" href="#ダウンロード" aria-label="Permalink to &quot;ダウンロード&quot;">​</a></h3><p><code>utlist.h</code>ヘッダーファイルをダウンロードするには、<a href="https://github.com/troydhanson/uthash" target="_blank" rel="noreferrer">https://github.com/troydhanson/uthash</a> のリンクに従ってuthashをクローンするか、zipファイルを入手し、src/サブディレクトリを探す。</p><h3 id="bsdライセンス" tabindex="-1">BSDライセンス <a class="header-anchor" href="#bsdライセンス" aria-label="Permalink to &quot;BSDライセンス&quot;">​</a></h3><p>このソフトウェアは、license.html (revised BSD license)というリンクの下で利用可能です。フリーでオープンソースです。</p><h3 id="プラットフォーム" tabindex="-1">プラットフォーム <a class="header-anchor" href="#プラットフォーム" aria-label="Permalink to &quot;プラットフォーム&quot;">​</a></h3><p>utlist&#39;マクロは以下のプラットフォームでテストされている：</p><ul><li>Linux</li><li>Mac OS X</li><li>Windows, using Visual Studio 2008, Visual Studio 2010, or Cygwin/MinGW.</li></ul><h2 id="utlistを使う" tabindex="-1">utlistを使う <a class="header-anchor" href="#utlistを使う" aria-label="Permalink to &quot;utlistを使う&quot;">​</a></h2><h3 id="リストの種類" tabindex="-1">リストの種類 <a class="header-anchor" href="#リストの種類" aria-label="Permalink to &quot;リストの種類&quot;">​</a></h3><p>3種類のリンクリストがサポートされている：</p><ul><li><em>singly-linked</em> lists,</li><li><em>doubly-linked</em> lists, and</li><li><em>circular, doubly-linked</em> lists</li></ul><h4 id="効率性" tabindex="-1">効率性 <a class="header-anchor" href="#効率性" aria-label="Permalink to &quot;効率性&quot;">​</a></h4><p>Prepending elements::</p><p>Constant-time on all list types.</p><p>Appending::</p><p>&#39;O(n)&#39; on singly-linked lists; constant-time on doubly-linked list. (The utlist implementation of the doubly-linked list keeps a tail pointer in <code>head-&gt;prev</code> so that append can be done in constant time).</p><p>Deleting elements::</p><p>&#39;O(n)&#39; on singly-linked lists; constant-time on doubly-linked list.</p><p>Sorting::</p><p>&#39;O(n log(n))&#39; for all list types.</p><p>Insertion in order (for sorted lists)::</p><p>&#39;O(n)&#39; for all list types. Iteration, counting and searching::</p><p>&#39;O(n)&#39; for all list types.</p><h3 id="リスト要素" tabindex="-1">リスト要素 <a class="header-anchor" href="#リスト要素" aria-label="Permalink to &quot;リスト要素&quot;">​</a></h3><p>これらのマクロでは、構造体に <code>next</code> ポインタが含まれていれば、どのような構造体でも使用することができます。二重にリンクされたリストを作りたい場合は、要素にも <code>prev</code> ポインタが必要です。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">typedef</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> element </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">char</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> element </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">prev</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> /* 二重リンクリストにのみ必要 */</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> element </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;">next</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;"> /* 単一または二重リンクリストに必要 */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> element</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>構造体の名前は何でもいい。上の例では<code>element</code>と呼んでいる。特定のリスト内では、すべての要素は同じ型でなければならない。</p><h5 id="flexible-prev-next-naming" tabindex="-1">Flexible prev/next naming <a class="header-anchor" href="#flexible-prev-next-naming" aria-label="Permalink to &quot;Flexible prev/next naming&quot;">​</a></h5><p>You can name your <code>prev</code> and <code>next</code> pointers something else. If you do, there is a &lt;&lt;flex_names,family of macros&gt;&gt; that work identically but take these names as extra arguments.</p><h3 id="list-head" tabindex="-1">List head <a class="header-anchor" href="#list-head" aria-label="Permalink to &quot;List head&quot;">​</a></h3><p>The list head is simply a pointer to your element structure. You can name it anything. <em>It must be initialized to <code>NULL</code></em>.</p><p>element *head = NULL;</p><h3 id="list-operations" tabindex="-1">List operations <a class="header-anchor" href="#list-operations" aria-label="Permalink to &quot;List operations&quot;">​</a></h3><p>The lists support inserting or deleting elements, sorting the elements and iterating over them.</p><p>[width=&quot;100%&quot;,cols=&quot;10&lt;m,10&lt;m,10&lt;m&quot;,grid=&quot;cols&quot;,options=&quot;header&quot;] |=============================================================================== |Singly-linked | Doubly-linked | Circular, doubly-linked |LL_PREPEND(head,add); | DL_PREPEND(head,add); | CDL_PREPEND(head,add); |LL_PREPEND_ELEM(head,ref,add); | DL_PREPEND_ELEM(head,ref,add); | CDL_PREPEND_ELEM(head,ref,add); |LL_APPEND_ELEM(head,ref,add); | DL_APPEND_ELEM(head,ref,add); | CDL_APPEND_ELEM(head,ref,add); |LL_REPLACE_ELEM(head,del,add); | DL_REPLACE_ELEM(head,del,add); | CDL_REPLACE_ELEM(head,del,add); |LL_APPEND(head,add); | DL_APPEND(head,add); | CDL_APPEND(head,add); |LL_INSERT_INORDER(head,add,cmp); | DL_INSERT_INORDER(head,add,cmp); | CDL_INSERT_INORDER(head,add,cmp); |LL_CONCAT(head1,head2); | DL_CONCAT(head1,head2); | |LL_DELETE(head,del); | DL_DELETE(head,del); | CDL_DELETE(head,del); |LL_SORT(head,cmp); | DL_SORT(head,cmp); | CDL_SORT(head,cmp); |LL_FOREACH(head,elt) {...}| DL_FOREACH(head,elt) {...} | CDL_FOREACH(head,elt) {...} |LL_FOREACH_SAFE(head,elt,tmp) {...}| DL_FOREACH_SAFE(head,elt,tmp) {...} | CDL_FOREACH_SAFE(head,elt,tmp1,tmp2) {...} |LL_SEARCH_SCALAR(head,elt,mbr,val);| DL_SEARCH_SCALAR(head,elt,mbr,val); | CDL_SEARCH_SCALAR(head,elt,mbr,val); |LL_SEARCH(head,elt,like,cmp);| DL_SEARCH(head,elt,like,cmp); | CDL_SEARCH(head,elt,like,cmp); |LL_LOWER_BOUND(head,elt,like,cmp); | DL_LOWER_BOUND(head,elt,like,cmp); | CDL_LOWER_BOUND(head,elt,like,cmp); |LL_COUNT(head,elt,count); | DL_COUNT(head,elt,count); | CDL_COUNT(head,elt,count); |===============================================================================</p><p>&#39;Prepend&#39; means to insert an element in front of the existing list head (if any), changing the list head to the new element. &#39;Append&#39; means to add an element at the end of the list, so it becomes the new tail element. &#39;Concatenate&#39; takes two properly constructed lists and appends the second list to the first. (Visual Studio 2008 does not support <code>LL_CONCAT</code> and <code>DL_CONCAT</code>, but VS2010 is ok.) To prepend before an arbitrary element instead of the list head, use the <code>_PREPEND_ELEM</code> macro family. To append after an arbitrary element element instead of the list head, use the <code>_APPEND_ELEM</code> macro family. To &#39;replace&#39; an arbitrary list element with another element use the <code>_REPLACE_ELEM</code> family of macros.</p><p>The &#39;sort&#39; operation never moves the elements in memory; rather it only adjusts the list order by altering the <code>prev</code> and <code>next</code> pointers in each element. Also the sort operation can change the list head to point to a new element.</p><p>The &#39;foreach&#39; operation is for easy iteration over the list from the head to the tail. A usage example is shown below. You can of course just use the <code>prev</code> and <code>next</code> pointers directly instead of using the &#39;foreach&#39; macros. The &#39;foreach_safe&#39; operation should be used if you plan to delete any of the list elements while iterating.</p><p>The &#39;search&#39; operation is a shortcut for iteration in search of a particular element. It is not any faster than manually iterating and testing each element. There are two forms: the &quot;scalar&quot; version searches for an element using a simple equality test on a given structure member, while the general version takes an element to which all others in the list will be compared using a <code>cmp</code> function.</p><p>The &#39;lower_bound&#39; operation finds the first element of the list which is no greater than the provided <code>like</code> element, according to the provided <code>cmp</code> function. The &#39;lower_bound&#39; operation sets <code>elt</code> to a suitable value for passing to <code>LL_APPEND_ELEM</code>; i.e., <code>elt=NULL</code> if the proper insertion point is at the front of the list, and <code>elt=p</code> if the proper insertion point is between <code>p</code> and <code>p-&gt;next</code>.</p><p>The &#39;count&#39; operation iterates over the list and increments a supplied counter.</p><p>The parameters shown in the table above are explained here:</p><p>head:: The list head (a pointer to your list element structure). add:: A pointer to the list element structure you are adding to the list. del:: A pointer to the list element structure you are replacing or deleting from the list. elt:: A pointer that will be assigned to each list element in succession (see example) in the case of iteration macros; or, the output pointer from the search macros. ref:: Reference element for prepend and append operations that will be prepended before or appended after. If <code>ref</code> is a pointer with value NULL, the new element will be appended to the list for _PREPEND_ELEM() operations and prepended for _APPEND_ELEM() operations. <code>ref</code> must be the name of a pointer variable and cannot be literally NULL, use _PREPEND() and _APPEND() macro family instead. like:: An element pointer, having the same type as <code>elt</code>, for which the search macro seeks a match (if found, the match is stored in <code>elt</code>). A match is determined by the given <code>cmp</code> function. cmp:: pointer to comparison function which accepts two arguments-- these are pointers to two element structures to be compared. The comparison function must return an <code>int</code> that is negative, zero, or positive, which specifies whether the first item should sort before, equal to, or after the second item, respectively. (In other words, the same convention that is used by <code>strcmp</code>). Note that under Visual Studio 2008 you may need to declare the two arguments as <code>void *</code> and then cast them back to their actual types. tmp:: A pointer of the same type as <code>elt</code>. Used internally. Need not be initialized. mbr:: In the scalar search macro, the name of a member within the <code>elt</code> structure which will be tested (using <code>==</code>) for equality with the value <code>val</code>. val:: In the scalar search macro, specifies the value of (of structure member <code>field</code>) of the element being sought. count:: integer which will be set to the length of the list</p><p>Example</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">This example program reads names from a text file (one name per line), and</span></span>
<span class="line"><span style="color:#A6ACCD;">appends each name to a doubly-linked list. Then it sorts and prints them.</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">.A doubly-linked list</span></span>
<span class="line"><span style="color:#A6ACCD;">--------------------------------------------------------------------------------</span></span>
<span class="line"><span style="color:#A6ACCD;">#include &lt;stdio.h&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">#include &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">#include &lt;string.h&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">#include &quot;utlist.h&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">#define BUFLEN 20</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">typedef struct el {</span></span>
<span class="line"><span style="color:#A6ACCD;">    char bname[BUFLEN];</span></span>
<span class="line"><span style="color:#A6ACCD;">    struct el *next, *prev;</span></span>
<span class="line"><span style="color:#A6ACCD;">} el;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">int namecmp(el *a, el *b) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return strcmp(a-&gt;bname,b-&gt;bname);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">el *head = NULL; /* important- initialize to NULL! */</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">int main(int argc, char *argv[]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    el *name, *elt, *tmp, etmp;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    char linebuf[BUFLEN];</span></span>
<span class="line"><span style="color:#A6ACCD;">    int count;</span></span>
<span class="line"><span style="color:#A6ACCD;">    FILE *file;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    if ( (file = fopen( &quot;test11.dat&quot;, &quot;r&quot; )) == NULL ) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        perror(&quot;can&#39;t open: &quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        exit(-1);</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    while (fgets(linebuf,BUFLEN,file) != NULL) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if ( (name = (el *)malloc(sizeof *name)) == NULL) exit(-1);</span></span>
<span class="line"><span style="color:#A6ACCD;">        strcpy(name-&gt;bname, linebuf);</span></span>
<span class="line"><span style="color:#A6ACCD;">        DL_APPEND(head, name);</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    DL_SORT(head, namecmp);</span></span>
<span class="line"><span style="color:#A6ACCD;">    DL_FOREACH(head,elt) printf(&quot;%s&quot;, elt-&gt;bname);</span></span>
<span class="line"><span style="color:#A6ACCD;">    DL_COUNT(head, elt, count);</span></span>
<span class="line"><span style="color:#A6ACCD;">    printf(&quot;%d number of elements in list\\n&quot;, count);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    memcpy(&amp;etmp.bname, &quot;WES\\n&quot;, 5);</span></span>
<span class="line"><span style="color:#A6ACCD;">    DL_SEARCH(head,elt,&amp;etmp,namecmp);</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (elt) printf(&quot;found %s\\n&quot;, elt-&gt;bname);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    /* now delete each element, use the safe iterator */</span></span>
<span class="line"><span style="color:#A6ACCD;">    DL_FOREACH_SAFE(head,elt,tmp) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      DL_DELETE(head,elt);</span></span>
<span class="line"><span style="color:#A6ACCD;">      free(elt);</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    fclose(file);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    return 0;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">--------------------------------------------------------------------------------</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">[[flex_names]]</span></span>
<span class="line"><span style="color:#A6ACCD;">Other names for prev and next</span></span></code></pre></div><p>If the <code>prev</code> and <code>next</code> fields are named something else, a separate group of macros must be used. These work the same as the regular macros, but take the field names as extra parameters.</p><p>These &quot;flexible field name&quot; macros are shown below. They all end with <code>2</code>. Each operates the same as its counterpart without the <code>2</code>, but they take the name of the <code>prev</code> and <code>next</code> fields (as applicable) as trailing arguments.</p><p>[width=&quot;100%&quot;,cols=&quot;10&lt;m,10&lt;m,10&lt;m&quot;,grid=&quot;cols&quot;,options=&quot;header&quot;] |=============================================================================== |Singly-linked | Doubly-linked | Circular, doubly-linked |LL_PREPEND2(head,add,next); | DL_PREPEND2(head,add,prev,next); | CDL_PREPEND2(head,add,prev,next); |LL_PREPEND_ELEM2(head,ref,add,next); | DL_PREPEND_ELEM2(head,ref,add,prev,next); | CDL_PREPEND_ELEM2(head,ref,add,prev,next); |LL_APPEND_ELEM2(head,ref,add,next); | DL_APPEND_ELEM2(head,ref,add,prev,next); | CDL_APPEND_ELEM2(head,ref,add,prev,next); |LL_REPLACE_ELEM2(head,del,add,next); | DL_REPLACE_ELEM2(head,del,add,prev,next); | CDL_REPLACE_ELEM2(head,del,add,prev,next); |LL_APPEND2(head,add,next); | DL_APPEND2(head,add,prev,next); | CDL_APPEND2(head,add,prev,next); |LL_INSERT_INORDER2(head,add,cmp,next); | DL_INSERT_INORDER2(head,add,cmp,prev,next); | CDL_INSERT_INORDER2(head,add,cmp,prev,next); |LL_CONCAT2(head1,head2,next); | DL_CONCAT2(head1,head2,prev,next); | |LL_DELETE2(head,del,next); | DL_DELETE2(head,del,prev,next); | CDL_DELETE2(head,del,prev,next); |LL_SORT2(head,cmp,next); | DL_SORT2(head,cmp,prev,next); | CDL_SORT2(head,cmp,prev,next); |LL_FOREACH2(head,elt,next) {...} | DL_FOREACH2(head,elt,next) {...} | CDL_FOREACH2(head,elt,next) {...} |LL_FOREACH_SAFE2(head,elt,tmp,next) {...} | DL_FOREACH_SAFE2(head,elt,tmp,next) {...} | CDL_FOREACH_SAFE2(head,elt,tmp1,tmp2,prev,next) {...} |LL_SEARCH_SCALAR2(head,elt,mbr,val,next); | DL_SEARCH_SCALAR2(head,elt,mbr,val,next); | CDL_SEARCH_SCALAR2(head,elt,mbr,val,next); |LL_SEARCH2(head,elt,like,cmp,next); | DL_SEARCH2(head,elt,like,cmp,next); | CDL_SEARCH2(head,elt,like,cmp,next); |LL_LOWER_BOUND2(head,elt,like,cmp,next); | DL_LOWER_BOUND2(head,elt,like,cmp,next); | CDL_LOWER_BOUND2(head,elt,like,cmp,next); |LL_COUNT2(head,elt,count,next); | DL_COUNT2(head,elt,count,next); | CDL_COUNT2(head,elt,count,next); |===============================================================================</p><p>// vim: set tw=80 wm=2 syntax=asciidoc:</p>`,56),o=[l];function p(i,r,d,c,h,m){return a(),n("div",null,o)}const A=e(s,[["render",p]]);export{C as __pageData,A as default};
