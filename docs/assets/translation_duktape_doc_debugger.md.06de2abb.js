import{_ as e,c as a,o as t,Q as s}from"./chunks/framework.44f152d8.js";const g=JSON.parse('{"title":"Duktapeデバッガ","description":"","frontmatter":{},"headers":[],"relativePath":"translation/duktape/doc/debugger.md","lastUpdated":1676129847000}'),o={name:"translation/duktape/doc/debugger.md"},n=s(`<h1 id="duktapeデバッガ" tabindex="-1">Duktapeデバッガ <a class="header-anchor" href="#duktapeデバッガ" aria-label="Permalink to &quot;Duktapeデバッガ&quot;">​</a></h1><h2 id="はじめに" tabindex="-1">はじめに <a class="header-anchor" href="#はじめに" aria-label="Permalink to &quot;はじめに&quot;">​</a></h2><h3 id="概要" tabindex="-1">概要 <a class="header-anchor" href="#概要" aria-label="Permalink to &quot;概要&quot;">​</a></h3><p>Duktapeには、以下の基本的なデバッグ機能があります。</p><ul><li>実行状況：ファイル/ラインでの実行/一時停止、コールスタック、ローカル変数</li><li>実行制御：一時停止、再開、ステップオーバー、ステップイン、ステップアウト</li><li>ブレークポイント：対象となるファイル/行のペア、ブレークポイントリスト、&quot;debugger &quot;ステートメント</li><li>一時停止中にコールスタック上の任意の活性化のコンテキストで評価（基本的なウォッチ式の実装に使用可能）</li><li>内部メタデータ、プロパティを列挙してヒープオブジェクトを検査し、プロトタイプチェーンを歩く</li><li>任意のコールスタックレベルで変数を取得/配置する。</li><li>アプリケーション定義のリクエスト（AppRequest）および通知（AppNotify）のためのメカニズム</li><li>ロガーの書き込みを転送する</li><li>ヒープフルダンプ（デバッガーのウェブUIでJSONに変換される）</li></ul><p>Duktapeのデバッグ・アーキテクチャは、以下の主要な部分から構成されています。</p><ul><li>Duktapeが直接実装する標準的な<strong>デバッグ・プロトコル</strong>です。</li><li>アプリケーションによって実装される、信頼性の高い <strong>デバッグトランスポート</strong> ストリーム。</li><li>Duktapeヒープにデバッガをアタッチ/デタッチするための<strong>デバッグAPI</strong>です。</li><li>デバッグプロトコルエンドポイントを実装し、ユーザーインターフェースを提供する、オフターゲットで動作する<strong>デバッグクライアント</strong>である。</li><li>オプションの <strong>JSON デバッグプロトコルプロキシ</strong> は、デバッグターゲットと対話するための、より簡単なJSONベースのインターフェイスを提供します。 Node.jsとDukLuvで書かれたプロキシ実装の例がDuktapeに含まれています。</li></ul><p>本書では、これらの作品について詳しく説明します。</p><h3 id="はじめに-duk-を使ったデバッグについて" tabindex="-1">はじめに：&quot;duk &quot;を使ったデバッグについて <a class="header-anchor" href="#はじめに-duk-を使ったデバッグについて" aria-label="Permalink to &quot;はじめに：&quot;duk &quot;を使ったデバッグについて&quot;">​</a></h3><p>デバッグターゲットとして <code>duk --debugger</code> を、デバッグクライアントとして <code>debugger/duk_debug.js</code> を使用する具体的な方法については <code>debugger/README.rst</code> を参照してください。</p><h3 id="はじめに-ターゲットのデバッグ" tabindex="-1">はじめに：ターゲットのデバッグ <a class="header-anchor" href="#はじめに-ターゲットのデバッグ" aria-label="Permalink to &quot;はじめに：ターゲットのデバッグ&quot;">​</a></h3><p>ターゲットにデバッガサポートを組み込むには、以下のことが必要です。</p><ul><li><strong>設定オプションの確認</strong>: Duktape のデバッガーサポートを有効にするには、<code>DUK_USE_DEBUGGER_SUPPORT</code> と <code>DUK_USE_INTERRUPT_COUNTER</code> を有効にしてください。また、その他のデバッグ関連のコンフィグオプションも考慮してください。</li><li><strong>具体的なストリーム伝送機構を実装する</strong>: ターゲット・デバイスとDuktapeデバッガの両方に必要です。 最適なトランスポートはターゲットに依存します。例えば、TCP ソケット、 シリアルリンク、あるいは既存のカスタムプロトコルにデバッグデータを埋め込む、などです。 TCP デバッグトランスポートの例は <code>examples/debug-trans-socket/duk_trans_socket_unix.c</code> で提供されています。</li><li><strong>デバッガを添付するコードの追加</strong>: はデバッグを開始する時に <code>duk_debugger_attach()</code> を呼び出します。Duktapeは実行を一時停止し、デバッグメッセージを処理します(必要ならブロッ キングします)。 実行はデバッグクライアントの制御下で再開されます。</li><li><strong>終了後、デバッガをデタッチします</strong>: デバッグを停止するには <code>duk_debugger_detach()</code> を呼び出します。デバッグストリームエラーも自動的に切り離されます。 デバッグストリームエラーが発生すると、Duktapeは通常の実行を再開し、ブレークポイントなどを無視します(デバッグクライアントから明示的に要求された場合やDuktapeがデバッグストリームエラーを検出した場合にもデタッチが発生することがあります。)。</li><li><strong>イベントループがある場合</strong>: オプションで、Duktape の呼び出しが行われていない時に、たまに <code>duk_debugger_cooperate()</code> を呼び出します。 これにより、デバッグコマンドを Duktape の呼び出しの外で実行することができるようになります。</li></ul><p>Duktapeには、プレーンなTCPトランスポートをサポートするデバッグ・クライアントが付属しています。また、サードパーティ製のデバッグクライアントもいくつかあり、ターゲットと通信できるようにすることができます。これらは同じデバッグプロトコルを共有しているので、トランスポートだけを適合させる必要があります。</p><p>また、デバッグプロトコルのクライアント側を実装することで、独自のデバッグクライアントを作成することもできます。 デバッグ・クライアントはターゲットのデバッグ・プロトコルのバージョンに適応するよう意図されているので、Duktapeデバッグ・プロトコルの進化に伴って、デバッグ・クライアントの変更が必要になる場合があります。 デバッグ・プロトコルは、Duktape APIと同じセマンティック・バージョニングの原則でバージョン管理されています。</p><p>バイナリー・デバッグ・プロトコルをデバッグ・クライアントに直接実装することもできますが、より簡単な方法として、デバッグ・プロトコルのJSONマッピングを使用すると、より使い勝手が良くなります。 Duktapeには、JSONマッピングと、ターゲット上で実際に動作するバイナリー・デバッグ・プロトコルを変換するプロキシサーバーが含まれています。</p><h3 id="クライアントとサーバーのデバッグ例" tabindex="-1">クライアントとサーバーのデバッグ例 <a class="header-anchor" href="#クライアントとサーバーのデバッグ例" aria-label="Permalink to &quot;クライアントとサーバーのデバッグ例&quot;">​</a></h3><p>Duktapeレポには、デバッグ・トランスポートにTCPを使用し、Duktapeコマンドライン・ツール（「duk」）と通信できるデバッガーのウェブUIの例が含まれています。 この実行例は、デバッグコマンドの具体的な詳細とデバッグトランスポートの実装方法をさらに文書化するためのものです。 ウェブコンソールは、TCPデバッグトランスポートを使用する他のデバッグターゲットと直接対話することも可能です。</p><p>デバッガーのサンプルには:</p><ul><li><p>Duktapeのコマンドラインツールの <code>--debugger</code> オプションは、 <code>DUK_CMDLINE_DEBUGGER_SUPPORT</code> と <code>DUK_USE_DEBUGGER_SUPPORT</code> の両方を使用することで有効にすることができます。コマンドラインツールは <code>examples/debug-trans-socket/</code> で提供される TCP ソケットベースのサンプルトランスポートを使用します。</p></li><li><p>NodeJS + ExpressJS ベースの最小デバッガー Web UI が <code>debugger/</code> ディレクトリにあり、デバッグ転送に TCP ソケットを使用します。</p></li></ul><p><strong>TCPは良い例のトランスポートではあるが、「標準」トランスポートではない。トランスポートは常に最終的にはユーザーコード次第である。</strong></p><h3 id="ローカルデバッガの例" tabindex="-1">ローカルデバッガの例 <a class="header-anchor" href="#ローカルデバッガの例" aria-label="Permalink to &quot;ローカルデバッガの例&quot;">​</a></h3><p>通常、リモート・デバッグ・クライアントが望ましいのですが、場合によってはDuktapeが動作しているのと同じプロセスでデバッグ接続を終了させるのが便利なことがあります。 Duktapeの観点からは、「ローカル」デバッガはリモートのデバッガと同じです：デバッグ・トランスポートの実装がDuktapeとの違いを隠してくれます。ローカルなd値エンコーダー/デコーダーを持つデバッグ・トランスポートの例があります。</p><ul><li><code>examples/debug-trans-dvalue/</code></li></ul><p>サンプルのトランスポートは、dvalueのエンコードとデコードの詳細を隠し、ローカルのデバッグクライアントを書きやすくします。 このトランスポートは、C言語でdvalueを扱う例としても役立ちます（Node.jsのデバッガには、Javascriptのための同様の例があります）。</p><h3 id="duktapeが提供しないもの" tabindex="-1">Duktapeが提供しないもの <a class="header-anchor" href="#duktapeが提供しないもの" aria-label="Permalink to &quot;Duktapeが提供しないもの&quot;">​</a></h3><h4 id="標準的なデバッグ用トランスポート" tabindex="-1">標準的なデバッグ用トランスポート <a class="header-anchor" href="#標準的なデバッグ用トランスポート" aria-label="Permalink to &quot;標準的なデバッグ用トランスポート&quot;">​</a></h4><p>最適なトランスポートは千差万別なので、これはユーザーコード次第です。Wi-Fi、シリアルポート、などなど。 しかし、TCP を使用しない特別な理由がないのであれば、おそらく TCP は良いデフォルトのトランスポートとなるでしょう。 バンドルされているサンプルのデバッガー Web UI と JSON デバッグプロキシは、トランスポートとして TCP を使用します。</p><h4 id="標準的なデバッガーui" tabindex="-1">標準的なデバッガーUI <a class="header-anchor" href="#標準的なデバッガーui" aria-label="Permalink to &quot;標準的なデバッガーUI&quot;">​</a></h4><p>ユーザー・コードは、Duktapeがサポートするデバッグ・コマンドの上に、具体的なデバッガー・インターフェイスを実装する必要があります。 しかし、Duktapeには、完全に機能するデバッガの例が含まれています。 必要に応じてこれを拡張することもできますし、自分で書くこともできます。</p><h4 id="機能ソースコード" tabindex="-1">機能ソースコード <a class="header-anchor" href="#機能ソースコード" aria-label="Permalink to &quot;機能ソースコード&quot;">​</a></h4><p>Duktapeは現在、デバッグ・プロトコルで関数のソース・コードを提供していません。 デバッグクライアントは、一致するソースコードにアクセスでき、特定のファイル名に一致するソースファイルを見つける能力を持っていることが前提です。 これは、<code>eval</code> を使って作成された関数は、ソースが存在する状態でデバッグできないことも意味します。</p><h2 id="デバッガサポート有効化の影響" tabindex="-1">デバッガサポート有効化の影響 <a class="header-anchor" href="#デバッガサポート有効化の影響" aria-label="Permalink to &quot;デバッガサポート有効化の影響&quot;">​</a></h2><h3 id="パフォーマンス" tabindex="-1">パフォーマンス <a class="header-anchor" href="#パフォーマンス" aria-label="Permalink to &quot;パフォーマンス&quot;">​</a></h3><p>デバッガが接続され、実行中の関数にアクティブなブレークポイントがある場合を除き、パフォーマンスへの影響は非常に小さいはずです。</p><p>バイトコードエクゼキュータが再起動するとき、デバッガが接続されていないことをすぐに判断し、ブレークポイントを処理する必要はありません。 バイトコード実行に何らかの影響を与えるデバッガを使用するには、バイトコードエクゼキュータ割り込みを有効にする必要があります。</p><p>Duktapeは、デバッガが接続され、現在の関数にアクティブなブレークポイントがある場合、「チェック済み実行」になります。 チェック実行（詳細は後述）は、通常の実行よりはるかに遅く、バイトコード命令ごとに割り込みハンドラが実行されます。</p><h3 id="コードフットプリント" tabindex="-1">コードフットプリント <a class="header-anchor" href="#コードフットプリント" aria-label="Permalink to &quot;コードフットプリント&quot;">​</a></h3><p>デバッガサポートにより、フットプリントが約15-20kB増加します（有効なデバッガ機能に依存）。 デバッガ機能が有効な場合</p><h3 id="メモリフットプリント" tabindex="-1">メモリフットプリント <a class="header-anchor" href="#メモリフットプリント" aria-label="Permalink to &quot;メモリフットプリント&quot;">​</a></h3><p>ヒープレベルのデバッガー状態のため、 <code>duk_heap</code> 構造体のサイズが増加します。細かく調整されたメモリプールを使用している場合、メモリプールのサイズを再チューニングする必要があるかもしれません。</p><p>関数インスタンスは常に内部の <code>_Varmap</code> プロパティを保持し、ローカル変数が常に名前で検索できるようにします。 デバッガのサポートがない場合、 <code>_Varmap</code> は実行中に必要となる場合のみ保持されます (例: 関数に eval コールが含まれている場合など)。</p><p>そうでなければ、メモリフットプリントは無視できるほど小さくなるはずです。 Duktape はデバッグ・メッセージのバッファリングを維持する必要がありません。なぜなら、全てのデバッグ・データはストリームで入出力されるからです。</p><h3 id="セキュリティ" tabindex="-1">セキュリティ <a class="header-anchor" href="#セキュリティ" aria-label="Permalink to &quot;セキュリティ&quot;">​</a></h3><p>デバッガープロトコル経由で利用可能なデバッグコマンドは、潜在的に悪用可能なメモリ安全でない動作をトリガーするために（誤って）使用される可能性があります。 たとえば、デバッグクライアントは、悪用される可能性のあるファブリケーションポインタから/への読み取り/書き込みを行う可能性があります。</p><p>これがセキュリティ上の懸念である場合、デバッグトランスポートは認証、暗号化、および完全性保護を提供する必要があります。 例えば、相互認証されたTLS接続を使用することができます。 Duktape自体は、トランスポートによって提供される以上のセキュリティ対策を提供しません。</p><h2 id="デバッグapi" tabindex="-1">デバッグAPI <a class="header-anchor" href="#デバッグapi" aria-label="Permalink to &quot;デバッグAPI&quot;">​</a></h2><h3 id="duk-debugger-attach" tabindex="-1">duk_debugger_attach() <a class="header-anchor" href="#duk-debugger-attach" aria-label="Permalink to &quot;duk_debugger_attach()&quot;">​</a></h3><p>アプリケーションがDuktapeヒープにデバッガーを取り付けたいときに呼び出されます::</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">duk_debugger_attach</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_trans_read_cb</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">         /* 読み取りコールバック */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_trans_write_cb</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">        /* 書き込みコールバック */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_trans_peek_cb</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">         /* ピークコールバック (オプション) */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_trans_read_flush_cb</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">   /* 読み取りフラッシュコールバック (オプション) */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_trans_write_flush_cb</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">  /* 書き込みフラッシュコールバック (オプション) */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_request_cb</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">            /* アプリリクエストコールバック (オプション) */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_detached_cb</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;font-style:italic;">           /* デバッガデタッチドコールバック */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    my_udata</span><span style="color:#89DDFF;">);</span><span style="color:#676E95;font-style:italic;">                /* デバッグudata */</span></span>
<span class="line"></span></code></pre></div><p>呼び出されると、Duktapeはデバッグ・モードに入り、実行を一時停止し、デバッグ・クライアントからのさらなる指示を待ちます。 Duktapeのデバッガ・サポートが有効でない場合、エラーがスローされます。</p><p>トランスポートコールバックは、開始要求の一部として与えられる。 Duktape はデバッグの開始/停止サイクルごとに新しい仮想ストリームを期待し、 <code>duk_debugger_attach()</code> が呼ばれるたびにプロトコルバージョン識別子を送信します。</p><p>detached コールバックはデバッガが切り離されたときに呼び出されます。 これは、明示的な要求 (<code>duk_debugger_detach()</code>) やデバッグメッセージ/トランスポートエラー、Duktape ヒープの破壊によって起こります。</p><p>APIドキュメントに明示的に記載されていない限り、どのコールバックもDuktape APIを呼び出すことはできません(ほとんどの場合、 <code>ctx</code> 引数を取得しないのもこのためです)。そうすると、メモリが安全でない挙動を引き起こす可能性があります。 具体的な例として、もしユーザーの読み出しコールバックが読み出し中に Duktape API を呼び出すと、その API 呼び出しがガベージコレクションの引き金になる可能性があります。 ガベージコレクションは任意の副作用を持つ可能性があるため、実行中のデバッガコマンド (<code>src-input/duk_debugger.c</code> で実装) が非常に混乱した方法でブレークする可能性があります。</p><h3 id="duk-debugger-detach" tabindex="-1">duk_debugger_detach() <a class="header-anchor" href="#duk-debugger-detach" aria-label="Permalink to &quot;duk_debugger_detach()&quot;">​</a></h3><p>アプリケーションがデバッガーをデタッチしたいときに呼び出されます::</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">duk_debugger_detach</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p>デバッガが切り離されると、Duktapeは通常の実行を再開します。 残っているデバッグ状態（ブレークポイントなど）は無視されます。</p><p>Duktapeのデバッガ・サポートが有効でない場合、エラーが投げられます。</p><h3 id="duk-debugger-cooperate" tabindex="-1">duk_debugger_cooperate() <a class="header-anchor" href="#duk-debugger-cooperate" aria-label="Permalink to &quot;duk_debugger_cooperate()&quot;">​</a></h3><p>Duktapeへの呼び出しがアクティブでない場合に、受信デバッグ・コマンドを処理するためのオプションの呼び出しです。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">duk_debugger_cooperate</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p>保留中のデバッグコマンドは <code>ctx</code> スレッドのコンテキスト内で実行されます。ブロックせずに実行できるすべてのデバッグコマンドは、呼び出しの間に実行されます。 この呼び出しはブロックしないので、イベントループの中に埋め込んでも安全です。 この呼び出しは、デバッグがサポートされていないときやアクティブでないときは無意味なので、デバッグの状態をチェックせずに呼び出すことができます。</p><p>注意点：</p><ul><li>呼び出し元は、Duktapeへの呼び出しがアクティブなときに、このAPI関数を呼び出さないようにする責任があります（どのようなコンテキストでも）。</li><li>duk_debugger_cooperate() の呼び出しの間隔は、保留中のデバッグ・コマンドに対する Duktape の反応速度に影響します。</li></ul><p>このAPIコールは、Duktapeへの呼び出しがアクティブでないときにEvalなどのデバッグ・コマンドを実行できるようにするために、一部のアプリケーションで必要とされています。 例えば、以下のようになります。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(;;)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /* イベントまたはタイムアウトを待ちます。 */</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">wait_for_events_or_timeout</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /* プロセスイベント。 */</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">event1</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        ...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /*...*/</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /* Duktapeデバッガと連携する。 */</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">duk_debugger_cooperate</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">ctx</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>このAPIコールは、保留中の受信メッセージをすべて処理するため（ブロックせずに利用可能）、次のように使用することも可能です。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(;;)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /* イベントまたはタイムアウトを待ちます。 */</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">wait_for_events_or_timeout</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /* プロセスイベント。 */</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">got_inbound_debugger_data</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        /* Duktapeデバッガと協力：新しい受信データが到着するまで、保留中のメッセージをすべて処理する。 */</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">duk_debugger_cooperate</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">ctx</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /*...*/</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="duk-debugger-pause" tabindex="-1">duk_debugger_pause() <a class="header-anchor" href="#duk-debugger-pause" aria-label="Permalink to &quot;duk_debugger_pause()&quot;">​</a></h3><p>ターゲットはいつでもこれを呼び出して、ECMAScript の実行を一時停止し、添付のデバッグクライアントに制御を移すよう要求することができます。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">duk_debugger_pause</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p>要求された一時停止はすぐには起こらないかもしれませんが、次のバイトコードオペレーションディスパッチで実行されます。詳細はAPIドキュメントを参照してください。</p><p>このコールの一般的な使用例は、ホットキーにバインドすることで、ユーザーが無限ループから抜け出し、デバッグすることを可能にします。 しかし、他のDuktape APIコールと同様に、このコールはスレッドセーフではないので、デバッグ対象のECMAScriptコードを実行するために使用するのと同じスレッドから呼び出す必要があります。</p><h3 id="duk-debugger-notify" tabindex="-1">duk_debugger_notify() <a class="header-anchor" href="#duk-debugger-notify" aria-label="Permalink to &quot;duk_debugger_notify()&quot;">​</a></h3><p>デバッグトランスポートを通じてアプリケーション固有の通知を送信するためのオプションのコール::</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">duk_bool_t</span><span style="color:#A6ACCD;"> sent</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">duk_push_string</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">BatteryLevel</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">duk_push_uint</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">130</span><span style="color:#89DDFF;">);</span><span style="color:#676E95;font-style:italic;">  /* 130 of 1000 */</span></span>
<span class="line"><span style="color:#A6ACCD;">    sent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">duk_debugger_notify</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#676E95;font-style:italic;"> /*nvalues*/</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /* &#39;sent&#39; は、notify が正常に送信されたか否かを示す。 */</span></span>
<span class="line"></span></code></pre></div><p>この呼び出しは0を返し、デバッガサポートがコンパイルされていないときや、デバッガが接続されていないときは事実上無視されます。</p><p>詳細については、以下の「カスタムリクエストと通知」を参照してください。</p><h2 id="デバッグトランスポート" tabindex="-1">デバッグトランスポート <a class="header-anchor" href="#デバッグトランスポート" aria-label="Permalink to &quot;デバッグトランスポート&quot;">​</a></h2><h3 id="概要-1" tabindex="-1">概要 <a class="header-anchor" href="#概要-1" aria-label="Permalink to &quot;概要&quot;">​</a></h3><p>Duktapeのデバッガ・コードは、TCPコネクションやシリアル・リンクに似たセマンティクスを持つ、抽象化された信頼性の高いストリーム・トランスポートを介してデバッグ・メッセージを送受信します。 異なる環境への移植性を最大化するために、Duktapeはユーザーコードが <code>duk_debugger_attach()</code> に与えるコールバックという形で、このトランスポートの具体的な実装を提供することを期待しています。</p><p>トランスポートが提供する論理的なサービスは、以下のプリミティブを持つ信頼性の高いバイトストリームである。</p><ul><li>バイト読み（部分読みOK，最低1バイト読みが必要ならブロック）</li><li>バイト書き込み（部分書き込みOK，最低1バイトの書き込みが必要な場合はブロックする）</li><li>ブロッキングせずに受信バイトをPeekする。</li><li>フラッシュヒントを読む</li><li>書き込みフラッシュヒント</li></ul><p>トランスポート・コールバックの実装をできるだけ簡単にするために、部分的な 読み書きを許可しています。 Duktapeは、必要な回数だけreadとwriteを呼び出すことで、「完全に読む」「完全に書く」セマンティクスを自動的に処理します。</p><p>Peekingは、Duktapeがブロックすることなく、受信したデバッグ・メッセージを検出することを可能にします。これにより、Duktapeが（一時停止状態ではなく）通常通り動作している場合でも、デバッグ・メッセージを処理することができます。</p><p>書き込みフラッシュは、トランスポート実装が書き込みを確実に合体させることを可能にする。リードフラッシュは、トランスポート実装が受信ウィンドウをより効率的に管理 することを可能にする。 読み取り/書き込みフラッシュコールバックは、いくつかのタイプのトランスポートに おいてのみ必要とされる。</p><p>このセクションでは、各コールバックの詳細なセマンティクスをカバーし、フロー制御、圧縮、セキュリティなどの他のトランスポート関連の一般的な問題について議論しています。</p><p><strong>重要：アプリケーションは read/write チャンクバウンダリに何の意味も持たせるべきではありません。 リード、ライト、ピーキング、フラッシュコールがデバッグメッセージの境界に対応する保証はありません。</strong></p><h3 id="コールバックのセマンティクスを読み取る" tabindex="-1">コールバックのセマンティクスを読み取る <a class="header-anchor" href="#コールバックのセマンティクスを読み取る" aria-label="Permalink to &quot;コールバックのセマンティクスを読み取る&quot;">​</a></h3><ul><li>読み取り長は≧1が保証される。</li><li>バッファポインタは非NULLであることが保証される。</li><li>Duktapeは、少なくとも1バイト、最大でも「長さ」バイトの読み取りを要求しています。 部分的な読み出しはOKだが、少なくとも1バイトは読み出さなければならない。 ユーザーコードが少なくとも1バイトを読み取れない場合、読み取れるまでブロックしなければならない(MUST)。 1バイト以上が利用可能な場合、ユーザーコードはブロックしてはならない(MUST NOT)。</li><li>1,length]の範囲の戻り値は、与えられたバッファにいくつのバイトが読み込まれたかを示す。</li><li>戻り値0は、ストリーム・エラー（サニティ・タイムアウト、コネクション・クローズなど）を示します。 Duktapeはそのストリームを壊れたとみなし、それ以上操作を行いません。 デバッガは自動的に切り離されます。</li></ul><h3 id="コールバックのセマンティクスを書き込む" tabindex="-1">コールバックのセマンティクスを書き込む <a class="header-anchor" href="#コールバックのセマンティクスを書き込む" aria-label="Permalink to &quot;コールバックのセマンティクスを書き込む&quot;">​</a></h3><ul><li>書き込み長は≧1であることが保証される。</li><li>バッファポインタは非NULLであることが保証される。</li><li>Duktapeは、最低でも1バイト、最大でも「length」バイトの書き込みを要求しています。 部分的な書き込みはOKだが、少なくとも1バイトは書き込まなければならない。もしユーザー・コードが少なくとも1バイトを書き込めない場合は、書き込めるようになるまでブロックしなければならない（MUST）。</li><li>1,length]の範囲の戻り値は、与えられたバッファから何バイトが書き込まれたかを示します。</li><li>戻り値0は、ストリーム・エラー（サニティ・タイムアウト、コネクション・クローズなど）を示します。 Duktapeはそのストリームを壊れたとみなし、それ以上操作を行いません。 デバッガは自動的に切り離されます。</li></ul><h3 id="peekコールバックのセマンティクス" tabindex="-1">Peekコールバックのセマンティクス <a class="header-anchor" href="#peekコールバックのセマンティクス" aria-label="Permalink to &quot;Peekコールバックのセマンティクス&quot;">​</a></h3><ul><li>peekコールバックの実装はオプションです(NULLは <code>duk_debugger_attach()</code> で渡すことができます)が、強く推奨します。 コールバックが提供されない場合、(Duktapeが正常に動作している間に)「突然」実行を一時停止するようないくつかの機能は動作しなくなります。</li><li>Peekコールバックには引数がありません。</li><li>Duktapeは入力ストリームを覗くことを要求しています。つまり、少なくとも1バイトがブロックされずに読み込めるかどうかを確認するためです。</li><li>戻り値0は、ブロックせずに読み取ることができるバイトがないことを示す。</li><li>戻り値 &gt; 0 は、ブロッキングせずに読み込めるバイト数を示します。 現在、Duktapeは少なくとも1バイトが利用可能かどうかだけを気にしているので、 0か1を返せば十分です。</li><li>Duktapeは現在、少なくとも1バイトが利用可能であれば、デバッグメッセージ全体を読み取ることができると仮定しています（必要に応じてブロックし、部分的な読み取りを処理します）。</li></ul><h3 id="リードフラッシュコールバックのセマンティクス" tabindex="-1">リードフラッシュコールバックのセマンティクス <a class="header-anchor" href="#リードフラッシュコールバックのセマンティクス" aria-label="Permalink to &quot;リードフラッシュコールバックのセマンティクス&quot;">​</a></h3><ul><li>リードフラッシュコールバックの実装はオプションです (<code>duk_debugger_attach()</code> で NULL を渡すことができます)。</li><li>リードフラッシュコールバックは引数を持たない。</li><li>Duktapeはユーザー・コードに対して「リード・フラッシュ」を指示しています。 Duktapeは、その場ではもう読み込みをしないかもしれないのに、&quot;read flush &quot;を指示することが保証されています。 (ただし、Duktapeはその直後から読み込みを続けていても、読み込みのフラッシュを示すことがあります)。</li><li>ほとんどのトランスポートでは、リードフラッシュは重要ではない。 トランスポートプロトコルが制限された読み取りウィンドウを使用し、リ モートピアにウィンドウの状態を更新するプロトコルを持つ場合、ウィンドウ 制御メッセージは次の読み取りフラッシュに延期できる(読み取りバッファが空の状態 など、それを送信する他の緊急の理由がない場合)。</li></ul><h3 id="書き込みフラッシュコールバックセマンティクス" tabindex="-1">書き込みフラッシュコールバックセマンティクス <a class="header-anchor" href="#書き込みフラッシュコールバックセマンティクス" aria-label="Permalink to &quot;書き込みフラッシュコールバックセマンティクス&quot;">​</a></h3><ul><li>書き込みフラッシュコールバックの実装はオプションです (<code>duk_debugger_attach()</code> で NULL を渡すことができます)。</li><li>書き込みフラッシュコールバックは引数を持ちません。</li><li>Duktapeは、ユーザーコードに対して「書き込みフラッシュ」を示しています。 Duktapeは、その特定の機会にこれ以上書き込みをしないかもしれないとき、 「書き込みフラッシュ」を示すことが保証されています。 (ただし、Duktapeは書き込みの直後でも書き込みフラッシュを指示することが あります)。</li><li>この表示は、ユーザー・トランスポートが書き込みをより大きなチャンクにまと める場合に有用です。 ユーザーコードは、バッファリングされたデータが十分に大きくなるか、書き込みフラッシ ュが指示されると、チャンクを送り出すことができます。 ユーザーコードは、重要なときにライトフラッシュが起こることを信頼することができる。</li><li>ユーザーコードは、この表示が基礎となるトランスポートに適用されない場合（例えば、TCPを使用する場合、書き込みの自動合体のためのメカニズムがすでにあります）、または保留中のバイトが最終的に送信されることを確実にするための他のメカニズム（例えば、タイマー）がある場合、無視する自由もあります。</li></ul><h3 id="トランスポートが壊れたことを示すマーク" tabindex="-1">トランスポートが壊れたことを示すマーク <a class="header-anchor" href="#トランスポートが壊れたことを示すマーク" aria-label="Permalink to &quot;トランスポートが壊れたことを示すマーク&quot;">​</a></h3><p>Duktapeは、次の場合に輸送が壊れたとマークします。</p><ul><li>ユーザー・コールバックがストリーム・エラーを示した場合</li><li>Duktapeがデバッグ・ストリームをパースする際に、パース・エラーに遭遇した場合。</li></ul><p>デバッグ・トランスポートが壊れたとマークされたとき。</p><ul><li>デバッガは自動的に切り離され、通常のECMAScriptの実行が直ちに再開されます。 デタッチド コールバックが存在する場合は、それが呼び出されます。</li><li>Duktapeは、ストリームのユーザー・コールバックに対して、これ以上呼び出しを行いません。</li><li>Duktape内部のデバッグ用読み込みコールは、ダミー値（バイト読み込み時は0、整数読み込み時は0、文字列読み込み時は空文字列など）を返し、書き込みは黙って無視されます。 これにより、実装は読み書きのたびにエラーをチェックすることなくデータの読み書きができます。「壊れたトランスポート」に対する明示的なチェックは、最も便利な場所で行うことができます。</li></ul><h3 id="ピーキングリクエストノート" tabindex="-1">ピーキングリクエストノート <a class="header-anchor" href="#ピーキングリクエストノート" aria-label="Permalink to &quot;ピーキングリクエストノート&quot;">​</a></h3><p>Duktapeは、入ってくるデバッグ・コマンドを検出し、それを処理するためにピー ク・リクエストを使用します。ピー クは、通常の実行時 (関連するブレークポイントがなく、ステッピングがアクティブでない時) と チェック実行時 (1つ以上のアクティブなブレークポイントがあり、ステッピングがアクティブな時) の両方に使用されます。</p><p>Duktapeは、日付ベースのタイムスタンプを使用して、ピーク要求のレートを自動的に制限しています。</p><h3 id="フラッシュ・ノートの作成" tabindex="-1">フラッシュ・ノートの作成 <a class="header-anchor" href="#フラッシュ・ノートの作成" aria-label="Permalink to &quot;フラッシュ・ノートの作成&quot;">​</a></h3><p>Duktapeは、書き込みフラッシュを使用して、この機会にこれ以上データを送信しない可能性があること、および、アプリケーションがキューに入れた保留データを送信する必要があることを示します。</p><p>Duktapeは、送信するデバッグ・メッセージを非常に小さく分割して書き込むので、アプリケーションが送信待ちデータのバッファを維持するのは理にかなっているかもしれません。Duktapeが書き込みを行う際、データをバッファに追加することができます。 データは、バッファが十分に大きくなった時か、Duktapeが書き込みフラッシュを実行した時に送出されます。</p><p>書き込みフラッシュは、Duktapeがメッセージのセットを処理し終わった時に発生するこ とが保証されており、アプリケーションは、保留中の書き込みをフラッシュするための タイマー・メカニズムなどを別に持つ必要がありません。 書き込みフラッシュは、送信されるデバッグ・メッセージの後では保証され ません（現在のDuktapeの実装はそのように動作しますが）。</p><p>** ユーザー・コードは、Duktapeがいつ書き込みフラッシュを示すかについて、それが起こったときに保留中のバイトを送信すること以外、何も仮定してはいけません **</p><h3 id="信頼性" tabindex="-1">信頼性 <a class="header-anchor" href="#信頼性" aria-label="Permalink to &quot;信頼性&quot;">​</a></h3><p>Duktapeは、トランスポートが信頼できるものであることを期待します。すなわち、 バイトの並び替えや紛失、重複がないことです。 具体的なトランスポートは、アプリケーション固有の手段で信頼性を提供しな ければならない。 例えば、TCP ソケットが使われる場合、信頼性は TCP によって自動的に提供されます。 信頼性のないパケットトランスポートの場合、ユーザコードは再送、重複検出、順序付けを提供しなければならない。</p><h3 id="フロー制御" tabindex="-1">フロー制御 <a class="header-anchor" href="#フロー制御" aria-label="Permalink to &quot;フロー制御&quot;">​</a></h3><p>抽象的なトランスポートレベルではフロー制御はないが、アプリケーションはト ランスポートの一部としてフロー制御を自由に実装することができる。 例えば、TCPソケットが使用される場合、TCPの一部として自動的なフロー制御が存在する。</p><p>フロー制御は、バッファの過剰な確保を避けるために、メモリ量の非常に少ないデバイスでは必要かもしれない。</p><h3 id="圧縮" tabindex="-1">圧縮 <a class="header-anchor" href="#圧縮" aria-label="Permalink to &quot;圧縮&quot;">​</a></h3><p>非常に低速なリンクでは、アプリケーション固有のトランスポートがデバッグトラフィックのストリーム圧縮を使用することが適切である場合があります。 圧縮は、ストリームを非圧縮サイズの10〜30%程度に減らすことができる。</p><h3 id="セキュリティ-1" tabindex="-1">セキュリティ <a class="header-anchor" href="#セキュリティ-1" aria-label="Permalink to &quot;セキュリティ&quot;">​</a></h3><p>環境によっては、デバッグトランスポートはセキュリティ上重要である場合があります。 そのような場合、アプリケーションはデバッグトランスポートに認証と暗号化（例：トランスポートにSSL/TLSを使用）を使用する必要があります。</p><h3 id="パケットベースのトランスポートの上に実装する。" tabindex="-1">パケットベースのトランスポートの上に実装する。 <a class="header-anchor" href="#パケットベースのトランスポートの上に実装する。" aria-label="Permalink to &quot;パケットベースのトランスポートの上に実装する。&quot;">​</a></h3><p>このトピックは別のセクションで扱います。</p><h3 id="開発時間輸送拷問オプション" tabindex="-1">開発時間輸送拷問オプション <a class="header-anchor" href="#開発時間輸送拷問オプション" aria-label="Permalink to &quot;開発時間輸送拷問オプション&quot;">​</a></h3><p>DUK_USE_DEBUGGER_TRANSPORT_TORTURE という設定オプションを使うと、Duktape はすべてのデバッグトランスポートの読み込み/書き込み操作を 1 バイト単位で行うようになり、あるサイズのチャンクの読み込み/書き込みに関する不正な仮定をキャッチするのに役立ちます。</p><h2 id="デバッグストリームフォーマット" tabindex="-1">デバッグストリームフォーマット <a class="header-anchor" href="#デバッグストリームフォーマット" aria-label="Permalink to &quot;デバッグストリームフォーマット&quot;">​</a></h2><h3 id="概要-2" tabindex="-1">概要 <a class="header-anchor" href="#概要-2" aria-label="Permalink to &quot;概要&quot;">​</a></h3><p>デバッグ・プロトコルは、Duktape内部とデバッグ・クライアントの間で交わされる会話です。 ユーザーコードはデバッグプロトコルの内容を意識することはなく、デバッグターゲットとデバッグクライアントの間でストリームのチャンクを運ぶためのデバッグトランスポートを提供するだけです。</p><p>デバッグプロトコルはシンプルな3つのライフサイクルを持っています。</p><ul><li>ストリームが接続され、バージョン識別（Duktapeによって送信される）を待機しています。</li><li>ストリームが接続され、アクティブに使用されている状態。 デバッグ・メッセージは、それぞれの方向で自由に交換されます。</li><li>ストリームは切断されます。 これは明示的なデタッチ要求（つまり <code>duk_debugger_detach()</code> への呼び出し、ユーザーのトランスポートコールバックによって示される読み込み/書き込みエラー、Duktapeによって検出されるメッセージ構文エラー、またはDuktapeヒープ破棄によって起こります。</li></ul><p>プロトコルはリクエストパイプラインを使用する。つまり、各ピアは前のリ クエストに対する応答を待つことなく、複数のリクエストを送ることが許される。 これを促進するために、すべてのリクエストは対応する応答/エラーメッセージを持ち、リクエストは常に再順序付けされることなく処理される。 どちらのピアもパイプライン化されたリクエストを送る必要はなく、例えばデバッグクライアントが別のリクエストを送る前に応答を待つことは全く問題ありません。</p><h3 id="バージョン識別" tabindex="-1">バージョン識別 <a class="header-anchor" href="#バージョン識別" aria-label="Permalink to &quot;バージョン識別&quot;">​</a></h3><p>デバッグ・トランスポートが装着されているとき、Duktapeはバージョン識別をUTF-8でエンコードされた:という形の行として書き込みます。</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">protocolversion</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">SP</span><span style="color:#89DDFF;"> (0x20)&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">additional</span><span style="color:#89DDFF;"> text, no LF&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">LF</span><span style="color:#89DDFF;"> (0x0a)&gt;</span></span>
<span class="line"></span></code></pre></div><p>現在のプロトコルのバージョンは「2」であり、識別行は現在、次のような形になっています。</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">2 </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">DUK_VERSION</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">DUK_GIT_DESCRIBE</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">target</span><span style="color:#89DDFF;"> string&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">LF</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>プロトコルバージョン番号の後に続くものはすべて情報提供のみです。 例::</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">2 20000 v2.0.0 duk command built from Duktape repo</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>デバッグプロトコルのバージョンは、ユーザーコードへの定義として利用可能です (<code>duktape.h</code> で定義されます)::</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">DUK_DEBUG_PROTOCOL_VERSION</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>これは、ターゲットがそのデバッグ機能を宣伝できる場合などに有用である。</p><p>デバッグクライアントはその行を解析し、最初にプロトコルバージョンをチェックする必要があります。プロトコルバージョンがサポートされていない場合、デバッグ接続は閉じられるべきです。 デバッグクライアントは、常にターゲットに存在するプロトコルバージョンに適応します。 バージョン識別に対する確認応答はなく、デバッグクライアントからの対応するハンドシェイクメッセージもありません。</p><p>バージョン識別（ハンドシェイク）が完了すると、デバッグストリームは以下に説明する異なるフレーミングに切り替わります。 このフレーミングはプロトコルのバージョンに依存する可能性があり、そのためバージョン識別が最初に処理されなければなりません。</p><p>バージョン識別形式に関するいくつかの根拠。</p><ul><li>1行のテキスト文字列は一般的なハンドシェイク手法であり、（TCPトランスポートを使用している場合）ターゲットにtelnet接続でき、デバッガーポートに接続したことを容易に確認できるという利点があります。 また、例えばDuktapeがオプションの機能をアドバタイズできるように、簡単に拡張することができます（それが必要になった場合）。</li><li>バージョン識別は、ハンドシェイク形式を変更することなく、将来的にプロトコルのフレームを変更することを可能にします。 もしバージョン識別が以下に述べるような複雑なフレームを使用するならば、 バージョンの互換性をより難しくするでしょう。</li><li>Duktapeは、ただやみくもにバージョン識別を送信し、応答を解析する必要がないので、例えば1バイトのバージョンを送信することと比較して、人間が読めるバージョン識別行を持つことにほとんどコストはかかりません。</li><li>デバッグ・クライアントのためにバージョン識別を追加することは、Duktapeにとって不必要なパース状態を意味します。 Duktapeにデバッグ・クライアントのバージョンを認識させるメリットはほとんどない。</li></ul><h3 id="dvalue" tabindex="-1">Dvalue <a class="header-anchor" href="#dvalue" aria-label="Permalink to &quot;Dvalue&quot;">​</a></h3><p>バージョン識別ハンドシェイクの後、デバッグストリームはそれぞれの方向に送られる <em>dvalues</em> と呼ばれる型付き値で構成される。 Dvalues はメッセージフレームマーカー、整数、文字列、タグ付き ECMAScript 値などを表現する。 これらはコンテキストなしで解析することができ、ダンプに便利であり、またコンテキストなしで dvalues (とデバッグメッセージ) をスキップすることができる。 デバッグメッセージは、開始マーカ、0個以上のd値、メッセージ終了マーカからなる一連のd値として構築される。</p><p>次の表は、dvalueとそのフォーマットについてまとめたものである。 初期バイト(IB)は、タイプタグとして、また、値の一部を含むものとして使用される場合がある。</p><table><thead><tr><th>Byte sequence</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td>EOM</td><td>メッセージの終わり</td></tr><tr><td>0x01</td><td>REQ</td><td>リクエストメッセージの開始</td></tr><tr><td>0x02</td><td>REP</td><td>成功返信メッセージの開始</td></tr><tr><td>0x03</td><td>ERR</td><td>エラー返信メッセージの開始</td></tr><tr><td>0x04</td><td>NFY</td><td>通知メッセージの開始</td></tr><tr><td>0x05...0x0f</td><td>reserved</td><td></td></tr><tr><td>0x10 <code>&lt;int32&gt;</code></td><td>integer</td><td>4 バイト整数，符号付き 32 ビット整数，ネットワーク順で先頭バイトに続く。</td></tr><tr><td>0x11 <code>&lt;uint32&gt;</code> <code>&lt;data&gt;</code></td><td>string</td><td>4 バイト文字列、符号なし 32 ビット文字列長でネットワーク順、文字列データは先頭バイトに続く。</td></tr><tr><td>0x12 <code>&lt;uint16&gt;</code> <code>&lt;data&gt;</code></td><td>string</td><td>2 バイト文字列、符号なし 16 ビット文字列長、ネットワーク順、文字列データは先頭バイトに続く。</td></tr><tr><td>0x13 <code>&lt;uint32&gt;</code> <code>&lt;data&gt;</code></td><td>buffer</td><td>4 バイトバッファ、符号なし 32 ビットバッファ長、ネットワーク順、バッファデータは先頭バイトに続く。</td></tr><tr><td>0x14 <code>&lt;uint16&gt;</code> <code>&lt;data&gt;</code></td><td>buffer</td><td>2 バイトバッファ、符号なし 16 ビットバッファ長、ネットワーク順、バッファデータは先頭バイトに続く</td></tr><tr><td>0x15</td><td>unused</td><td>内部的にはマッピングされていない配列エントリをマークするために使用され、デバッガプロトコルでは &quot;none &quot;の結果を示すために使用されます。</td></tr><tr><td>0x16</td><td>undefined</td><td>ECMAScript &quot;undefined&quot;</td></tr><tr><td>0x17</td><td>null</td><td>ECMAScript &quot;null&quot;</td></tr><tr><td>0x18</td><td>true</td><td>ECMAScript &quot;true&quot;</td></tr><tr><td>0x19</td><td>false</td><td>ECMAScript &quot;false&quot;</td></tr><tr><td>0x1a <code>&lt;8 bytes&gt;</code></td><td>number</td><td>IEEEダブル（ネットワークエンディアン）</td></tr><tr><td>0x1b <code>&lt;uint8&gt;</code> <code>&lt;uint8&gt;</code> <code>&lt;data&gt;</code></td><td>object</td><td>クラス番号、ポインタ長、ポインタデータ(ネットワークエンディアン)</td></tr><tr><td>0x1c <code>&lt;uint8&gt;</code> <code>&lt;data&gt;</code></td><td>pointer</td><td>ポインタ長、ポインタデータ(ネットワークエンディアン)</td></tr><tr><td>0x1d <code>&lt;uint16&gt;</code> <code>&lt;uint8&gt;</code> <code>&lt;data&gt;</code></td><td>lightfunc</td><td>Lightfuncフラグ、ポインタ長、ポインタデータ(ネットワークエンディアン)</td></tr><tr><td>0x1e <code>&lt;uint8&gt;</code> <code>&lt;data&gt;</code></td><td>heapptr</td><td>ポインタの長さ、ポインタデータ（ネットワークエンディアン）；ヒープオブジェクトへのポインタ、DumpHeapで使用される</td></tr><tr><td>0x1f</td><td>reserved</td><td></td></tr><tr><td>0x20...0x5f</td><td>reserved</td><td></td></tr><tr><td>0x60...0x7f <code>&lt;data&gt;</code></td><td>string</td><td>長さ [0,31] の文字列、文字列の長さは IB - 0x60, データは以下の通り。</td></tr><tr><td>0x80...0xbf</td><td>integer</td><td>整数 [0,63]、整数値はIB - 0x80</td></tr><tr><td>0xc0...0xff <code>&lt;uint8&gt;</code></td><td>integer</td><td>整数 [0,16383], 整数値は ((IB - 0xc0) &lt;&lt; 8) + followup_byte です。</td></tr></tbody></table><p>すべての &quot;integer &quot;表現は意味的に同じであり，整数が期待されるところではすべて使用することができる。 文字列 &quot;と &quot;バッファ &quot;表現も同様である。</p><p>dvalue の型付けは <code>duk_tval</code> の値を表現するのに十分であり、型付けを保持することができます (例えば、文字列とバッファは別々の型を持っています)。</p><p>dvalueは以下のテキストで以下のように表現される(テキスト中のすべての型に必要なわけではない)::</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">EOM</span></span>
<span class="line"><span style="color:#A6ACCD;">REQ</span></span>
<span class="line"><span style="color:#A6ACCD;">REP</span></span>
<span class="line"><span style="color:#A6ACCD;">ERR</span></span>
<span class="line"><span style="color:#A6ACCD;">NFY</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;int: field name&gt;      e.g. &lt;int: error code&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;str: field name&gt;      e.g. &lt;str: error message&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;buf: field name&gt;      e.g. &lt;buf: buffer data&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;ptr: field name&gt;      e.g. &lt;ptr: prototype pointer&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;tval: field name&gt;     e.g. &lt;tval: eval result&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;obj: field name&gt;      e.g. &lt;obj: target&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;heapptr: field name&gt;  e.g. &lt;heapptr: target&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>これらの追加的な表記は次の通りである。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;"># 1つの整数または2つの文字列のような代替。</span></span>
<span class="line"><span style="color:#A6ACCD;">(&lt;int: foo&gt; | &lt;str: bar&gt; &lt;str: quux&gt;)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 繰り返し、例えば0-N個の整数。</span></span>
<span class="line"><span style="color:#A6ACCD;">[&lt;int: foo&gt;]*</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 繰り返し、例えば1-N個の値、各文字列または整数。</span></span>
<span class="line"><span style="color:#A6ACCD;">[&lt;str: foo&gt; | &lt;int: bar&gt;]+</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>フィールドが ECMAScript の値と正確に関連しない場合、例えばフィールドがデバッガ制御フィールドである場合、型付けは緩くなることがある。 例えば、boolean フィールドは integer dvalue として、任意のバイナリ文字列は string dvalue として表現されることがあります。 各コマンドで使用される具体的な型は、以下のコマンドごとのセクションで説明します。</p><p>dvalue形式の背後にある意図は、次のとおりです。</p><ul><li>最下層のプロトコルを型付けし、解析される特定のメッセージを知ることなく、dvalueとメッセージをダンプできるようにする。</li><li>EOMマーカーをスキャンすることで、メッセージの内容を理解せずに メッセージをスキップする、あるいはメッセージの末尾のフィールドを 無視する方法を提供する。これは、サポートされていないリクエストを処理したり、既存のものに dvalue を追加してメッセージを拡張したりするのに便利である。 しかし、信頼性のあるスキップは、実装がすべてのd値の型を解析し、その長さを知ることができる場合にのみ可能であることに注意してください。 特に、(EOMに使用される)ゼロバイトはdvalueの内部にも現れることが あるので、ゼロバイトにスキップすることは信頼できるスキップの方法 ではない。</li><li>これは、両方のピアが、それ自身のリクエストに対するリプライと、相手から 開始されたリクエストまたは通知とを確実に区別できるようにするために必要であ る。</li><li>最終メッセージの長さを事前に知ることなく、デバッグメッセージのストリーム書き込みを許可する(これは、たとえばフレーミングが先行メッセージ長フィールドを持つ場合に必要である)。 これは、メッセージのサイズを事前に計算したり、送信前に完全なメッセージを 作成するために蓄積バッファを使用する必要性を回避するのに便利です。</li><li>すべての <code>duk_tval</code> 値を情報を失うことなく表現します。</li><li>低帯域幅のデバッグ用トランスポート(シリアル回線など)のトラフィックを最小化するために、典型的な数値や文字列には短いエンコーディングフォームを使用します。 <ul><li>整数の範囲 [0,63] は1バイトにエンコードされ、コマンド番号、ステータスコード、ブール値などに有効です。</li><li>整数範囲 [0,16383] は2バイトにエンコードされ、例えば行番号、典型的な配列インデックス、ループカウンタ値などに有効です。</li><li>長さ [0,31] の短い文字列は、1 バイトと文字列データにエンコードされます。 これは、典型的なファイル名、プロパティ名、変数名などに有効です。</li></ul></li></ul><p>注意事項</p><ul><li><code>duk_tval</code> を送信しない場合、整数の値は常にプレーンな整数としてエンコードされなければなりません (IEEE double エンコーディングではありません)。</li><li>duk_tval\`\` の値をパースする際には、プレーンな整数値と IEEE double 値の両方を受け入れなければなりません。 プレーンな整数は IEEE doubles に一意に対応するので、情報の損失はありません。 負の 0 は，符号を保持するために IEEE double として表現しなければならないことに注意してください．</li><li>高速整数(fastint)はデバッガープロトコルにおいて通常の数値と区別されません。</li><li>バッファの値は明示的に表現されますが、バッファオブジェクト(Node.js Buffer, ArrayBuffer, DataView, TypedArray ビュー)はオブジェクトとして表現されます。 つまり、その内容は送信されず、ヒープポインタとクラス番号のみが送信されます。</li><li>未使用」値は特別です。Duktapeが内部的にマッピングされていない配列のエントリーをマークするために使用されますが、実際の値（値スタック上のエントリー、プロパティ値など）に使用されることは意図されていません。 unused&quot; 値は、デバッガ・プロトコルで、いくつかのコマンド・リプライの欠落/無値を示すために使用されます。 リクエストでは使用されないので、デバッグ・クライアントはリクエスト（PutVarなど）で「unused」d値を送信してはいけません。</li></ul><h3 id="エンディアン" tabindex="-1">エンディアン <a class="header-anchor" href="#エンディアン" aria-label="Permalink to &quot;エンディアン&quot;">​</a></h3><p>原則として、すべての値はネットワークオーダー（ビッグエンディアン）にシリアライズされます。これはポインタ値やIEEEダブル値にも適用されます。</p><p>ポインタやIEEEダブルがバッファデータの一部である場合、それらはメモリ上に存在する任意の順序でエンコードされます。 これは、例えばDumpHeapによってダンプされたバイトコードは、プラットフォーム固有のバイトオーダーでバッファーの値として表現されることを意味します。 バイトオーダーを変更すると、デバッガーコードが特定のバッファ値のメモリレイアウトを認識する必要があるため、非常に厄介なことになります。</p><h3 id="duk-tvalの値を表現する" tabindex="-1">duk_tvalの値を表現する <a class="header-anchor" href="#duk-tvalの値を表現する" aria-label="Permalink to &quot;duk_tvalの値を表現する&quot;">​</a></h3><p><code>duk_tval</code> の値には、以下の dvalue タイプが使用される。</p><ul><li>未使用（undefined/unused/none）：特定の dvalue。</li><li>未定義：特定の dvalue</li><li>null: 固有の dvalue</li><li>boolean: <code>true</code> と <code>false</code> に対応する特定の dvalue です。</li><li>数値：符号付き 32 ビット整数は，単純な整数の d 値で表現できる（負の 0 を除く），その他の数値はリテラルの IEEE 倍数として表現される．</li><li>文字列: いくつかの文字列長に対応する特定の d 値</li><li>buffer: 数少ないバッファ長に対する特定のd値</li><li>オブジェクト: ポインタとして表現される (デバッグクライアントからデバッグターゲットに送信される場合は危険)</li><li>ポインター: ポインターとして表現</li><li>lightfunc: ポイントとフラグフィールドで表現される（デバッグクライアントからデバッグター ゲットに送信される場合は危険）。</li></ul><p>&lt;tval: フィールド名&gt;<code>という記法では、</code>duk_tval\`\` と互換性のある任意の dval を使用することができます。 しかし、いくつかの値はデバッグクライアントからターゲットに送信する際に危険であることに注意してください。例えば、PutVar への引数として lightfunc 値を送信することは可能ですが、非常に注意しなければ簡単にセグメンテーションフォルトを起こすことができます。</p><h3 id="request-replies-and-notifications" tabindex="-1">Request, replies, and notifications <a class="header-anchor" href="#request-replies-and-notifications" aria-label="Permalink to &quot;Request, replies, and notifications&quot;">​</a></h3><p>リクエストは次のような形式です。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">REQ &lt;int: command&gt; &lt;0-N dvalues&gt; EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>成功応答は次のような形式です。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">REP &lt;0-N dvalues&gt; EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>エラー応答は、コマンドに依存しない <strong>固定フォーマット</strong> である。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">ERR &lt;int: error code&gt; &lt;str: error message or empty string&gt; EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>通知には、次のような形式があります。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NFY &lt;int: command&gt; &lt;0-N dvalues&gt; EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>注意事項</p><ul><li>リクエストとリプライはメッセージIDを持たない: それは必要ない。 各ピアは、送られてくるリクエストに順番に応答することが要求される。また、 すべてのリクエストは、一つの成功またはエラー応答を持つことが要求されるので、 応答を以前に送ったリクエストに確実に関連付けることができる。 返信メッセージは、他の方向でピアから送られたリクエストや通知とまだ混 在しているかもしれない、ということに注意すること。</li><li>返信メッセージは、デバッグストリームでの順序に基づいて暗黙のうちに リクエスト/通知と関連付けられる。</li><li>エラー応答は、エラー処理を統一するために決まった形式を持ちます。デバッグクライアントが新しいコマンドがサポートされているかどうかを簡単に チェックし、サポートされていなければ他のコマンドにフォールバックできるように、 「unsupported command」に対する特定のエラーコードを用意しています。</li><li>Duktapeは現在、通知のみを送信し、リクエストは送信しません。</li></ul><h3 id="error-codes" tabindex="-1">Error codes <a class="header-anchor" href="#error-codes" aria-label="Permalink to &quot;Error codes&quot;">​</a></h3><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td>不明または未指定のエラー</td></tr><tr><td>0x01</td><td>非対応のコマンド</td></tr><tr><td>0x02</td><td>多すぎる（例：ブレークポイントが多すぎる、新規に追加できないなど）</td></tr><tr><td>0x03</td><td>見つかりません（例：無効なブレークポイントインデックス）</td></tr><tr><td>0x04</td><td>アプリケーションエラー（例：AppRequest関連エラー）</td></tr></tbody></table><h3 id="インバウンドリクエストの対応" tabindex="-1">インバウンドリクエストの対応 <a class="header-anchor" href="#インバウンドリクエストの対応" aria-label="Permalink to &quot;インバウンドリクエストの対応&quot;">​</a></h3><p>どちらかのピアが何か予期せぬことが起こったと判断した場合、単にトランスポートをドロップすることができます。 Duktapeがこれを検出するとすぐに、デバッガは自動的に切り離され、通常の実行が再開されます。 これは予期せぬエラーに対する統一されたハンドリングを提供し、例えば以下のような場合に適切な動作となります。</p><ul><li>無効な、あるいは非常識なdvalueフォーマットに遭遇した場合。 このような場合、確実に実行を継続する方法がないことがよくあります。</li><li>サポートされているコマンドが処理されているときにパースエラーが発生した。 このような状況は、ピアにバグがあるか、一貫性のない状態であることを示しています。</li></ul><p>正確なエラー処理規則は、ここではあまり詳細に規定しませんが、重要な規則がいくつかあります。 拡張性のために重要なルールがいくつかある。</p><ul><li>ピアは、サポートされていないコマンド番号のリクエストを受信した場 合、そのコマンドがサポートされていることを示すエラー応答を返さなければ ならず[MUST NOT]、デバッグ接続を切断してはならない[MUST NOT]。 この動作は、ピアがコマンドを試してたまたまサポートされてい るかどうかを確認し、サポートされていない場合は他の動作にフォールバッ クできるようにするために、重要である。 その結果、常にプロトコルのバージョンを厳密に上げることなく新しいコマンドを追加することができ、オプションやカスタム、ターゲット固有のコマンドを追加して、それらを「調査」することが可能になります。 <ul><li>今のところ、これはDuktapeにのみ適用されます。Duktapeはリクエストを送信せず、通知のみを送信します。 Duktapeはリクエストを送ることはなく、通知だけを送ります。 * サポートされていないコマンド番号の通知を相手が受け取った場合、その通知を無視 しなければならず、デバッグ接続を切断してはいけません(MUST NOT)。その理由はリクエストと同じである。</li></ul></li><li>サポートされているコマンドがパースされ、EOMの前に追加のdvalueが ある場合、最後のdvalueは無視されなければならない[MUST]。 これは、新しいコマンド番号を割り当てたり、プロトコルのバージョンを上げ たりすることなく、既存のコマンドを(場合によっては)拡張することができる ようにするものである。</li></ul><p>これらの単純なルールは実装が簡単で、いくつかの一般的なケースでプロトコルを優雅に拡張することができます(もちろんすべてではありませんが)。</p><h3 id="d値およびデバッグメッセージのテキスト表示" tabindex="-1">d値およびデバッグメッセージのテキスト表示 <a class="header-anchor" href="#d値およびデバッグメッセージのテキスト表示" aria-label="Permalink to &quot;d値およびデバッグメッセージのテキスト表示&quot;">​</a></h3><p><strong>これは、このドキュメントとduk_debug.jsのダンプで使用される情報提供の慣習です</strong>。</p><p>Duktapeデバッグクライアントは、以下の規約を使用して、dvalueをテキストで表現します。 Duktapeデバッグ・クライアントは、dvaluesをテキストとして表現するために、以下の規約を使用します。</p><ul><li>マーカバイト: <code>EOM</code>, <code>REQ</code>, <code>REP</code>, <code>ERR</code>, <code>NFY</code>.</li><li>整数: <code>-123</code> などのように、文字列を正規化したもの。</li><li>文字列は、バイト列 (0x00...0xff) からコードポイント U+0000...U+00FF に1対1でマッピングされ、JSON にエンコードされる。 JSONエンコーディングは、結果にエスケープされていない改行がないことを保証します。 標準的なJSONは、コードポイントU+0080...U+00FFをすべてエスケープしないので、残念ながらおかしなことになります（ASCIIのみのシリアライズが望ましいでしょう）。</li><li>その他の型は、JSONマッピングのようにJSONエンコードされています、以下を参照してください。</li></ul><p>デバッグメッセージは、関連するすべてのd値(メッセージタイプマーカーとEOMを含む)を空白で区切った1行で表現されるだけです。これにより、テキストダンプは読みやすく、カットアンドペーストや診断などが容易になります。</p><p>例として、ペイロードが文字列「touché」、整数「123」、整数「-321」からなる応答を考えてみよう。 この文字列は、Duktape内部でUTF-8シーケンス:.Touchéとして表現されます。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">74 6f 75 63 68 c3 a9</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>返信メッセージの生のバイトは、（パイプで区切られたdvaluesで）次のようになります：。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">02 | 67 74 6f 75 63 68 c3 a9 | c0 7b | 10 ff ff fe bf | 00</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>これは、テキストのワンライナーとしてレンダリングされます：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">REP &quot;touch\\u00c3\\u00a9&quot; 123 -321 EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Duktape内部で文字列が使用する正確なバイト数を維持するために、奇数文字列のマッピングが選択されます。 Duktapeの文字列の中には、意図的に無効なUTF-8を使用しているものがあるので、Unicodeにマッピングすることが常に選択肢になるわけではないことに注意してください。 この文字列マッピングは、バッファ・データを表現するためにも使用されます。</p><h3 id="デバッグ・プロトコルのためのjsonマッピング" tabindex="-1">デバッグ・プロトコルのためのJSONマッピング <a class="header-anchor" href="#デバッグ・プロトコルのためのjsonマッピング" aria-label="Permalink to &quot;デバッグ・プロトコルのためのJSONマッピング&quot;">​</a></h3><p>このセクションで説明するマッピングは、デバッグのd値やメッセージをJSONの値にマッピングするために使用されます。 このマッピングは JSON デバッグプロキシーの実装に使用され、デバッグクライアントはバイナリプロトコルを全く実装せずに、クリーンな JSON メッセージだけを使用してデバッグターゲットと対話できるようになります。</p><h3 id="dvalues-の-json-表現" tabindex="-1">dvalues の JSON 表現 <a class="header-anchor" href="#dvalues-の-json-表現" aria-label="Permalink to &quot;dvalues の JSON 表現&quot;">​</a></h3><ul><li>Unused::</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">unused</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Undefined::</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">undefined</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Null、true、falseはJSONに直接マッピングされます。</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#89DDFF;">true</span></span>
<span class="line"><span style="color:#89DDFF;">false</span></span>
<span class="line"></span></code></pre></div><ul><li>整数は、JSONの数値型に直接マッピングされます：。</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">1234</span></span>
<span class="line"></span></code></pre></div><ul><li>JSONの数値として損失なく表現できない数値（無限大、NaN、負のゼロなど）は、次のように表現されます。</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// data contains IEEE double in big endian hex encoded bytes</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// (here Math.PI)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">number</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">data</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">400921fb54442d18</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>このオブジェクトには、オプションで <code>value</code> フィールドを含めることができ、これは JSON 互換の近似値として数値を提供します。 このフィールドは、JSON互換の近似値として数値を提供します。生のIEEE doubleと比較して、いくつかの精度が失われる可能性があります。 また、NaNや無限大の場合は <code>null</code> となり、コードを書く際に <code>JSON.stringify()</code> で値をエンコードすることができるようになります。 例::</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 4.5</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">number</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">data</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">4012000000000000</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4.5</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// +Infinity</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">number</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">data</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">7ff0000000000000</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>重要</strong>: <code>value</code> のキーは機械的に処理されてはならず、JSON プロトコルのテキストを直接読みやすくするためにのみ存在する。 パースするコードは常にこれを無視し、代わりに <code>data</code> を使用しなければならない。</p><ul><li>文字列はテキスト表現と同様にマッピングされます。すなわち、バイト 0x00...0xff は Unicode コードポイント U+0000...U+00FF: にマッピングされます。</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 4 バイトの文字列 0xde 0xad 0xbe 0xef</span></span>
<span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">\\u00de</span><span style="color:#C3E88D;">\\00ad\\00be\\00ef</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div><p>この表現は、バイト単位で正確であり、UTF-8以外の文字列を正しく表現し、かつほとんどの実用的な（ASCII）文字列に対して人間が読みやすいという理由で使用されています。</p><ul><li>バッファデータは、16進エンコードされた形でオブジェクトに包まれて表現されます：。</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">buffer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">data</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">deadbeef</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>メッセージフレーミングの d 値 (EOM, REQ, REP, NFY, ERR) は、JSON プロトコルでは見えません。 これらは <code>duk_debug.js</code> が内部で次のようなフォーマットで使用しています::</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">eom</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">req</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">rep</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">err</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">nfy</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Object::</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// classは数値，ポインタは16進数である．</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">object</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">pointer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">deadbeef</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Pointer::</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// ポインタは16進数である</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">pointer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">pointer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">deadbeef</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Lightfunc::</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// flagsはJSONの数値として表現される16ビット整数、ポインタは16進数で表現されます。</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">lightfunc</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">flags</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1234</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">pointer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">deadbeef</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Heap pointer::</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// ポインタは16進数である</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">heapptr</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">pointer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">deadbeef</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="デバッグメッセージのjson表現" tabindex="-1">デバッグメッセージのJSON表現 <a class="header-anchor" href="#デバッグメッセージのjson表現" aria-label="Permalink to &quot;デバッグメッセージのJSON表現&quot;">​</a></h3><p>メッセージは、以下のようにメッセージタイプマーカーとEOMマーカーを削除したJSONオブジェクトとして表現される。</p><p>request メッセージは、&#39;request&#39; キーと dvalue のリスト (EOM は省略) を含む &#39;args&#39; 配列を用いてコマンドを指定します::</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">request</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">AddBreak</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>args&#39; 引数はオプションである。これがない場合は、空の配列と同じように扱われる: 。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">request</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">AddBreak</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>通常、デバッグコマンドは文字列として指定され、プロキシはデバッガのメタデータを使用して文字列をコマンド番号に自動的にマッピングします。 コマンド番号は明示的に指定することができ、さらに次のように両方指定することもできます。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 明示的なコマンド番号（例：メタデータがカスタムコマンドを知らない）。</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">request</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">24</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 同上、これは以前から使われていた形式です（上記の形式が望ましい）。</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">request</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">command</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">24</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// &#39;request&#39; にはコマンド名を指定し、&#39;command&#39; には予備のコマンドを数値で指定することも可能です。  コマンド名がコマンドメタデータで解決できない場合は、&#39;command&#39; に指定したコマンド番号が使用されます (その場合のみ)。</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">request</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">AddBreak</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">command</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">24</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>返信メッセージはコマンド番号を持たないので、メッセージの種類を区別できるように、 「reply」キーに「true」をセットしておく。 引数は再び&#39;args&#39;（EOMは省略）になります。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">reply</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>エラーメッセージは返信のようなもので、&#39;error&#39; キーには &quot;true&quot; 値が、&#39;args&#39; にはエラー引数（EOM は省略）が含まれます。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">error</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">no space for breakpoint</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>通知メッセージはリクエストと同じ形式ですが、「request」キーが「notify」に置き換えられています。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Status</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">frob</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">808</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>通知コマンド番号の指定には、notifiesの代替形式も用意されています。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">frob</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">808</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">command</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">frob</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">808</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Status</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">command</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">frob</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">123</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">808</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>引数リストが空の場合、&#39;args&#39; はどのメッセージでも省略可能である。</p><p>要求メッセージと通知メッセージは、要求/通知コマンド名と番号の両方を含み、いくつかの形式がサポートされている。 コマンド名／番号は以下のように解決される。</p><ul><li>request&#39; / &#39;notify&#39; にコマンド名が文字列で指定されている場合、コマンドのメタデータ からコマンドを検索します。 コマンド名がわかっている場合、コマンドメタデータのコマンド番号を使用します (「command」キーの可能性は無視します)。</li><li>request&#39; / &#39;notify&#39; でコマンド番号が指定されている場合は、その番号をそのまま使用します。</li><li>command&#39; がコマンド番号を提供している場合、それをそのまま使用します。 request&#39; や &#39;notify&#39; が <code>true</code> 値で存在する場合もありますが、無視されます。</li><li>上記の手順が失敗した場合、request/notifyは処理できません。</li></ul><h3 id="その他のjsonメッセージ" tabindex="-1">その他のJSONメッセージ <a class="header-anchor" href="#その他のjsonメッセージ" aria-label="Permalink to &quot;その他のJSONメッセージ&quot;">​</a></h3><p>上記のコアメッセージフォーマットに加えて、デバッグプロトコルのバージョン情報やトランスポートイベントのためのいくつかのカスタムメッセージがあります。 これらは、アンダースコアで始まる特別なコマンド名とコマンド番号のない「通知」メッセージとして表現されます。 これらは主に人間の読みやすさを向上させるためのもので、細かい部分は必要に応じて変更される可能性があります。</p><p>ターゲットへの接続が試みられると、次のようなnotifyが送信されます</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">_TargetConnecting</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1.2.3.4</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">9091</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>ターゲットに接続すると、バージョン識別がそのまま中継される。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">_TargetConnected</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1 10199 v1.1.0-173-gecd806e-dirty duk command built from Duktape repo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>ターゲットが切断されたとき。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">_TargetDisconnected</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>トランスポートエラーが発生した場合（ターミナルエラーとは限らないので、複数回表示される可能性がある）。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">_Error</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">some kind of error</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>JSONプロキシ接続が切断される寸前の場合：。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">_Disconnecting</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>オプションで reason 引数を含めることができる：。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">notify</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">_Disconnecting</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">args</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Target disconnected</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="jsonプロトコルのラインフォーマット" tabindex="-1">JSONプロトコルのラインフォーマット <a class="header-anchor" href="#jsonプロトコルのラインフォーマット" aria-label="Permalink to &quot;JSONプロトコルのラインフォーマット&quot;">​</a></h3><p>JSONメッセージは、コンパクトなワンライナー形式でエンコードされ、メッセージの最後に改行(LF文字1つ、0x0a)を入れて送信されます。(上記の例は、複数行のフォーマットで書かれていますが、これは <strong>not</strong> 許可されていないことに注意してください; これは単に分かりやすくするためです)。</p><p>この規約により、メッセージの読み書きが容易になります。 メッセージは簡単にカット・ペーストでき、メッセージ・ログを効果的にグ レープすることができます。</p><h2 id="プロトコルの拡張とバージョンの互換性" tabindex="-1">プロトコルの拡張とバージョンの互換性 <a class="header-anchor" href="#プロトコルの拡張とバージョンの互換性" aria-label="Permalink to &quot;プロトコルの拡張とバージョンの互換性&quot;">​</a></h2><p>バージョン識別行は、デバッグプロトコルに互換性のない変更を加えるために使用されるプロトコルのバージョン番号を提供します; デバッグクライアントは常にターゲットのデバッグプロトコルバージョンに準拠するものと想定されます。</p><p>また、以下の基本的な方法で、プロトコルのバージョン番号を変更することなくプロトコルを拡張することが可能です。</p><ul><li><p>新しいコマンドを追加する。 新しいコマンドを追加する。コマンドがサポートされていない場合、ピアは未知の/サポートされていないコマンドを示す特定のエラーを送り返す。</p></li><li><p>リクエスト、レスポンス、または通知に末尾のフィールドを追加する。 ピアはサポートするフィールドを読み込んで処理した後、未知の末尾フィールドをスキップしてEOMに進むことが要求される。 メッセージの中には、可変数のフィールド(例えば、変数名/値ペアのリスト)を持つものがあり、その場合、このアプローチは不可能かもしれない。</p></li></ul><p>これらの拡張は、(1) メッセージの内容を理解せずに EOM にスキップする機能、および (2) 未知のメッセージと未知の末尾 d 値に対する処理要件によって実現されています。</p><p>一般的な設計ルールとして、Duktape内部はバージョン特有の処理や回避策を排除しておく必要があります。 もし、ある機能が互換性のある方法できれいに実装できない場合、コマンドの並列変種を追加したり、他の厄介な妥協をしたりする代わりに、プロトコルのバージョンを上げる必要があります。デバッガのコードを小さくきれいに保ち、ターゲットでのコードフットプリントが損なわれないようにすることが重要です。</p><h2 id="duktape-が送るコマンド" tabindex="-1">Duktape が送るコマンド <a class="header-anchor" href="#duktape-が送るコマンド" aria-label="Permalink to &quot;Duktape が送るコマンド&quot;">​</a></h2><h3 id="状態通知-0x01" tabindex="-1">状態通知(0x01) <a class="header-anchor" href="#状態通知-0x01" aria-label="Permalink to &quot;状態通知(0x01)&quot;">​</a></h3><p>フォーマット::</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NFY </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> 1&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> state&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">str:</span><span style="color:#89DDFF;"> filename&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">str:</span><span style="color:#89DDFF;"> funcname&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> linenumber&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> pc&gt;</span><span style="color:#A6ACCD;"> EOM</span></span>
<span class="line"></span></code></pre></div><p>例::</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NFY 1 0 &quot;foo.js&quot; &quot;frobValues&quot; 101 679 EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>何も実行していない時（例えば、Duktape の起動時以外から duk_debug_cooperate() が呼ばれた時） filename と funcname は未定義（d 値として &quot;undefined&quot; が使われる）、 pc/line は 0 になります。</p><p>状態は、以下のいずれかである。</p><ul><li>0x00: 実行中</li><li>0x01: 一時停止中、デバッグクライアントを再開する必要があります。</li></ul><p>実行状態が変化した場合（例：一時停止から実行中、またはその逆）、Duktapeは常にStatus通知を送信します。</p><p>デバッガを接続してDuktapeを実行している場合、どのファイル／行／関数が実行されているかをデバッグ・クライアントに知らせるために、随時ステータス通知を送信します。</p><p>ステータス更新のレートは、日付ベースのタイムスタンプを使用して自動的に制限されるため、Duktapeが通常モードまたはチェック・モードで動作している場合、ステータス更新は最大で200msごとに送信されます。</p><h3 id="予約済み-0x02" tabindex="-1">予約済み (0x02) <a class="header-anchor" href="#予約済み-0x02" aria-label="Permalink to &quot;予約済み (0x02)&quot;">​</a></h3><p>(Duktape 2.0.0で削除、Duktape 1.xで印刷通知）。</p><h3 id="予約済み-0x03" tabindex="-1">予約済み (0x03) <a class="header-anchor" href="#予約済み-0x03" aria-label="Permalink to &quot;予約済み (0x03)&quot;">​</a></h3><p>(Duktape2.0.0で削除。Duktape1.xではアラート通知)</p><h3 id="ログ通知-0x04" tabindex="-1">ログ通知(0x04) <a class="header-anchor" href="#ログ通知-0x04" aria-label="Permalink to &quot;ログ通知(0x04)&quot;">​</a></h3><p>(Duktape2.0.0で削除。Duktape1.xでログ通知)</p><h3 id="throw通知-0x05" tabindex="-1">throw通知(0x05) <a class="header-anchor" href="#throw通知-0x05" aria-label="Permalink to &quot;throw通知(0x05)&quot;">​</a></h3><p>Format::</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">    NFY </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> 5&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> fatal&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">str:</span><span style="color:#89DDFF;"> msg&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">str:</span><span style="color:#89DDFF;"> filename&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> linenumber&gt;</span><span style="color:#A6ACCD;"> EOM</span></span>
<span class="line"></span></code></pre></div><p>Example::</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">    NFY 5 1 &quot;ReferenceError: identifier not defined&quot; &quot;pig.js&quot; 812 EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Fatalは、その一つです。</p><ul><li>0x00: キャッチ</li><li>0x01: 致命的(捕捉されない)</li></ul><p>Duktapeは、ランタイム・エラーによってDuktapeによって、あるいはECMAScriptコードによって直接、エラーが投げられるたびにThrow通知を送信します。</p><p>msgはスローされる文字列強制の値です。 ファイル名と行番号は、スローされたオブジェクトがErrorインスタンス（拡張後）であれば直接取得され、そうでなければ、これらの値はバイトコード・エグゼキュータの状態から計算されます。</p><h3 id="通知解除-0x06" tabindex="-1">通知解除 (0x06) <a class="header-anchor" href="#通知解除-0x06" aria-label="Permalink to &quot;通知解除 (0x06)&quot;">​</a></h3><p>フォーマット：:</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NFY </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> 6&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">int:</span><span style="color:#89DDFF;"> reason&gt;</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">str:</span><span style="color:#89DDFF;"> msg&gt;</span><span style="color:#A6ACCD;">] EOM</span></span>
<span class="line"></span></code></pre></div><p>例::</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NFY 6 1 &quot;d値のパースエラー&quot; EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>理由は以下のいずれかです。</p><ul><li>0x00: 正常なデタッチ</li><li>0x01: ストリームエラーによるデタッチ</li></ul><p>Duktapeは、デバッガがデタッチする際にDetaching通知を送信します。 クライアントがこの通知を見ることなくターゲットがトランスポートをドロップした場合、接続が失われたと仮定し、それに応じて対応することができます（例えば、リンクを再確立しようとする）。</p><p>msg\`\` はオプションの文字列で、切り離しの理由を詳しく説明します。 これは切り離しの性質によって、存在する場合としない場合があります。</p><h3 id="appnotify-notification-0x07" tabindex="-1">AppNotify notification (0x07) <a class="header-anchor" href="#appnotify-notification-0x07" aria-label="Permalink to &quot;AppNotify notification (0x07)&quot;">​</a></h3><p>フォーマット:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NFY &lt;int: 0x07&gt; [&lt;tval&gt;]* EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>例:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NFY 7 &quot;DebugPrint&quot; &quot;Everything is going according to plan!&quot; EOM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>これはカスタム通知メッセージで、その意味とセマンティクスはアプリケーションに依存します。 アプリケーションに依存します。</p><p>AppNotifyメッセージは、Duktapeデバッグ・プロトコルを介したデバッグ・クライアントとデバッグ・ターゲット間の直接通信のために使用されます。 カスタム・メッセージの意味とそれに含まれるdvalueの両方は、完全に実装次第であり、アプリケーションのニーズによっては、まったくサポートされないこともあります。</p><p>詳細については、以下の「カスタム・リクエストと通知」を参照してください。</p><h2 id="commands-sent-by-debug-client" tabindex="-1">Commands sent by debug client <a class="header-anchor" href="#commands-sent-by-debug-client" aria-label="Permalink to &quot;Commands sent by debug client&quot;">​</a></h2><h3 id="basicinfo-request-0x10" tabindex="-1">BasicInfo request (0x10) <a class="header-anchor" href="#basicinfo-request-0x10" aria-label="Permalink to &quot;BasicInfo request (0x10)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x10&gt; EOM
REP &lt;int: DUK_VERSION&gt; &lt;str: DUK_GIT_DESCRIBE&gt; &lt;str: target info&gt;
    &lt;int: endianness&gt; &lt;int: sizeof(void *)&gt; EOM
</code></pre><p>Example:</p><pre><code>REQ 16 EOM
REP 10099 &quot;v1.0.0-254-g2459e88&quot; &quot;Arduino Yun&quot; 2 4 EOM
</code></pre><p>Endianness:</p><ul><li>1 = little endian</li><li>2 = mixed endian (doubles in ARM &quot;mixed&quot; endian, integers little endian)</li><li>3 = big endian</li></ul><p>Endianness affects decoding of a few dvalues.</p><p>Target info is a string that can be compiled in, and can e.g. describe the device type.</p><p>Void pointer size indicates pointer size used for pointer-related values. Note that function pointers may have a different size.</p><h3 id="triggerstatus-request-0x11" tabindex="-1">TriggerStatus request (0x11) <a class="header-anchor" href="#triggerstatus-request-0x11" aria-label="Permalink to &quot;TriggerStatus request (0x11)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x11&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 17 EOM
REP EOM
</code></pre><p>Duktape will then re-send a status notify.</p><h3 id="pause-request-0x12" tabindex="-1">Pause request (0x12) <a class="header-anchor" href="#pause-request-0x12" aria-label="Permalink to &quot;Pause request (0x12)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x12&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 18 EOM
REP EOM
</code></pre><p>If Duktape is already paused, a no-op. If Duktape is running, Duktape will check for incoming debug messages from time to time. When Duktape notices the pause request (which can take seconds) it will reply to the request, pause execution, and send a Status notification indicating it has paused.</p><h3 id="resume-request-0x13" tabindex="-1">Resume request (0x13) <a class="header-anchor" href="#resume-request-0x13" aria-label="Permalink to &quot;Resume request (0x13)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x13&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 19 EOM
REP EOM
</code></pre><p>If Duktape is already running, a no-op. If Duktape is paused, it will exit the debug message loop associated with the paused state (where control is fully in the hands of the debug client), resume execution, and send a Status notification indicating it is running.</p><h3 id="stepinto-request-0x14" tabindex="-1">StepInto request (0x14) <a class="header-anchor" href="#stepinto-request-0x14" aria-label="Permalink to &quot;StepInto request (0x14)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x14&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 20 EOM
REP EOM
</code></pre><p>Resume execution and pause when execution exits the current line, enters another function, exits the current function, or an error is thrown past the current function (in which case execution pauses in the error catcher, if any). If the current function doesn&#39;t have line information (e.g. it is native), pauses on function entry/exit or error throw.</p><h3 id="stepover-request-0x15" tabindex="-1">StepOver request (0x15) <a class="header-anchor" href="#stepover-request-0x15" aria-label="Permalink to &quot;StepOver request (0x15)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x15&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 21 EOM
REP EOM
</code></pre><p>Resume execution and pause when execution exits the current line, exits the current function, or an error is thrown past the current function (in which case execution pauses in the error catcher, if any). If the current function doesn&#39;t have line information (e.g. it is native), pauses on function exit or error throw.</p><h3 id="stepout-request-0x16" tabindex="-1">StepOut request (0x16) <a class="header-anchor" href="#stepout-request-0x16" aria-label="Permalink to &quot;StepOut request (0x16)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x16&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 22 EOM
REP EOM
</code></pre><p>Resume execution and pause when execution exits the current function or an error is thrown past the current function (in which case execution pauses in the error catcher, if any).</p><h3 id="listbreak-request-0x17" tabindex="-1">ListBreak request (0x17) <a class="header-anchor" href="#listbreak-request-0x17" aria-label="Permalink to &quot;ListBreak request (0x17)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x17&gt; EOM
REP [ &lt;str: fileName&gt; &lt;int: line&gt; ]* EOM
</code></pre><p>Example (two breakpoints):</p><pre><code>REQ 23 EOM
REP &quot;foo.js&quot; 102 &quot;bar.js&quot; 99 EOM
</code></pre><h3 id="addbreak-request-0x18" tabindex="-1">AddBreak request (0x18) <a class="header-anchor" href="#addbreak-request-0x18" aria-label="Permalink to &quot;AddBreak request (0x18)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x18&gt; &lt;str: fileName&gt; &lt;int: line&gt; EOM
REP &lt;int: breakpoint index&gt; EOM
</code></pre><p>Example:</p><pre><code>REQ 24 &quot;foo.js&quot; 109 EOM
REP 3 EOM
</code></pre><p>If there&#39;s no space for more breakpoints, a &quot;too many&quot; error is sent:</p><pre><code>REQ 24 &quot;foo.js&quot; 109 EOM
ERR 2 &quot;no space for breakpoint&quot; EOM
</code></pre><h3 id="delbreak-request-0x19" tabindex="-1">DelBreak request (0x19) <a class="header-anchor" href="#delbreak-request-0x19" aria-label="Permalink to &quot;DelBreak request (0x19)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x19&gt; &lt;int: index&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 25 3 EOM
REP EOM
</code></pre><p>If an invalid index is used, an error reply is sent.</p><h3 id="getvar-request-0x1a" tabindex="-1">GetVar request (0x1a) <a class="header-anchor" href="#getvar-request-0x1a" aria-label="Permalink to &quot;GetVar request (0x1a)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x1a&gt; &lt;int: level&gt; &lt;str: varname&gt; EOM
REP &lt;int: 0/1, found&gt; &lt;tval: value&gt; EOM
</code></pre><p>Example:</p><pre><code>REQ 26 -1 &quot;testVar&quot; EOM
REP 1 &quot;myValue&quot; EOM
</code></pre><p>Level specifies the callstack depth, where -1 is the topmost (current) function, -2 is the calling function, etc. If not provided, the topmost function will be used.</p><h3 id="putvar-request-0x1b" tabindex="-1">PutVar request (0x1b) <a class="header-anchor" href="#putvar-request-0x1b" aria-label="Permalink to &quot;PutVar request (0x1b)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x1b&gt; &lt;int: level&gt; &lt;str: varname&gt; &lt;tval: value&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 27 -1 &quot;testVar&quot; &quot;newValue&quot; EOM
REP EOM
</code></pre><p>Level specifies the callstack depth, where -1 is the topmost (current) function, -2 is the calling function, etc. If not provided, the topmost function will be used.</p><h3 id="getcallstack-request-0x1c" tabindex="-1">GetCallStack request (0x1c) <a class="header-anchor" href="#getcallstack-request-0x1c" aria-label="Permalink to &quot;GetCallStack request (0x1c)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x1c&gt; EOM
REP [ &lt;str: fileName&gt; &lt;str: funcName&gt; &lt;int: lineNumber&gt; &lt;int: pc&gt; ]* EOM
</code></pre><p>Example:</p><pre><code>REQ 28 EOM
REP &quot;foo.js&quot; &quot;doStuff&quot; 100 317 &quot;bar.js&quot; &quot;doOtherStuff&quot; 210 880 EOM
</code></pre><p>List callstack entries from top to bottom.</p><h3 id="getlocals-request-0x1d" tabindex="-1">GetLocals request (0x1d) <a class="header-anchor" href="#getlocals-request-0x1d" aria-label="Permalink to &quot;GetLocals request (0x1d)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x1d&gt; &lt;int: level&gt; EOM
REP [ &lt;str: varName&gt; &lt;tval: varValue&gt; ]* EOM
</code></pre><p>Example:</p><pre><code>REQ 29 -1 EOM
REP &quot;x&quot; &quot;1&quot; &quot;y&quot; &quot;3.1415&quot; &quot;foo&quot; &quot;bar&quot; EOM
</code></pre><p>List local variable names from specified activation (the internal <code>_Varmap</code>). Level specifies the callstack depth, where -1 is the topmost (current) function, -2 is the calling function, etc.</p><p>The result includes only local variables declared with <code>var</code> and locally declared functions. Variables outside the current function scope, including outer functions and global variables, are not included.</p><p>::: note ::: title Note :::</p><p>The local variable list doesn&#39;t currently include dynamically declared variables introduced by e.g. eval(), or variables with a dynamic scope like the catch variable in try-catch. This will be fixed in future versions. :::</p><h3 id="eval-request-0x1e" tabindex="-1">Eval request (0x1e) <a class="header-anchor" href="#eval-request-0x1e" aria-label="Permalink to &quot;Eval request (0x1e)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x1e&gt; (&lt;int: level&gt; | &lt;null&gt;) &lt;str: expression&gt; EOM
REP &lt;int: 0=success, 1=error&gt; &lt;tval: value&gt; EOM
</code></pre><p>Example:</p><pre><code>REQ 30 null &quot;1+2&quot; EOM
REP 0 3 EOM
</code></pre><p>Level specifies the callstack depth, where -1 is the topmost (current) function, -2 is the calling function, etc. If not provided, the topmost function will be used (as with a real <code>eval()</code>). The level affects only the lexical scope of the code evaluated. The callstack will be intact, and will be visible in e.g. stack traces and <code>Duktape.act()</code>. The level can also be null to perform an indirect Eval.</p><p>If a valid callstack level is given, the eval expression is evaluated as if a &quot;direct call&quot; to eval was executed in the position where execution has paused, in the lexical scope specified by the provided callstack level. A direct eval call shares the same lexical scope as the function it is called from (an indirect eval call does not). For instance, suppose we&#39;re executing:</p><pre><code>function foo(x, y) {
    print(x);  // (A)
    print(y);  // (B) &lt;== paused here (before print(y))
}

foo(100, 200);
</code></pre><p>and you&#39;d eval:</p><pre><code>print(x + y); y = 10; &quot;quux&quot;
</code></pre><p>The Eval would execute as if the code had been:</p><pre><code>function foo(x, y) {
    print(x);
    eval(&#39;print(x + y); y = 10; &quot;quux&quot;);
    print(y);
}

foo(100, 200);
</code></pre><p>so that the Eval statement would:</p><ul><li>Print out 300 (using print).</li><li>Assign 10 to <code>y</code> so that statement B would then print 10 (instead of 200).</li><li>The final result of the eval would be the string <code>&quot;quux&quot;</code>, which would then be shown in the debug client UI.</li></ul><p>When Eval is requested from outside any Duktape activation, e.g. while doing a duk_debugger_cooperate() call, there is no active ECMAScript activation so that a &quot;direct&quot; Eval is not possible. Eval will then be executed as an indirect Eval instead. As noted above, you can request an indirect Eval explicitly by sending null for the callstack level.</p><p>Current limitations:</p><ul><li>Can get stuck in an infinite loop.</li><li>The debug code runs inside an actual <code>eval()</code> call which affects the call stack. For example, <code>Duktape.act()</code> will see the additional stack frames.</li></ul><h3 id="detach-request-0x1f" tabindex="-1">Detach request (0x1f) <a class="header-anchor" href="#detach-request-0x1f" aria-label="Permalink to &quot;Detach request (0x1f)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x1f&gt; EOM
REP EOM
</code></pre><p>Example:</p><pre><code>REQ 31 EOM
REP EOM
</code></pre><p>Request that Duktape detach the debugger. Duktape requests the user transport code to close the transport connection, and then resumes normal execution.</p><h3 id="dumpheap-request-0x20" tabindex="-1">DumpHeap request (0x20) <a class="header-anchor" href="#dumpheap-request-0x20" aria-label="Permalink to &quot;DumpHeap request (0x20)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x20&gt; EOM
REP &lt;dvalues&gt; EOM
</code></pre><p>Example:</p><pre><code>REQ 32 EOM
REP &lt;dvalues&gt; EOM
</code></pre><p>Dump contents of the entire Duktape heap. The format of the heap dump is somewhat complicated; see <code>duk_debugger.c</code> for the format.</p><p>This is used to implement a debugger UI feature where you can download a JSON dump of the heap state for analysis.</p><p>::: note ::: title Note :::</p><p>This command is somewhat incomplete at the moment. It will be useful to implement a heap browser, and will probably be completed together with some kind of UI. :::</p><p>::: note ::: title Note :::</p><p>The dump format may potentially change to leverage GetHeapObjInfo to read details of individual heap objects. This command would then simply provide a list of objects the debug client can inspect on its own. :::</p><h3 id="getbytecode-request-0x21" tabindex="-1">GetBytecode request (0x21) <a class="header-anchor" href="#getbytecode-request-0x21" aria-label="Permalink to &quot;GetBytecode request (0x21)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x21&gt; (&lt;int: level&gt; | &lt;obj: target&gt; | &lt;heapptr: target&gt;) EOM
REP &lt;int: numconsts&gt; (&lt;tval: const&gt;){numconsts}
    &lt;int: numfuncs&gt; (&lt;tval: func&gt;){numfuncs}
    &lt;str: bytecode&gt; EOM
</code></pre><p>Example without argument, gets bytecode for current function:</p><pre><code>REQ 33 EOM
REP 2 &quot;foo&quot; &quot;bar&quot; 0  &quot;...bytecode...&quot; EOM
</code></pre><p>Callstack level can be given explicitly, for example -3 is the third callstack level counting from callstack top:</p><pre><code>REQ 33 -3 EOM
REP 2 &quot;foo&quot; &quot;bar&quot; 0  &quot;...bytecode...&quot; EOM
</code></pre><p>An explicit ECMAScript function object can also be given using an &quot;object&quot; or &quot;heapptr&quot; dvalue:</p><pre><code>REQ 33 {&quot;type&quot;:&quot;object&quot;,&quot;class&quot;:6,&quot;pointer&quot;:&quot;00000000014839e0&quot;} EOM
REP 2 &quot;foo&quot; &quot;bar&quot; 0  &quot;...bytecode...&quot; EOM
</code></pre><p>An error reply is returned if:</p><ul><li>The argument exists but has an invalid type or points to a target value which is not an ECMAScript function.</li><li>Callstack entry doesn&#39;t exist or isn&#39;t an ECMAScript activation.</li></ul><p>Notes:</p><ul><li>Bytecode endianness is target specific so the debug client needs to get target endianness and interpret the bytecode based on that.</li><li>Minor change from Duktape 1.4.0: when the callstack entry doesn&#39;t exist Duktape 1.5.x and above will return an error rather than an empty result.</li></ul><p>::: note ::: title Note :::</p><p>This command is somewhat incomplete at the moment and may be modified once the best way to do this in the debugger UI has been figured out. :::</p><p>::: note ::: title Note :::</p><p>This command may be removed in favor of using GetHeapObjInfo to get the same bytecode information. :::</p><h3 id="apprequest-request-0x22" tabindex="-1">AppRequest request (0x22) <a class="header-anchor" href="#apprequest-request-0x22" aria-label="Permalink to &quot;AppRequest request (0x22)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x22&gt; [&lt;tval&gt;*] EOM
REP [&lt;tval&gt;*] EOM
</code></pre><p>Example:</p><pre><code>REQ 34 &quot;GameInfo&quot; &quot;GetTitle&quot; EOM
REP &quot;Spectacles: Bruce&#39;s Story&quot; EOM
</code></pre><p>If the target hasn&#39;t registered a request callback, Duktape responds:</p><pre><code>ERR 2 &quot;AppRequest unsupported by target&quot; EOM
</code></pre><p>The application request callback may also indicate an error, e.g.:</p><pre><code>ERR 4 &quot;missing argument for SetFrameRate&quot;
</code></pre><p>This is a custom request message whose meaning and semantics depend on the application.</p><p>AppRequest messages are used for direct communication between the debug client and debug target over the Duktape debug protocol. Both the meaning of a custom message and the dvalues it contains are entirely up to the implementation and depending on the needs of the application, need not be supported at all.</p><p>See &quot;Custom requests and notifications&quot; below for more details.</p><h3 id="getheapobjinfo-0x23" tabindex="-1">GetHeapObjInfo (0x23) <a class="header-anchor" href="#getheapobjinfo-0x23" aria-label="Permalink to &quot;GetHeapObjInfo (0x23)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x23&gt; (&lt;heapptr: target&gt; | &lt;object: target&gt; | &lt;pointer: target&gt;) EOM
REP [&lt;int: flags&gt; &lt;str/int: key&gt; [&lt;tval: value&gt; | &lt;obj: getter&gt; &lt;obj: setter&gt;]]* EOM
</code></pre><p>Example:</p><pre><code>REQ 35 { &quot;type&quot;: &quot;heapptr&quot;, &quot;pointer&quot;: &quot;deadbeef&quot; } EOM
REP 0 &quot;class_name&quot; &quot;ArrayBuffer&quot; ... EOM
</code></pre><p>Inspect a heap object using the provided heap pointer; any dvalue type containing a pointer is allowed: heapptr, object, pointer. The debug client is responsible for ensuring that the pointer is safe, i.e. that the pointer is valid and the pointer target is still in the Duktape heap:</p><ul><li>When the debugger is paused garbage collection is automatically disabled so that any pointers obtained while the debugger remains paused are safe. Once execution is resumed using Resume or a step command, all pointers are potentially invalidated by garbage collection.</li><li>When the debugger is not paused the debug client may safely inspect an object if it&#39;s known with 100% certainty that the object is reachable and therefore safe to inspect. Because this is generally not a safe assumption, you should avoid making it unless it&#39;s really necessary.</li><li><strong>WARNING</strong>: Inspecting an unsafe pointer causes memory unsafe behavior and may lead to crashes, etc.</li></ul><p>The result is a list of artificial property entries, each containing a flags field, a key, and a value. See GetObjPropDesc for the shared format used.</p><p>Artificial properties are not actually present in a property table but are generated based on e.g. <code>duk_heaphdr</code> flags and are string keyed to make versioning easier. Artifical properties expose internal fields which may change between versions and are not part of version guarantees. As a result the artificial property keys and/or values may change between versions. However, because the properties are string keyed it&#39;s relatively easy for the debug client to adapt to such changes.</p><p>The current artificial keys are described in the section &quot;Heap object inspection&quot;.</p><h3 id="getobjpropdesc-0x24" tabindex="-1">GetObjPropDesc (0x24) <a class="header-anchor" href="#getobjpropdesc-0x24" aria-label="Permalink to &quot;GetObjPropDesc (0x24)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x24&gt; &lt;obj: target&gt; &lt;str: key&gt; EOM
REP &lt;int: flags&gt; (&lt;str: key&gt; | &lt;int: key&gt;) (&lt;tval: value&gt; | &lt;obj: getter&gt; &lt;obj: setter&gt;) EOM
</code></pre><p>Example:</p><pre><code>REQ 36 { &quot;type&quot;: &quot;object&quot;, &quot;class&quot;: 10, &quot;pointer&quot;: &quot;deadbeef&quot; } &quot;message&quot; EOM
REP 7 &quot;message&quot; &quot;Hello there!&quot; EOM
</code></pre><p>Inspect a property of an ECMAScript object using a specific string key without causing side effects such as getter calls or Proxy traps. The result is either:</p><ul><li>A property value using the format described below.</li><li>A &quot;not found&quot; error if the property doesn&#39;t exist.</li></ul><p>Properties stored in the internal &quot;array part&quot; are indexed using numeric string keys, e.g. <code>&quot;3&quot;</code>, not integers.</p><p>Proxy objects are inspected as is without invoking any traps. The only properties usually available are the Duktape specific internal control properties indicating the target and the handler object with traps. A Proxy object can be reliably detected using the artificial property <code>exotic_proxyobj</code> returned by GetHeapObjInfo.</p><p>See GetHeapObjInfo for notes about pointer safety.</p><p>Each property entry is described using the following sequence of dvalues (this format is shared with other property related commands, including GetHeapObjInfo and GetObjPropDescRange):</p><ul><li>Flags field <ul><li>A bit mask (described below)</li></ul></li><li>Key <ul><li>Always a string, for array index properties convert index to canonical index string (e.g. <code>&quot;3&quot;</code>)</li></ul></li><li>Property value: <ul><li>If property is not an accessor (apparent from flags field): single dvalue representing a duk_tval</li><li>If property is an accessor: two dvalues pointing to getter and setter functions (respectively)</li></ul></li></ul><p>The flags field is an unsigned integer bitmask with the following bits:</p><hr><p>Bitmask Description</p><hr><p>0x01 Property attribute: writable, matches DUK_PROPDESC_FLAG_WRITABLE.</p><p>0x02 Property attribute: enumerable, matches DUK_PROPDESC_FLAG_ENUMERABLE.</p><p>0x04 Property attribute: configurable, matches DUK_PROPDESC_FLAG_CONFIGURABLE.</p><p>0x08 Property attribute: accessor, matches DUK_PROPDESC_FLAG_ACCESSOR.</p><p>0x10 Property is virtual, matches DUK_PROPDESC_FLAG_VIRTUAL.</p><p>0x100 Property key is a Symbol.</p><h2 id="_0x200-property-is-a-hidden-symbol-which-is-not-visible-to-ordinaryecmascript-code" tabindex="-1">0x200 Property is a hidden Symbol which is not visible to ordinary ECMAScript code. <a class="header-anchor" href="#_0x200-property-is-a-hidden-symbol-which-is-not-visible-to-ordinaryecmascript-code" aria-label="Permalink to &quot;0x200     Property is a hidden Symbol which is not visible to ordinary
            ECMAScript code.&quot;">​</a></h2><p>For artificial properties (returned by GetHeapObjInfo) the property attributes are not relevant (sent as zero) and the value is currently never an accessor.</p><h3 id="getobjpropdescrange-0x25" tabindex="-1">GetObjPropDescRange (0x25) <a class="header-anchor" href="#getobjpropdescrange-0x25" aria-label="Permalink to &quot;GetObjPropDescRange (0x25)&quot;">​</a></h3><p>Format:</p><pre><code>REQ &lt;int: 0x25&gt; &lt;obj: target&gt; &lt;int: idx_start&gt; &lt;int: idx_end&gt; EOM
REP [&lt;int: flags&gt; (&lt;str: key&gt; | &lt;int: key&gt;) (&lt;tval: value&gt; | &lt;obj: getter&gt; &lt;obj: setter&gt;)]* EOM
</code></pre><p>Example:</p><pre><code>REQ 37 { &quot;type&quot;: &quot;object&quot;, &quot;class&quot;: 10, &quot;pointer&quot;: &quot;deadbeef&quot; } 0 2 EOM
REP 7 &quot;name&quot; &quot;Example object&quot; 7 &quot;message&quot; &quot;Hello there!&quot; EOM
</code></pre><p>Inspect a range <code>[idx_start,idx_end[</code> of an ECMAScript object&#39;s &quot;own&quot; properties. Result contains properties found; if the start/end index is larger than available property count those values will be missing from the result entirely. For example, if the object has 3 properties and the range <code>[0,10[</code> is requested, the result will contain 3 properties only. If the indices are crossed (e.g. <code>[10,5[</code>) an empty result is returned.</p><p>The indices in the range <code>[idx_start,idx_end[</code> refer to a conceptual index space which is guaranteed to be stable as long as (1) execution is paused so that garbage collection is prevented, and (2) the object is not mutated. The property order within the index space has no specific guarantees and does not necessarily match enumeration order; the debug client should reorder the properties if a specific presentation order is needed.</p><p>The current index space (which may change in future versions) contains:</p><ul><li>The object&#39;s internal array part, indices <code>[0,a_size[</code>. Here <code>a_size</code> is the space allocated for the dense array part and may be larger than the apparent <code>.length</code> property of the array. Unmapped values and missing array indices are returned as &quot;unused&quot; dvalues.</li><li>The object&#39;s internal entry part, indices <code>[0,e_next[</code>. The entry part may contain deleted properties which are returned as &quot;unused&quot; dvalues.</li></ul><p>The debug client doesn&#39;t need to care about these details, and can simply read arbitrary ranges (even those spanning the two parts) provided that it correctly deals with &quot;unused&quot; values.</p><p>The debug client can request all properties simply by requesting the index range <code>[0,0x7fffffff[</code> (signed indices for now). The result will only contain as many properties as are actually present.</p><p>The debug client can also iterate over the property set incrementally as follows:</p><ul><li>Request index ranges in sequence, for example <code>[0,10[</code>, <code>[10,20[</code>, etc.</li><li>When a partial result (here less than 10 properties) is received, we&#39;re done. Equivalent approach is to stop iterating when you get an entirely empty result.</li></ul><p>The properties included in the index space are the target object&#39;s &quot;own&quot; properties, without side effects:</p><ul><li>Property attributes are provided in a flags field. Internal properties, currently implemented using keys starting with the 0xFF byte, are flagged explicitly so that the debug client doesn&#39;t need to check the marker byte (which may change in future versions) separately.</li><li>Accessor properties are described as is, as a setter/getter pair, without invoking the getter. The debug client can do that explicitly if it so desires.</li><li>Inherited properties are not enumerated. The debug client can walk the prototype chain manually by looking up the <code>prototype</code> artificial property and inspecting that object separately. Prototype walking should carefully avoid failing on a prototype loop.</li><li>Some properties which are implemented in a fully virtualized fashion are visible in ECMAScript enumeration but may not be visible in the inspection. For example, String object has virtual index properties (0, 1, 2, ...) for string characters, and these are not included in the inspection result at the moment. They can be read using GetObjPropDesc, however.</li><li>Proxy traps are not invoked, and the properties returned are the &quot;own&quot; properties of the Proxy itself. Typically the Proxy has only Duktape specific internal control properties identifying the Proxy target and handler table.</li></ul><p>Note that Array objects can be dense or sparse. This distinction is internal: dense arrays have an array part where the array items are stored while sparse arrays don&#39;t have an array part and array items are stored in the main property table together with normal string keyed properties. Array items for sparse arrays will thus appear as normal string keyed properties, and may not be in ascending index order; the debug client should always reorder properties to fit the preferred display order. Array gaps may be visible either as missing keys or as keys with the dvalue &quot;unused&quot;. Currently gaps in sparse arrays will be visible as missing keys while gaps in dense arrays are visible as &quot;unused&quot; dvalues; the debug client should handle both cases.</p><p>See GetHeapObjInfo for notes about pointer safety.</p><h2 id="custom-requests-and-notifications" tabindex="-1">Custom requests and notifications <a class="header-anchor" href="#custom-requests-and-notifications" aria-label="Permalink to &quot;Custom requests and notifications&quot;">​</a></h2><p>Starting in Duktape 1.5.x, Duktape supports direct communication between the debug client and debug target over the same transport by using the special AppRequest and AppNotify messages. These messages have no meaning to Duktape, which merely serves to marshal them back and forth through a defined API.</p><p>AppNotify messages may be sent by pushing the contents of the message to the stack and calling <code>duk_debugger_notify()</code> passing the number of values pushed. Each value pushed will be sent as a dvalue in the message. So if you push two strings, &quot;foo&quot; and &quot;bar&quot;, the client will see <code>NFY 7 &quot;foo&quot; &quot;bar&quot; EOM</code>.</p><p>AppRequest is used to make requests to the target which are not directly related to ECMAScript execution and may be implementation-dependent. For example, an AppRequest might be used to:</p><ul><li>Download source files directly from the debug target file system</li><li>Change the frame rate of a game engine</li><li>Reset/reboot an embedded target device while debugging</li><li>Perform or trigger software or script updates</li></ul><p>A target that wishes to support AppRequest should provide a request callback when calling <code>duk_debugger_attach()</code>. When an AppRequest is received, the request callback is invoked with the contents of the message on the value stack, and may push its own values to be sent in reply. The request callback may block if necessary (for example, the callback might wait for a hardware button press). Note, however, that Duktape will also be blocked while the callback executes which may not be desirable in some cases and may cause a debug client to time out (this of course depends entirely on the debug client).</p><p>This is a minimal do-nothing request callback:</p><pre><code>duk_idx_t duk_cb_debug_request(duk_context *ctx, void *udata, duk_idx_t nvalues) {
    /* Number of return values is returned: here empty reply. */
    return 0;
}
</code></pre><p>The above dummy callback simply responds with <code>REP EOM</code> (an empty reply) to all requests.</p><p>A more useful callback should process the values it receives on the value stack, push its own values to send in reply, and return a non-negative integer indicating how many values it pushed. Here is a slightly more useful implementation:</p><pre><code>duk_idx_t duk_cb_debug_request(duk_context *ctx, void *udata, duk_idx_t nvalues) {
    const char *cmd_name = NULL;

    /* Callback must be very careful NEVER to access values below
     * &#39;nvalues&#39; topmost value stack elements.
     */
    if (nvalues &gt;= 1) {
        /* Must access values relative to stack top. */
        cmd_name = duk_get_string(ctx, -nvalues + 0);
    }

    if (cmd_name == NULL) {
        /* Return -1 to send an ERR reply.  The value on top of the stack
         * should be a string which will be used for the error text sent
         * to the debug client.
         */
        duk_push_string(ctx, &quot;missing application specific command name&quot;);
        return -1;
    } else if (strcmp(cmd_name, &quot;VersionInfo&quot;) == 0) {
        /* Return a positive integer to send a REP containing values pushed
         * to the stack.  The return value indicates how many dvalues you
         * are including in the response.
         */
        duk_push_string(ctx, &quot;My Awesome Program&quot;);
        duk_push_int(ctx, 81200);  /* ver. 8.12.0 */
        return 2;  /* 2 dvalues */
    } else {
        duk_push_sprintf(ctx, &quot;unrecognized application specific command name: %s&quot;,
                         cmd_name);
        return -1;
    }
}
</code></pre><p>If no request callback is provided at attach, AppRequest will be treated as an unsupported command, eliciting an ERR reply from Duktape saying so. A target is always free to send AppNotify messages.</p><p>As a precaution, the target should try to avoid sending structured values such as JS objects in notify messages as their heap pointers may become stale by the time the client receives and inspects them. This is especially true for notifications sent while the target is running. It&#39;s better to stick to primitives which have unique dvalue representations, e.g. numbers, booleans, and strings. If a structured value does need to be sent, it can simply be e.g. JSON/JX encoded and sent as a string instead (carefully avoiding uncaught errors).</p><h3 id="important-notes-on-the-request-callback" tabindex="-1">Important notes on the request callback <a class="header-anchor" href="#important-notes-on-the-request-callback" aria-label="Permalink to &quot;Important notes on the request callback&quot;">​</a></h3><p>The request callback is provided with a <code>duk_context</code> pointer with which it can access the value stack and is assumed to be trusted. There are certain things it MUST NOT do. Specifically:</p><ul><li>It MUST NOT assume that <code>nvalues</code> has any specific value. In particular it might be zero so that there are no arguments to the callback (not even a string used, by convention, to identify an application specific command).</li><li>It MUST NOT attempt to access or pop any values from the top of the stack beyond the <code>nvalues</code> it is given and the values it pushes itself.</li><li>It MUST NOT assume any specific value for <code>duk_get_top()</code> and similar primitives. In practice this means using negative stack indices to access values.</li><li>It MUST NOT throw errors. It is very easy to accidentally throw an error when working with value stack values directly, so caution must be exercised here.</li></ul><p>Violating this contract is undefined behavior and may corrupt debugger state, cause incorrect behavior, or even lead to a segfault. In the future it would be nice to make this more robust, e.g. by sandboxing the function so that it cannot access unrelated stack values and is allowed to throw errors safely.</p><p>The dvalues of a message are pushed in the order they are received. This makes them inconvenient to access using negative indices, since the relative position of any given value on the stack is dependent on the total number of values. However because the callback receives the total number of values as a parameter, a useful convention is to index the stack like so:</p><pre><code>if (nvalues &lt; 3) {
    duk_push_string(ctx, &quot;not enough arguments&quot;);
    return -1;
}
cmd_name = duk_get_string(ctx, -nvalues + 0);
val_1 = duk_get_string(ctx, -nvalues + 1);
val_2 = duk_get_int(ctx, -nvalues + 2);
</code></pre><h3 id="apprequest-appnotify-command-format" tabindex="-1">AppRequest/AppNotify command format <a class="header-anchor" href="#apprequest-appnotify-command-format" aria-label="Permalink to &quot;AppRequest/AppNotify command format&quot;">​</a></h3><p>As a general convention, it is recommended for the first field in an AppRequest or AppNotify message after the command number be a string identifying the command, e.g. &quot;VersionInfo&quot; or &quot;RebootDevice&quot;. This makes it simpler for different clients and targets to interoperate. Unrecognized command names can simply be ignored, whereas, e.g. integer commands may be interpreted differently depending on the debug client and target in use.</p><p>If a command is specific to your application in some way (purpose or behavior), it might make sense to add a prefix, e.g. &quot;MyApp-AwesomeCmd&quot;. This avoids clashes with other targets which may have similarly-named commands.</p><p>Ultimately, no convention or overall form for application message contents is actually enforced by Duktape. A peer should therefore not make any assumptions about the contents of an AppRequest or AppNotify message unless it knows exactly where that message came from.</p><h2 id="heap-object-inspection" tabindex="-1">Heap object inspection <a class="header-anchor" href="#heap-object-inspection" aria-label="Permalink to &quot;Heap object inspection&quot;">​</a></h2><p>Artificial keys are subject to change between versions.</p><p>The following, however, have versioning guarantees:</p><ul><li><code>prototype</code>: internal prototype (not to be confused with a possible &quot;prototype&quot; property, which is the external prototype).</li><li><code>class_name</code>: string name for object class</li><li><code>class_number</code>: object class number, matches object dvalue</li></ul><h3 id="duktape-1-5-0" tabindex="-1">Duktape 1.5.0 <a class="header-anchor" href="#duktape-1-5-0" aria-label="Permalink to &quot;Duktape 1.5.0&quot;">​</a></h3><p>The following list describes artificial keys included in Duktape 1.5.0, see <code>src-input/duk_debugger.c</code> for up-to-date behavior:</p><hr><p>Artificial property Object type(s) Description key</p><hr><p><code>heaphdr_flags</code> <code>duk_heaphdr</code> Raw <code>duk_heaphdr</code> flags field; the (all) individual flags are also provided as separate artificial properties.</p><p><code>heaphdr_type</code> <code>duk_heaphdr</code> <code>duk_heaphdr</code> type field, (all) [\`DUK_HTYPE_xxx]{.title-ref}.</p><p><code>refcount</code> <code>duk_heaphdr</code> Reference count, omitted if no (all) refcount support.</p><p><code>extensible</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_EXTENSIBLE</p><p><code>constructable</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_CONSTRUCTABLE</p><p><code>callable</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_CALLABLE</p><p><code>bound</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_BOUND</p><p><code>compfunc</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_COMPFUNC</p><p><code>natfunc</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_NATFUNC</p><p><code>bufobj</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_BUFOBJ</p><p><code>fastrefs</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_FASTREFS</p><p><code>array_part</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_ARRAY_PART</p><p><code>strict</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_STRICT</p><p><code>notail</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_NOTAIL</p><p><code>newenv</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_NEWENV</p><p><code>namebinding</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_NAMEBINDING</p><p><code>createargs</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_CREATEARGS</p><p><code>have_finalizer</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_HAVE_FINALIZER</p><p><code>exotic_array</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_EXOTIC_ARRAY</p><p><code>exotic_stringobj</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ</p><p><code>exotic_arguments</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS</p><p><code>exotic_proxyobj</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ</p><p><code>special_call</code> <code>duk_hobject</code> DUK_HOBJECT_FLAG_SPECIAL_CALL</p><p><code>class_number</code> <code>duk_hobject</code> Duktape internal class number (same as object dvalue).</p><p><code>class_name</code> <code>duk_hobject</code> String class name, e.g. <code>&quot;ArrayBuffer&quot;</code>.</p><p><code>prototype</code> <code>duk_hobject</code> Points to the effective (internal) prototype and allows enumeration of inherited properties in client control.</p><p><code>props</code> <code>duk_hobject</code> Current property table allocation.</p><p><code>e_size</code> <code>duk_hobject</code> Entry part size.</p><p><code>e_next</code> <code>duk_hobject</code> Entry part next index (= used size).</p><p><code>a_size</code> <code>duk_hobject</code> Array part size.</p><p><code>h_size</code> <code>duk_hobject</code> Hash part size.</p><p><code>length</code> <code>duk_harray</code> Array .length.</p><p><code>length_nonwritable</code> <code>duk_harray</code> Array .length writable (false) or non-writable (true).</p><p><code>thread</code> <code>duk_hdecenv</code> Thread for open declarative environment.</p><p><code>varmap</code> <code>duk_hdecenv</code> Varmap for open declarative environment.</p><p><code>regbase</code> <code>duk_hdecenv</code> Regbase for open declarative environment.</p><p><code>target</code> <code>duk_hobjenv</code> Target object for object environment.</p><p><code>has_this</code> <code>duk_hobjenv</code> True if object environment provides a &#39;this&#39; binding.</p><p>(not present yet) <code>duk_hnatfunc</code> Native function pointer.</p><p><code>nargs</code> <code>duk_hnatfunc</code> Number of stack arguments.</p><p><code>magic</code> <code>duk_hnatfunc</code> Magic value.</p><p><code>varargs</code> <code>duk_hnatfunc</code> True if function has variable arguments.</p><p>(not present yet) <code>duk_hcompfunc</code> ECMAScript function data area, including bytecode.</p><p><code>lex_env</code> <code>duk_hcompfunc</code> Function lexical environment.</p><p><code>var_env</code> <code>duk_hcompfunc</code> Function variable environment.</p><p><code>nregs</code> <code>duk_hcompfunc</code> Number of bytecode executor registers.</p><p><code>nargs</code> <code>duk_hcompfunc</code> Number of stack arguments.</p><p><code>start_line</code> <code>duk_hcompfunc</code> First source code line.</p><p><code>end_line</code> <code>duk_hcompfunc</code> Last source code line.</p><p>(no properties yet) <code>duk_hthread</code> No thread properties yet.</p><p><code>buffer</code> <code>duk_hbufobj</code> Underlying plain buffer (provided as a heapptr).</p><p><code>slice_offset</code> <code>duk_hbufobj</code> Byte offset to underlying buffer for start of slice.</p><p><code>slice_length</code> <code>duk_hbufobj</code> Byte length of slice.</p><p><code>elem_shift</code> <code>duk_hbufobj</code> Shift value for element, e.g. Uint64 -&gt; 3.</p><p><code>elem_type</code> <code>duk_hbufobj</code> DUK_HBUFOBJ_ELEM_xxx</p><p><code>is_typedarray</code> <code>duk_hbufobj</code> True if bufferobject is a typed array (e.g. Uint8Array).</p><p><code>extdata</code> <code>duk_hstring</code> DUK_HSTRING_FLAG_EXTDATA</p><p><code>bytelen</code> <code>duk_hstring</code> Byte length of string.</p><p><code>charlen</code> <code>duk_hstring</code> Character length of string.</p><p><code>hash</code> <code>duk_hstring</code> String hash, algorithm depends on config options.</p><p><code>data</code> <code>duk_hstring</code> Plain string value.</p><p><code>dynamic</code> <code>duk_hbuffer</code> DUK_HBUFFER_FLAG_DYNAMIC</p><p><code>external</code> <code>duk_hbuffer</code> DUK_HBUFFER_FLAG_EXTERNAL</p><p><code>size</code> <code>duk_hbuffer</code> Byte size of buffer.</p><p><code>dataptr</code> <code>duk_hbuffer</code> Raw pointer to current data area.</p><h2 id="data-duk-hbuffer-buffer-data" tabindex="-1"><code>data</code> <code>duk_hbuffer</code> Buffer data. <a class="header-anchor" href="#data-duk-hbuffer-buffer-data" aria-label="Permalink to &quot;\`data\`                 \`duk_hbuffer\`     Buffer data.&quot;">​</a></h2><h3 id="currently-disabled" tabindex="-1">Currently disabled <a class="header-anchor" href="#currently-disabled" aria-label="Permalink to &quot;Currently disabled&quot;">​</a></h3><p>These are disabled (<code>if #0</code>&#39;d out) in code, and may be added back if useful:</p><hr><p>Artificial property key Object type(s) Description</p><hr><p><code>reachable</code> <code>duk_heaphdr</code> DUK_HEAPHDR_FLAG_REACHABLE (all)</p><p><code>temproot</code> <code>duk_heaphdr</code> DUK_HEAPHDR_FLAG_TEMPROOT (all)</p><p><code>finalizable</code> <code>duk_heaphdr</code> DUK_HEAPHDR_FLAG_FINALIZABLE (all)</p><p><code>finalized</code> <code>duk_heaphdr</code> DUK_HEAPHDR_FLAG_FINALIZED (all)</p><p><code>readonly</code> <code>duk_heaphdr</code> DUK_HEAPHDR_FLAG_READONLY (all)</p><p><code>arridx</code> <code>duk_hstring</code> DUK_HSTRING_FLAG_ARRIDX</p><p><code>symbol</code> <code>duk_hstring</code> DUK_HSTRING_FLAG_SYMBOL (DUK_HSTRING_FLAG_INTERNAL in Duktape 1.x)</p><p><code>hidden</code> <code>duk_hstring</code> DUK_HSTRING_FLAG_HIDDEN</p><p><code>reserved_word</code> <code>duk_hstring</code> DUK_HSTRING_FLAG_RESERVED_WORD</p><p><code>strict_reserved_word</code> <code>duk_hstring</code> DUK_HSTRING_FLAG_STRICT_RESERVED_WORD</p><h2 id="eval-or-arguments-duk-hstring-duk-hstring-flag-eval-or-arguments" tabindex="-1"><code>eval_or_arguments</code> <code>duk_hstring</code> DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS <a class="header-anchor" href="#eval-or-arguments-duk-hstring-duk-hstring-flag-eval-or-arguments" aria-label="Permalink to &quot;\`eval_or_arguments\`      \`duk_hstring\`    DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS&quot;">​</a></h2><h2 id="debugger-statement" tabindex="-1">&quot;debugger&quot; statement <a class="header-anchor" href="#debugger-statement" aria-label="Permalink to &quot;\\&quot;debugger\\&quot; statement&quot;">​</a></h2><p>ECMAScript has a debugger statement:</p><pre><code>a = 123;
debugger;
a = 234;
</code></pre><p>The E5 specification states that:</p><blockquote><p>Evaluating the DebuggerStatement production may allow an implementation to cause a breakpoint when run under a debugger. If a debugger is not present or active this statement has no observable effect.</p></blockquote><p>Other ECMAScript engines typically treat a debugger statement as a breakpoint:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ie/0bwt76sk%28v=vs.94%29.aspx" target="_blank" rel="noreferrer">http://msdn.microsoft.com/en-us/library/ie/0bwt76sk(v=vs.94).aspx</a></li><li><a href="http://blog.katworksgames.com/2012/09/27/debugger-statement-makes-javascript-development-easier/" target="_blank" rel="noreferrer">http://blog.katworksgames.com/2012/09/27/debugger-statement-makes-javascript-development-easier/</a></li></ul><p>Duktape interprets it as a breakpoint too, i.e. execution is paused if a debugger statement is encountered while a debug client is attached. This allows breakpoints to be set even in anonymous eval code (though there will be no access to source code).</p><h2 id="implementing-a-debug-transport-on-top-of-a-packet-based-transport" tabindex="-1">Implementing a debug transport on top of a packet-based transport <a class="header-anchor" href="#implementing-a-debug-transport-on-top-of-a-packet-based-transport" aria-label="Permalink to &quot;Implementing a debug transport on top of a packet-based transport&quot;">​</a></h2><p>Implementing a debug transport over a packet-based lower level protocol is essentially the same problem as forwarding a TCP stream or a virtual serial link over the packed-based protocol. There is very little Duktape specific in doing so, and the problem is quite well understood. This section provides some pointers.</p><h3 id="basic-issues" tabindex="-1">Basic issues <a class="header-anchor" href="#basic-issues" aria-label="Permalink to &quot;Basic issues&quot;">​</a></h3><ul><li>You&#39;ll need a mechanism to reliably send and receive arbitrary chunks of data with no reordering or duplication. This mechanism is needed both for the target and the debug client.</li><li>If buffering is an issue you may need to implement a flow control mechanism. Usually buffering is only an issue on the debug target, so one way flow control is usually enough.</li><li>To ensure data chunks sent by the debug target are reasonably sized, you may need to coalesce debug transport writes made by Duktape and use &quot;write flush&quot; to flush out pending bytes when no more data will be sent. Alternatively you could use a timer, similarly to what TCP does.</li></ul><p>If you also implement your own debug client you need to parse the debug stream from the data chunks received, e.g. with trial parsing:</p><ul><li>Read an incoming data chunk and append it to an input byte buffer.</li><li>Trial parse for debug messages until no more complete messages can be parsed. Then wait for next inbound data chunk.</li><li><strong>Because the boundaries of debug messages are not guaranteed to align with the read/write calls Duktape makes into the transport implementation, you should not try to match debug messages to the data chunks sent/received by your transport implementation!</strong></li></ul><h3 id="coalescing-writes-example" tabindex="-1">Coalescing writes example <a class="header-anchor" href="#coalescing-writes-example" aria-label="Permalink to &quot;Coalescing writes example&quot;">​</a></h3><ul><li>Maintain a buffer BUF of max N bytes for outbound writes.</li><li>For each Duktape transport write call: <ul><li>If the write data fits into BUF, append it. If not, append as many bytes as fit in the remaining BUF space (partial write).</li><li>If the buffer is now full (N bytes), send and empty the buffer.</li><li>Return value to Duktape indicates how many values were consumed, i.e. appended to BUF.</li></ul></li><li>For each Duktape transport write flush: <ul><li>If there are bytes in BUF, send and empty the buffer.</li><li>Note that you can rely on Duktape performing a write flush before it finishes writing and e.g. blocks on read or resumes execution. Write flushes may also happen at other times. <strong>Don&#39;t assign any other meaning to the flushes, e.g. a write flush is not guaranteed to match debug message boundaries!</strong></li></ul></li></ul><h3 id="one-way-flow-control-example" tabindex="-1">One-way flow control example <a class="header-anchor" href="#one-way-flow-control-example" aria-label="Permalink to &quot;One-way flow control example&quot;">​</a></h3><p>A simple one-way flow control mechanism to ensure a debug target can be implemented with a fixed inbound buffer of MAXBUF bytes (MAXBUF is something small like 256):</p><ul><li>The debug client maintains two byte counts: <ol><li>SENT indicates how many bytes have been sent since the start of the debug connection.</li><li>ACKED indicates how many bytes the debug target has confirmed to have consumed. SENT - ACKED is the number of bytes potentially in the target input buffer.</li></ol></li><li>The debug client then knows that the target can buffer at least MAXBUF - (SENT - ACKED) bytes, so that it&#39;s free to send that amount.</li><li>When the debug target receives data chunks from the debug client, it: <ul><li>Appends the data chunk to an inbound data buffer. There should always be space for the data if the debug client behaves correctly.</li></ul></li><li>When Duktape calls the debug transport read callback: <ul><li>Consume bytes from the inbound data buffer.</li><li>Send a transport specific notification to the debug client, updating the ACKED byte count (= number of bytes consumed by Duktape read calls).</li></ul></li></ul><p>Because Duktape performs a lot of small reads, it may be useful to:</p><ul><li>In the debug transport read callback: <ul><li>Don&#39;t send a notification for the updated ACKED byte count unless the change to a previously sent value is large enough.</li></ul></li><li>Rely on the debug transport &quot;read flush&quot; indication: <ul><li>When received, always send a notification for the updated ACKED byte count.</li></ul></li></ul><p>There are many other options too, for example, send an updated ACKED byte count when:</p><ul><li>Receiving bytes from the debug target.</li><li>When Duktape reads bytes, only send an updated ACKED byte count when the read is made from a completely full input buffer (i.e., the debug client is currently not sending any data until we notify it we have space).</li></ul><h2 id="implementation-notes" tabindex="-1">Implementation notes <a class="header-anchor" href="#implementation-notes" aria-label="Permalink to &quot;Implementation notes&quot;">​</a></h2><h3 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h3><p>This section contains some implementation notes on the Duktape internals.</p><p>Duktape debugger support is optional and enabled with a config option. The bytecode executor interrupt feature is also mandatory when debugger support is enabled.</p><h3 id="source-files" tabindex="-1">Source files <a class="header-anchor" href="#source-files" aria-label="Permalink to &quot;Source files&quot;">​</a></h3><p>The debugger support is implemented almost entirely in the following files:</p><ul><li><code>duk_js_executor.c</code>: checked execution, breakpoints, step into/over, interfacing with debugger message loop</li><li><code>duk_hthread_stacks.c</code>: step out handling</li><li><code>duk_debugger.c</code>: debug transport, debug command handling</li><li><code>duk_api_debug.c</code>: debugger API entrypoints</li></ul><h3 id="attaching-and-detaching-a-debugger-to-a-heap" tabindex="-1">Attaching and detaching a debugger to a heap <a class="header-anchor" href="#attaching-and-detaching-a-debugger-to-a-heap" aria-label="Permalink to &quot;Attaching and detaching a debugger to a heap&quot;">​</a></h3><p>When user code attaches a debugger using <code>duk_debugger_attach()</code>, Duktape updates the <code>duk_heap</code> state to reflect that a debugger is attached, store the callbacks etc.</p><p>The debugger operates on a Duktape heap level, as other options seem to lead to confusing outcomes. For instance, if a debugger were attached to a single thread breakpoints would only be triggered by that thread. Even so, when a breakpoint was triggered, the whole heap would be paused because there&#39;s no way to pause a single thread and resume execution of others.</p><h3 id="execution-modes-executor-interrupt-and-restart-execution" tabindex="-1">Execution modes, executor interrupt, and &quot;restart_execution&quot; <a class="header-anchor" href="#execution-modes-executor-interrupt-and-restart-execution" aria-label="Permalink to &quot;Execution modes, executor interrupt, and \\&quot;restart_execution\\&quot;&quot;">​</a></h3><p>Perhaps the most critical capability needed to implement a debugger is to have an efficient way of detecting active breakpoints, trigger on a breakpoint, and implement stepped execution. These are implemented in the Duktape bytecode executor as follows.</p><p>Debugger support relies on the executor interrupt feature, which provides the ability to interrupt bytecode execution periodically or after every bytecode instruction. This mechanism is used to implement three conceptual modes of execution:</p><ul><li><strong>Normal</strong>: bytecode executor executes at full speed, calling into the executor interrupt once in a while. When in the interrupt, we peek for debug client messages (this allows an out-of-the-blue pause for instance), execution timeout etc.</li><li><strong>Checked</strong>: bytecode executor executes opcodes one at a time, calling into the executor interrupt before every instruction. The interrupt detects line transitions, checks if any breakpoints or stepping related conditions are triggered, and peeks (but doesn&#39;t block waiting) for debug client messages.</li><li><strong>Paused</strong>: bytecode executor calls into executor interrupt, and the executor interrupt processes debug client messages until the debug client issues some control flow related command like step over/into/out or resume. Execution is under complete control of the debug client.</li></ul><p>The &quot;paused&quot; mode is concretely implemented in the executor interrupt simply by processing debug messages until some kind of resume/detach command is encountered.</p><p>The &quot;checked&quot; mode is implemented by careful management of the interrupt counter. This is important so that no additional checks are introduced into the executor fast path: only a single interrupt counter check is needed. When execution is restarted, the need for checked execution is detected (e.g. there are active breakpoints or stepping is active) and the interrupt counter is configured to trigger an interrupt before any opcodes are executed. If we need to remain in checked mode, the interrupt handler will again configure the interrupt counter to ensure only one opcode is executed before again returning to the interrupt handler.</p><p>The &quot;normal&quot; execution mode is similar but the interrupt counter is configured into a higher value (e.g. interrupt every hundred thousand opcodes) when returning to the bytecode executor.</p><p>The <code>restart_execution:</code> label in the bytecode executor is an important control point. It is called whenever the bytecode executor is about to start executing a new activation, but can also be called explicitly e.g. when debug commands have adjusted breakpoint state. The &quot;restart execution&quot; operation does a lot of important things:</p><ul><li>It checks for debugger attached/detached state. If detached, all other debugger related checks are skipped.</li><li>It checks for active breakpoints in the current function, and writes out the active breakpoint list to make breakpoint trigger checks faster in the executor interrupt.</li><li>It checks for active stepping state. Both step into and step over require some handling.</li><li>It checks for paused state too. In some cases a &quot;paused&quot; flag can be set outside the bytecode executor. For example, when doing a &quot;step out&quot;, the callstack unwinding code sets a &quot;paused&quot; flag when unwinding the activation we&#39;re stepping out of. We detect this only when &quot;restart execution&quot; is called the next time.</li><li>Ultimately, it decides whether execution should proceed in checked mode or normal mode.</li></ul><p>After execution proceeds normally, with the help of the executor interrupt mechanism and the interrupt handler. The execution mode can only changed by the interrupt handler (e.g. if it starts setting the interrupt counter to a higher value) or if &quot;restart_execution&quot; is invoked again.</p><p>From the bytecode executor perspective the integration is quite simple:</p><ul><li>&quot;restart_execution&quot; does a lot of debugger processing as part of setting up execution.</li><li>The interrupt counter mechanism is used to call into the interrupt handler, and the actual opcode executor doesn&#39;t have to worry about the rest.</li></ul><h3 id="stepping-and-pausing" tabindex="-1">Stepping and pausing <a class="header-anchor" href="#stepping-and-pausing" aria-label="Permalink to &quot;Stepping and pausing&quot;">​</a></h3><p>The following internal heap level state is needed:</p><ul><li>Pause state: heap wide flag indicating we need to talk with the debug client until it gives us as a permission to continue.</li><li>Step state: heap wide, tracks currently active &quot;step into&quot;, &quot;step over&quot;, or &quot;step out&quot; state.</li></ul><p>The step state is rather tricky:</p><ul><li><p>Step over: track the original thread, activation index, and starting line. Execute in checked mode until starting line has changed; then pause. If we call into other functions, the state is kept and we&#39;ll pause once we return and the line number has changed.</p></li><li><p>Step into: track the original thread, activation index, and starting line. Execute in checked mode until starting line has changed. If we call into another function, we need to pause when entering it.</p></li><li><p>Step out: track the original thread and activation index (starting line does not matter). Execute in normal mode (unless there are breakpoints, of course). If the activation is unwound for any reason, enter paused mode. This means that if an error is thrown, we resume execution in the catcher. Step out handling is concretely implemented as part of callstack unwinding, which differs completely from how other step commands are implemented.</p><p>A coroutine yield does not trigger a &quot;step out&quot; because the callstack is not unwound.</p></li></ul><p>Step over/into state is checked in executor &quot;restart execution&quot; operation.</p><h3 id="breakpoints" tabindex="-1">Breakpoints <a class="header-anchor" href="#breakpoints" aria-label="Permalink to &quot;Breakpoints&quot;">​</a></h3><p>Breakpoints are maintained as a heap level file/line list. When the bytecode executor does a &quot;restart execution&quot; operation it rechecks the breakpoint list and figures out which breakpoints are active; the active breakpoint list is recorded into the heap state too. Whenever breakpoint state may have changed, e.g. as a result of executing debug commands, the bytecode executor must go through a &quot;restart execution&quot; operation so that breakpoints are properly re-checked and activated.</p><p>If there are one or more active breakpoints, execution resumes in checked mode. If no breakpoints are active (and there&#39;s no other reason to be in checked mode) execution resumes in normal mode. This is important to maximize execution performance when breakpoints are active but outside the currently executing function.</p><p>One key problem in figuring out the active breakpoints is how to handle inner functions. This is covered in a separate section below.</p><p>Breakpoints are handled directly by Duktape to make them reasonably efficient. Another design alternative would be to have an API or a protocol mechanism for stepped execution so that user code could implement breakpoints on its own. This would be more flexible than an integrated breakpoint mechanism, but also much slower.</p><p>There are many design alternatives to defining a breakpoint using a file/line pair. The current file/line approach is intuitive but means that:</p><ul><li>There&#39;s no way to break in the middle of a single line, e.g. for one-line functions. This also affects minified ECMAScript code.</li><li>There are potentially multiple ECMAScript function instance (i.e. <code>duk_hcompfunc</code> objects) that have been created from the same spot. The breakpoint will match all of them.</li></ul><h3 id="line-transitions" tabindex="-1">Line transitions <a class="header-anchor" href="#line-transitions" aria-label="Permalink to &quot;Line transitions&quot;">​</a></h3><p>It might seem at first that a line-to-PC conversion primitive would be needed so that a line number could be translated into a PC for an active breakpoint. However, such an approach doesn&#39;t really work, for several reasons, discussed below.</p><p>Multiple instructions can be generated from a single line so that there are several instructions with the same line number in the typical case. The opcodes mapping to a certain line number can also be scattered around the code (not necessarily in a linear or localized fashion), e.g. for flow control constructs. Something like the following is entirely possible, and normal:</p><pre><code>PC      Line
--      ----

50      98
51      99
52      100   &lt;--
53      100   &lt;--
54      100   &lt;--
55      100   &lt;--
56      102
57      103
58      103
59      104
60      105
61      100   &lt;--
</code></pre><p>There may also be several PCs which are &quot;entry points&quot; for a certain line number. This happens with e.g. loop constructs.</p><p>A breakpoint may also be targeted on a line number which doesn&#39;t have any matching bytecode instructions. This can happen trivially when a breakpoint is assigned to an empty line, but can also happen non-trivially when the line numbers in the generated bytecode are off by one or otherwise unintuitive. The expected behavior is often for the breakpoint to match when we transition to the breakpoint line <em>or</em> over it. There are several difficulties in using this breakpoint rule however:</p><ul><li>There are potentially multiple &quot;next lines&quot; or &quot;next opcodes&quot;. Consider a breakpoint on an empty line in the middle of a switch statement.</li><li>Using <code>(prev_line &lt; break_line) AND (curr_line &gt;= break_line)</code> as the rule to trigger a breakpoint works for the most part, but causes some unintuitive breakpoint behavior, especially when a breakpoint is in a conditional code block which is skipped but not executed. See discussion in: <a href="https://github.com/svaarala/duktape/issues/263" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/issues/263</a>. (Duktape 1.2.x used this breakpoint rule; the rule was changed in Duktape 1.3.x.)</li></ul><p>The current rule (Duktape 1.3.x) for breakpoint triggering is:</p><pre><code>(prev_line != break_line) AND (curr_line == break_line)
</code></pre><p>In other words, a breakpoint is triggered when we transition to the exact breakpoint line. See discussion in <a href="https://github.com/svaarala/duktape/issues/263" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/issues/263</a>.</p><p>Implementing breakpoints in terms of line transitions (instead of e.g. PC values) also solves another related issue: once we hit a breakpoint on a certain line, how to implement &quot;step into&quot; / &quot;step over&quot;? Stepping away from the breakpoint line means we need to execute bytecode instructions until current line changes to a value different than the breakpoint line. Note that this is not necessarily the next line or even a higher line number because control flow can maka a jump backwards.</p><p>So, right now Duktape implements breakpoints as follows:</p><ul><li>When one or more breakpoints is active, the bytecode executor enters checked execution. In checked execution the bytecode interrupt mechanism is invoked before every opcode. Checked execution is carefully avoided when at all possible, to ensure breakpoints don&#39;t slow down performance when they don&#39;t need to.</li><li>The interrupt mechanism tracks line information (previous line, current line) so that it can detect line transitions. This means Duktape will do a pc-to-line for every opcode executed. This is currently not optimized and will consult the pc-to-line bitstream every time; see future work for notes on how this can be improved in the future.</li><li>Breakpoints and stepping are checked when a line transition occurs, i.e. when <code>prev_line != curr_line</code>.</li></ul><h3 id="inner-functions-and-breakpoints" tabindex="-1">Inner functions and breakpoints <a class="header-anchor" href="#inner-functions-and-breakpoints" aria-label="Permalink to &quot;Inner functions and breakpoints&quot;">​</a></h3><p>A breakpoint should only be active in the innermost function in the source code. Consider for example:</p><pre><code>1  function foo() {
2      print(&#39;foo 1&#39;);
3      function bar() {
4          print(&#39;bar 1&#39;);
5      }
6      print(&#39;foo 2&#39;);
7      bar();
8  }
9  foo();
</code></pre><p>Suppose execution was currently at line 2, and a breakpoint was added for line 4. What happens when you single step?</p><p>In a naive implementation the executor considers the line 4 breakpoint to be active for the foo() activation, and when it detects a line transition from line 2 to line 6, the breakpoint is triggered. Execution stops at line 6 before printing &quot;foo 2&quot;.</p><p>To avoid this, a breakpoint is always associated (only) with the innermost function where it appears. This can be quickly detected by tracking the line range (smallest and largest line number) for each function. One can then determine active breakpoints for a function FUNC as follows:</p><ul><li>If breakpoint has a different filename, reject.</li><li>If breakpoint has line number is outside FUNC line range, reject. (For foo() line range would be 1-8 and for bar() line range would be 3-5.)</li><li>Loop through all inner functions IFUNC of FUNC: <ul><li>If breakpoint line number is inside IFUNC, reject. IFUNC is considered to &quot;capture&quot; the breakpoint.</li></ul></li><li>Accept breakpoint as active for FUNC execution.</li></ul><h3 id="pc-and-line-number-handling" tabindex="-1">PC and line number handling <a class="header-anchor" href="#pc-and-line-number-handling" aria-label="Permalink to &quot;PC and line number handling&quot;">​</a></h3><p>In internal book-keeping the PC field of a <code>duk_activation</code> refers to the next instruction to execute. This PC is not always the correct one to report. Conceptually the previous instruction (PC-1) is sometimes still being executed while sometimes we&#39;re in the middle of two opcodes, having finished execution of PC-1.</p><p>The correct PC to use depends on context. For example:</p><ul><li>In stack traces PC-1 is used for all callstack levels. For activations below the callstack top PC-1 is the instruction still being executed (it is the call instruction). For callstack top PC-1 is the &quot;offending&quot; instruction.</li><li>For debugger Status notification PC is used because we&#39;ve conceptually completed PC-1 and are about to execute PC. Breakpoints also trigger at PC <em>before</em> the opcode at PC is executed. In a debugger UI this means that the line highlighted is the next line to execute, and hasn&#39;t been executed yet.</li><li>For debugger GetCallStack PC-1 is used for all callstack levels below the callstack top: as for stack traces, these call instructions are still being executed. However, for callstack top PC is used to match Status, so that the line reported indicates what line will be executed next.</li></ul><p>See: <a href="https://github.com/svaarala/duktape/issues/281" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/issues/281</a>.</p><h3 id="avoid-nested-message-writing" tabindex="-1">Avoid nested message writing <a class="header-anchor" href="#avoid-nested-message-writing" aria-label="Permalink to &quot;Avoid nested message writing&quot;">​</a></h3><p>Consider the following scenario:</p><ul><li>Debug client requests for local variable names and values using a hypothetical GetLocalVarsAndValues request.</li><li>Duktape starts processing the request, streaming out a REP marker, followed by variable names and values.</li><li>One of the variable values is a getter, and the request handler just uses a naive read to get the variable value, so that the getter is invoked.</li><li>The getter calls <code>print()</code> which gets forwarded to the debug client. The <code>print()</code> handler writes a notification message containing the print data.</li><li>This notification ends up in the middle of the GetLocalVarsAndValues response, corrupting the debug stream.</li></ul><p>Such nested debug messages must be avoided at all times. Some ways to achieve this:</p><ul><li>If the debug command only deals with a single value (and not a list of values), read and coerce any values into safe form before streaming out the response.</li><li>As a general rule favor side effect free debug commands, e.g. read values without invoking getters.</li><li>For unsafe primitives that may have side effects, favor debug commands that just handle a single value (instead of an arbitrarily long list of values). Such a primitive is easier to implement safely because it doesn&#39;t need to buffer a potentially unlimited list of safely obtained values before starting to write out the response.</li><li>As a concrete example, the GetLocalVarsAndValues could be fixed either by: a. Changing it so that it doesn&#39;t invoke accessors. b. Changing it to return only a list of variable names, and adding a separate primitive to get the local variable value (GetLocalVar). This primitive can invoke getters, but it must do so before it starts to stream out the response. Note that request pipelining allows local variables to read in two round trips: first read the variable names, then issue reads for every variable name in a big set of pipelined requests.</li></ul><p>This issue affects various things here and there:</p><ul><li>If GC is invoked, it might be tempting to emit a GC notification from inside mark-and-sweep code. This would be very unsafe because GC can easily be invoked by any operation involving the value stack.</li></ul><h2 id="design-goals" tabindex="-1">Design goals <a class="header-anchor" href="#design-goals" aria-label="Permalink to &quot;Design goals&quot;">​</a></h2><p>This section provides some notes on goals behind the debugger design (this is not a comprehensive list).</p><h3 id="quick-integration-with-a-custom-target" tabindex="-1">Quick integration with a custom target <a class="header-anchor" href="#quick-integration-with-a-custom-target" aria-label="Permalink to &quot;Quick integration with a custom target&quot;">​</a></h3><p>It should be possible integrate debugging support into a custom target very quickly, e.g. in one day.</p><ul><li>This should be achievable with the current solution. One needs to implement a custom transport into both the target device and duk_debug.js and can then use the debugger web UI to debug the target.</li></ul><h3 id="minimize-fragmentation-of-debug-solutions" tabindex="-1">Minimize fragmentation of debug solutions <a class="header-anchor" href="#minimize-fragmentation-of-debug-solutions" aria-label="Permalink to &quot;Minimize fragmentation of debug solutions&quot;">​</a></h3><p>The debugger architecture should ensure that improvements for Duktape debugging capabilities are shared between users. Ideally debug clients developed for different environments could be mixed and matched.</p><ul><li>This is the main reason why a debug protocol is used as the basis of the design instead of a debug API. A debug API would mean every user would need to define their own debug protocol, which would fragment both the debug protocol and, as a consequence, the debug clients.</li><li>This goal is achieved to a large extent: any debug client should be able to talk with any target. However, there may be need to adapt a transport mechanism so it&#39;s not completely automatic.</li></ul><h3 id="transport-neutrality" tabindex="-1">Transport neutrality <a class="header-anchor" href="#transport-neutrality" aria-label="Permalink to &quot;Transport neutrality&quot;">​</a></h3><p>The debug protocol should be transport neutral to support embedding in very different environments and communication links (Wi-Fi, Bluetooth, serial, etc).</p><ul><li>Concrete solution is to use assume a reliable (TCP-like) byte stream, with user code providing the concrete transport.</li></ul><h3 id="transport-bandwidth" tabindex="-1">Transport bandwidth <a class="header-anchor" href="#transport-bandwidth" aria-label="Permalink to &quot;Transport bandwidth&quot;">​</a></h3><p>The debugger must work with slow transports, e.g. slow serial links.</p><ul><li>This is the reason a binary protocol is used: it&#39;s reasonably compact with no compression. Compression is a possible solution but it is not preferable for very low memory devices (memory overhead).</li></ul><p>The debugger must work with high latency transports (hundreds of milliseconds).</p><ul><li>This is the reason why request pipelining is used: pipelining allows multiple commands to be sent, reducing blocking round trip waits.</li><li>Pipelining allows debug commands to be built from small, simple operations with minimal additional latency (compared to a synchronous request/reply model).</li></ul><h3 id="human-readable-protocol" tabindex="-1">Human readable protocol <a class="header-anchor" href="#human-readable-protocol" aria-label="Permalink to &quot;Human readable protocol&quot;">​</a></h3><p>It would be nice for the protocol to be human readable, e.g. plain text.</p><ul><li>This is currently not achieved as the debug protocol is binary.</li><li>A binary protocol is used at the moment because it is more compact and has a smaller code footprint than parsing a text-based protocol. Note that such parsing would need to be done without GC impact or other side effects so existing ECMAScript mechanisms (like number parsing) cannot necessarily be used as is.</li></ul><h3 id="code-footprint" tabindex="-1">Code footprint <a class="header-anchor" href="#code-footprint" aria-label="Permalink to &quot;Code footprint&quot;">​</a></h3><p>Debugger support should be optional because it has a significant footprint.</p><p>It should be possible to enable debugger support even for very low memory devices (e.g. 256kB flash).</p><ul><li>At the moment the additional code footprint for debugger support is around 15-20 kB.</li></ul><h3 id="memory-ram-footprint-and-minimal-churn" tabindex="-1">Memory (RAM) footprint and minimal churn <a class="header-anchor" href="#memory-ram-footprint-and-minimal-churn" aria-label="Permalink to &quot;Memory (RAM) footprint and minimal churn&quot;">​</a></h3><p>The debugger implementation should consume a minimal amount of RAM on top of what the debug commands themselves need.</p><ul><li>Fixed allocations are preferable to variable allocations for low memory devices.</li></ul><p>Debugger commands should avoid disturbing Duktape internal state. For instance, if a debug command requested a dump of the Duktape heap, the command should cause no changes to the heap during serialization of the response. Concretely this means that:</p><ul><li>It must be possible to read and write debug messages without doing any memory allocations that can cause a GC. This rules out, among other things, pushing values on the value stack and interning strings. Memory allocations can be done using raw calls to allocation callbacks, but it&#39;s be preferable to be able to avoid memory allocations altogether.</li><li>Note that it is <em>not</em> a requirement that all debug commands be implemented without side effects. For instance, reading a variable may invoke a getter or use some internal mechanisms with side effects. The goal is simply that it should be <em>possible</em> to write some debug commands that are side effect free if that is necessary.</li></ul><p>Large and variable sized buffers for parsing inbound messages or constructing outbound messages should be avoided. These would be very problematic on low memory devices.</p><ul><li>This goal is an important reason why the debug protocol uses a stream transport. A stream transport allows e.g. the whole heap to be serialized with no variable sized output buffering: values are simply streamed out during the heap walk with a fixed streaming buffers.</li><li>This goal is also one reason why the debug protocol is binary instead of e.g. JSON: JSON parsing would introduce significant memory churn if the current parser were used. Adding a separate parser for debugging would be wasteful.</li></ul><h3 id="performance" tabindex="-1">Performance <a class="header-anchor" href="#performance" aria-label="Permalink to &quot;Performance&quot;">​</a></h3><p>When a debugger is not attached (but debugger support is compiled in), performance should be as close to normal as possible.</p><p>When a debugger is attached but there are no active breakpoints, performance should be as close to normal as possible.</p><p>Performance with active breakpoints is not critical, but still matters on slow targets so that timing sensitive applications have a chance of working properly when debugged.</p><h2 id="miscellaneous-design-notes" tabindex="-1">Miscellaneous design notes <a class="header-anchor" href="#miscellaneous-design-notes" aria-label="Permalink to &quot;Miscellaneous design notes&quot;">​</a></h2><p>Some design notes on miscellaneous issues, rejected alternatives, etc.</p><h3 id="debug-commands-instead-of-debug-api" tabindex="-1">Debug commands instead of debug API <a class="header-anchor" href="#debug-commands-instead-of-debug-api" aria-label="Permalink to &quot;Debug commands instead of debug API&quot;">​</a></h3><p>Instead of a debug protocol Duktape could provide a set of API primitives to allow user code to implement a debugger on its own. This would have several downsides:</p><ul><li>There would need to be a lot of new public API primitives with deep access to Duktape internals. Such an API would be a major maintenance issue going forwards: when Duktape internals change, there would still be old API promises to keep. A debug protocol can hide the internal details more effectively.</li><li>Every user application with a need for debugging would need to implement their own debug protocol: there would be no standard debug commands, just raw API calls which can be used to implement a debugger. Every Duktape debugger integration would be different.</li></ul><h3 id="impact-of-being-an-embeddable-interpreter" tabindex="-1">Impact of being an embeddable interpreter <a class="header-anchor" href="#impact-of-being-an-embeddable-interpreter" aria-label="Permalink to &quot;Impact of being an embeddable interpreter&quot;">​</a></h3><p>Embedded model means there is no standard launch like there is for a JVM for instance. The debugger needs to connect to a running instance, and the launching of the instance is up to the user. There may also not be easy access to source code: the way it is loaded is up to the user, and some of the source code is given from C code, perhaps programmatically.</p><p>It&#39;s up to the application to decide when the debugger is attached. For instance, a debugger may attached on startup (some kind of &quot;reboot and debug&quot; mode) or only when debugger is attached at runtime.</p><h3 id="packet-based-protocol" tabindex="-1">Packet based protocol <a class="header-anchor" href="#packet-based-protocol" aria-label="Permalink to &quot;Packet based protocol&quot;">​</a></h3><p>The debug transport could be based on delimited debug packets. Both V8 and Spidermonkey debug protocols are (JSON) packet based.</p><p>In a packet based protocol an inbound message needs to reside in memory to be processed. Similarly outbound messages are formed as full packets before being sent. This works poorly with low memory devices because it is difficult to limit the maximum debug packet size:</p><ul><li>For example, even if a debug packet only contained a single string (perhaps an eval result), the size of the string may vary widely. If debug packets have an upper size limit, it&#39;s quite easy to get into a situation where values that easily fit into memory cannot be sent over the debug protocol</li><li>One can alleviate this problem by doing fragmented reads, i.e. the debug protocol allows the debug client to read in a string in chunks. This has string life cycle issues, and such a fragmentation protocol is in fact emulating a stream transport in a crude way.</li><li>A similar approach is needed for serializing object values, and potentially many other debug commands, which is very awkward from a protocol design perspective.</li></ul><h3 id="stream-protocol-without-request-response-framing" tabindex="-1">Stream protocol without request/response framing <a class="header-anchor" href="#stream-protocol-without-request-response-framing" aria-label="Permalink to &quot;Stream protocol without request/response framing&quot;">​</a></h3><p>The debug protocol could also be a stream protocol with no request/response framing. This works poorly when either party may initiate messages without lock step. For example, if debug client sends a request and the target sends a notification, how can the debug client know that the bytes it receives are not a response but an unrelated notification?</p><p>Some framing is needed to at least separate responses from other messages.</p><h3 id="pipelining-vs-asynchronous-messages" tabindex="-1">Pipelining vs. asynchronous messages <a class="header-anchor" href="#pipelining-vs-asynchronous-messages" aria-label="Permalink to &quot;Pipelining vs. asynchronous messages&quot;">​</a></h3><p>The current design is to allow pipelining of requests: each request has a single reply (or error) and requests are never reordered. There is no need for request/reply identifiers in this model.</p><p>Another design would be to allow each party to send responses to incoming commands in an arbitrary order (asynchronously). This would be useful if some operations took a long time and could be handled in the background while more urgent operations could be processed in the meantime.</p><p>In practice this is difficult to implement especially on the debug target, and would require more state tracking. It would also make it more difficult to send multiple requests (compared to pipelining) because there would be no guarantee of their completion order.</p><h3 id="untyped-debug-message-encoding" tabindex="-1">Untyped debug message encoding <a class="header-anchor" href="#untyped-debug-message-encoding" aria-label="Permalink to &quot;Untyped debug message encoding&quot;">​</a></h3><p>One alternative tried was to use untyped encoding for debug messages, i.e. debug client and target both know what exact data messages are intended to have, so there is no need to tag a value e.g. as an integer or a string.</p><p>This would be efficient but difficult to extend in a compatible fashion. Instead, the debug protocol would need hard versioning for every minor change and the debug client would need to support all protocol variants. This is not necessarily a showstopper though as the debug client will need to have version awareness anyway.</p><h3 id="variable-size-integer-encoding" tabindex="-1">Variable size integer encoding <a class="header-anchor" href="#variable-size-integer-encoding" aria-label="Permalink to &quot;Variable size integer encoding&quot;">​</a></h3><p>The debug protocol exchanges a lot of small and large integers. The extended UTF-8 encoding was used first which is consistent with other variable length integer encoding in Duktape.</p><p>However, when the current tag initial byte (IB) was added, it became very natural to use the tag byte to encode small integers and to encode the byte length of larger integers. This representation is actually quite similar to CBOR: <a href="https://tools.ietf.org/html/rfc7049" target="_blank" rel="noreferrer">https://tools.ietf.org/html/rfc7049</a>.</p><h3 id="accessors-and-proxies-vs-variable-get-set" tabindex="-1">Accessors and proxies vs. variable get/set <a class="header-anchor" href="#accessors-and-proxies-vs-variable-get-set" aria-label="Permalink to &quot;Accessors and proxies vs. variable get/set&quot;">​</a></h3><ul><li>Triggering setters / getters may not be desirable.</li><li>Perhaps return value like Object.getOwnPropertyDescriptor(), and allow debug client to invoke the getter if necessary? (Heap walking provides a similar feature now.)</li><li>Access proxy and target separately?</li></ul><h2 id="other-debugger-implementations" tabindex="-1">Other debugger implementations <a class="header-anchor" href="#other-debugger-implementations" aria-label="Permalink to &quot;Other debugger implementations&quot;">​</a></h2><h3 id="overview-1" tabindex="-1">Overview <a class="header-anchor" href="#overview-1" aria-label="Permalink to &quot;Overview&quot;">​</a></h3><p>Both V8 and Spidermonkey use a packet based debug protocol with much of the protocol formatted in JSON. Although this is quite an intuitive approach, Duktape uses a stream based binary protocol to avoid the memory churn related to using JSON, and to better support very low memory devices where forming complete debug messages in memory would be problematic.</p><h3 id="chrome-v8" tabindex="-1">Chrome/V8 <a class="header-anchor" href="#chrome-v8" aria-label="Permalink to &quot;Chrome/V8&quot;">​</a></h3><p>Chrome/V8 uses a packet based debug protocol where each packet is a JSON message:</p><ul><li><a href="https://code.google.com/p/v8-wiki/wiki/DebuggerProtocol" target="_blank" rel="noreferrer">https://code.google.com/p/v8-wiki/wiki/DebuggerProtocol</a></li></ul><p>Also see:</p><ul><li><a href="https://code.google.com/p/chromedevtools/wiki/ChromeDevToolsProtocol" target="_blank" rel="noreferrer">https://code.google.com/p/chromedevtools/wiki/ChromeDevToolsProtocol</a></li><li><a href="https://developer.chrome.com/devtools/docs/javascript-debugging" target="_blank" rel="noreferrer">https://developer.chrome.com/devtools/docs/javascript-debugging</a></li></ul><h3 id="firefox" tabindex="-1">Firefox <a class="header-anchor" href="#firefox" aria-label="Permalink to &quot;Firefox&quot;">​</a></h3><p>Mozilla uses a packet based debug protocol where packets are either JSON or binary blobs. It can be mapped to a stream:</p><ul><li><a href="https://wiki.mozilla.org/Remote_Debugging_Protocol_Stream_Transport" target="_blank" rel="noreferrer">https://wiki.mozilla.org/Remote_Debugging_Protocol_Stream_Transport</a></li></ul><p>Also see:</p><ul><li><a href="https://developer.mozilla.org/en/docs/Debugging_JavaScript" target="_blank" rel="noreferrer">https://developer.mozilla.org/en/docs/Debugging_JavaScript</a></li></ul><h3 id="eclipse" tabindex="-1">Eclipse <a class="header-anchor" href="#eclipse" aria-label="Permalink to &quot;Eclipse&quot;">​</a></h3><p>An Eclipse debugger could be implemented using the Duktape debugger protocol. Some resources for that:</p><ul><li><a href="http://www.eclipse.org/articles/Article-Launch-Framework/launch.html" target="_blank" rel="noreferrer">http://www.eclipse.org/articles/Article-Launch-Framework/launch.html</a></li><li><a href="http://www.eclipse.org/articles/Article-Debugger/how-to.html" target="_blank" rel="noreferrer">http://www.eclipse.org/articles/Article-Debugger/how-to.html</a></li></ul><h2 id="known-issues" tabindex="-1">Known issues <a class="header-anchor" href="#known-issues" aria-label="Permalink to &quot;Known issues&quot;">​</a></h2><h3 id="valgrind-uninitialized-byte-s-warning" tabindex="-1">Valgrind uninitialized byte(s) warning <a class="header-anchor" href="#valgrind-uninitialized-byte-s-warning" aria-label="Permalink to &quot;Valgrind uninitialized byte(s) warning&quot;">​</a></h3><p>You may get the following when doing a DumpHeap:</p><pre><code>==17318== Syscall param write(buf) points to uninitialised byte(s)
==17318==    at 0x5466700: __write_nocancel (syscall-template.S:81)
==17318==    by 0x427ADA: duk_trans_socket_write_cb (duk_trans_socket_unix.c:237)
==17318==    by 0x403538: duk_debug_write_bytes.isra.11 (duk_debugger.c:379)
==17318==    by 0x4036AC: duk_debug_write_strbuf (duk_debugger.c:463)
[...]
</code></pre><p>When unpacked duk_tval is in use, all bytes of a duk_tval are not necessarily set when a certain value is written into the duk_tval. This is not a safety issue because Duktape won&#39;t read or use the uninitialized bytes in ordinary situations. However, the uninitialized bytes in the &#39;data&#39; area of a compiled function will be written out by DumpHeap as is, causing the above (harmless) valgrind gripe.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="error-handling" tabindex="-1">Error handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error handling&quot;">​</a></h3><p>Add error handling wrappers to debug code. For instance, if we run out of memory, detach automatically as a recovery measure?</p><p>Currently unsafe behavior may be triggered by internal errors (e.g. out of memory) or, for instance, a getter error triggered by GetVar.</p><h3 id="fast-pc-to-line-for-checked-execution" tabindex="-1">Fast pc-to-line for checked execution <a class="header-anchor" href="#fast-pc-to-line-for-checked-execution" aria-label="Permalink to &quot;Fast pc-to-line for checked execution&quot;">​</a></h3><p>During checked execution we need to figure out the line number for the current PC so that line transitions can be tracked accurately. Right now the pc-to-line bitstream is consulted statelessly each time, which is slow (but only affects checked execution, i.e. when there&#39;s an active breakpoint for the current function).</p><p>There are several ways to make this faster:</p><ul><li>Cache the pc-to-line conversion state. If the PC increases by one, we can almost always just decode a single line delta from the bitstream which is very efficient and requires no data format changes.</li><li>When entering checked execution, create an unpacked pc-to-line array so that lookups can be done as simple array lookups.</li><li>When debugging is enabled, store pc-to-line conversion information as a plain array in general. This has a memory footprint impact for all functions, even when a debugger is not attached (but Duktape debugger support is compiled in) so this approach is not very desirable.</li><li>Emit explicit line transition opcodes. This has a memory and performance impact, even when a debugger is not attached, so this approach is also not very desirable.</li></ul><h3 id="improve-compiler-line-number-accuracy" tabindex="-1">Improve compiler line number accuracy <a class="header-anchor" href="#improve-compiler-line-number-accuracy" aria-label="Permalink to &quot;Improve compiler line number accuracy&quot;">​</a></h3><p>The ECMAScript compiler assigns line numbers to bytecode opcodes emitted, and doesn&#39;t always do a perfect job in doing so. There are a few cases where the line number for a statement can be off by one (matching a previous statement) which looks funny in the debugger UI.</p><p>The underlying issue is that the compiler emits bytecode opcodes both when the active token is in the &quot;previous token&quot; and the &quot;current token&quot; slot. Expression parsing usually has the active token in the previous token slot, while statement parsing (especially when parsing the initial keyword) has the active token in the current token slot. This needs some reworking to be fixed properly.</p><h3 id="source-code" tabindex="-1">Source code <a class="header-anchor" href="#source-code" aria-label="Permalink to &quot;Source code&quot;">​</a></h3><p>Source code handling is currently outside of Duktape scope, and we simply assume that the proper source file can be located based on a &quot;fileName&quot; property of a running function.</p><p>There are many future options:</p><ul><li>Download from target device (same as where code was originally loaded)</li><li>Store source when compiling in debug mode, possibly using some trivial compression to reduce the memory impact</li><li>Identify source code text using a hash computed on the target, so that the corresponding source can be located more reliably</li></ul><h3 id="source-maps" tabindex="-1">Source maps <a class="header-anchor" href="#source-maps" aria-label="Permalink to &quot;Source maps&quot;">​</a></h3><p>It&#39;s a common practice to minify Javascript code. Line number information is often lost in the process, and this makes the code difficult to debug for a variety of reasons:</p><ul><li>Source code readability is poor</li><li>Breakpoint mechanisms targeting file/line work very poorly</li></ul><p>Source maps record the original line number information:</p><ul><li><a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="noreferrer">http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/</a></li></ul><p>If Duktape supported source maps, a source map could be taken into account during compilation and function pc-to-line mapping could refer to the original unminified source code which would be much more debugger friendly.</p><h3 id="more-flexible-pausing" tabindex="-1">More flexible pausing <a class="header-anchor" href="#more-flexible-pausing" aria-label="Permalink to &quot;More flexible pausing&quot;">​</a></h3><p>Various triggers for pausing could be added:</p><ul><li>Pause on function entry/exit</li><li>Pause on next statement</li><li>Pause on yield/resume</li><li>Pause on execution timeout</li></ul><h3 id="more-flexible-stepping" tabindex="-1">More flexible stepping <a class="header-anchor" href="#more-flexible-stepping" aria-label="Permalink to &quot;More flexible stepping&quot;">​</a></h3><p>Additional stepping parameters could be implemented:</p><ul><li>Step one PC at a time</li><li>Step for N bytecode instructions</li><li>Step for roughly N milliseconds</li></ul><h3 id="dynamically-declared-variables-in-local-variable-list" tabindex="-1">Dynamically declared variables in local variable list <a class="header-anchor" href="#dynamically-declared-variables-in-local-variable-list" aria-label="Permalink to &quot;Dynamically declared variables in local variable list&quot;">​</a></h3><p>The local variable list returned by GetLocals does not include dynamically declared variables, or variables with a scope smaller than the entire function:</p><pre><code>function test() {
    var foo = 123;   // &#39;foo&#39; is included

    eval(&#39;var bar = 321&#39;);  // &#39;bar&#39; is not included

    try {
        throw &#39;foo&#39;;
    } catch (e) {
        // &#39;e&#39; is not included
    }
}
</code></pre><p>This should be fixed so that the locals include dynamic variables too. This is especially important for try-catch.</p><p>The Eval command can read/write dynamic variables too, so the current workaround is to use Eval. For instance, in the catch clause, Eval <code>&quot;e&quot;</code> to read the error caught.</p><h3 id="expression-dependent-breakpoints" tabindex="-1">Expression dependent breakpoints <a class="header-anchor" href="#expression-dependent-breakpoints" aria-label="Permalink to &quot;Expression dependent breakpoints&quot;">​</a></h3><p>Pause when an expression evaluates to a truthy value.</p><h3 id="watch-expressions" tabindex="-1">Watch expressions <a class="header-anchor" href="#watch-expressions" aria-label="Permalink to &quot;Watch expressions&quot;">​</a></h3><p>Watch expressions are currently implemented by the debug client using the Eval command.</p><p>For example, the debugger web UI implements automatic eval for a single expression. The expression is automatically evaluated when Duktape becomes paused. This is easy to extend for multiple watch expressions.</p><h3 id="notifications-on-internal-events" tabindex="-1">Notifications on internal events <a class="header-anchor" href="#notifications-on-internal-events" aria-label="Permalink to &quot;Notifications on internal events&quot;">​</a></h3><p>Send a notification when interesting internal events occur, like:</p><ul><li>Ordinary GC</li><li>Emergency GC</li><li>Thread creation</li><li>Thread destruction</li><li>Execution timeout</li></ul><p>These must be implemented very carefully. For instance, if we&#39;re currently in the process of responding to some debug command (say, &quot;get locals&quot;) and GC is triggered, the GC notify cannot be sent inline from the mark-and-sweep code because it might then appear in the middle of the &quot;get locals&quot; response. Instead, events need to be flagged, based on counters, or queued.</p><h3 id="possible-new-commands-or-command-improvements" tabindex="-1">Possible new commands or command improvements <a class="header-anchor" href="#possible-new-commands-or-command-improvements" aria-label="Permalink to &quot;Possible new commands or command improvements&quot;">​</a></h3><ul><li>More comprehensive callstack inspection, at least on par with what a stack trace provides</li><li>Resume with error, i.e. inject error</li><li>Enumerate threads in heap</li><li>Enumerate all objects in heap</li><li>Status for success/failure of PutVar</li><li>Error handling for PutVar</li><li>Avoid side effects (getter invocation) in GetVar</li></ul><h3 id="direct-support-for-structured-values" tabindex="-1">Direct support for structured values <a class="header-anchor" href="#direct-support-for-structured-values" aria-label="Permalink to &quot;Direct support for structured values&quot;">​</a></h3><p>The current mapping between <code>duk_tval</code> values and dvalues works but it cannot represent structured types. For instance, if a hypothetical debug command to set a global variable reads the value argument as a dvalue, it cannot write a value like <code>[1,2,3]</code> into the global variable.</p><p>This can of course be worked out by doing an <code>eval()</code> for the argument or by representing the value as JSON (which is more or less the same thing).</p><p>Another alternative is to add support for representing structured values directly with dvalues, so that when C code does a:</p><pre><code>duk_debug_read_tval(thr);
</code></pre><p>an arbitrarily complex object value (perhaps even an arbitrary object graph) can be decoded and pushed to the value stack.</p><p>Heap walking support alleviates this problem for the cases where the structured data resides or can be placed in the Duktape heap.</p><h3 id="heap-dump-viewer" tabindex="-1">Heap dump viewer <a class="header-anchor" href="#heap-dump-viewer" aria-label="Permalink to &quot;Heap dump viewer&quot;">​</a></h3><p>The DumpHeap command provides a snapshot of all heap objects, which the debugger web UI converts into a JSON dump. It&#39;d be nice to include a viewer for the dump, so that it&#39;d be easy to traverse the object graph, look for strings and values, etc.</p><h3 id="eclipse-debugger" tabindex="-1">Eclipse debugger <a class="header-anchor" href="#eclipse-debugger" aria-label="Permalink to &quot;Eclipse debugger&quot;">​</a></h3><p>An Eclipse debugger would be very useful as it&#39;s a very popular IDE for embedded development. There are already integrations for Visual Studio Code.</p><h3 id="breakpoint-handling-in-attach-detach" tabindex="-1">Breakpoint handling in attach/detach <a class="header-anchor" href="#breakpoint-handling-in-attach-detach" aria-label="Permalink to &quot;Breakpoint handling in attach/detach&quot;">​</a></h3><p>Currently the list of breakpoints is not cleared by attach or detach, so if you detach and then re-attach, old breakpoints are still set. The debug client can just delete all breakpoints on attach, but it&#39;d be cleaner to remove the breakpoints on either attach or detach.</p><h3 id="indicate-fastint-status" tabindex="-1">Indicate fastint status <a class="header-anchor" href="#indicate-fastint-status" aria-label="Permalink to &quot;Indicate fastint status&quot;">​</a></h3><p>When debugging code that is intended to operate with fastints, it would be useful to see when a value is internally represented as a fastint vs. a full IEEE double. Currently this information is not conveyed by the protocol, and all fastints appear like any other number values.</p><h3 id="buffer-object-support" tabindex="-1">Buffer object support <a class="header-anchor" href="#buffer-object-support" aria-label="Permalink to &quot;Buffer object support&quot;">​</a></h3><p>Make it easier to see buffer object contents (like for plain buffers), either by serializing them differently, or through heap walking.</p><h3 id="separate-callback-for-checking-transport-status" tabindex="-1">Separate callback for checking transport status <a class="header-anchor" href="#separate-callback-for-checking-transport-status" aria-label="Permalink to &quot;Separate callback for checking transport status&quot;">​</a></h3><p>When Duktape is in the running state (not paused), Duktape will only call:</p><ul><li>The peek callback periodically to see if there is anything to read. There&#39;s no way to indicate a transport detach/error with peek now.</li><li>The write callback periodically, as a side effect of sending Status notifies. This is the main mechanism now for detecting a broken transport in the running state. If Status notifies were removed, Duktape would not notice a transport break unless something else prompted a write to the debug transport.</li></ul><p>It might be cleaner to provide either:</p><ul><li>A callback to check transport status explicitly and perhaps allows even an error message to be indicated.</li><li>Allow user code to proactively call into Duktape to indicate the transport is broken (beyond calling <code>duk_debugger_detach()</code>).</li></ul><p>However, for some transports it may not be possible to get transport status information without actually attempting a write. This may be caused by the nature of the transport or an underlying platform API limitation, for example. So, such a transport status callback must be optional, and it may still be necessary to ensure a periodic write (a &quot;keepalive&quot; if nothing else) to detect transport errors in such cases.</p><h3 id="extend-err-message-with-a-programmatic-string-error-code" tabindex="-1">Extend ERR message with a programmatic string error code <a class="header-anchor" href="#extend-err-message-with-a-programmatic-string-error-code" aria-label="Permalink to &quot;Extend ERR message with a programmatic string error code&quot;">​</a></h3><p>Current error messages have the form:</p><pre><code>ERR &lt;error number&gt; &lt;message&gt; EOM
</code></pre><p>The number space is awkward to manage modularly, and doesn&#39;t work well for application specific errors which would be useful for e.g. AppRequest messages. Extend the error format to:</p><pre><code>ERR &lt;error number&gt; &lt;error string code&gt; &lt;message&gt; EOM
</code></pre><p>String codes could follow an all caps convention like <code>&quot;NOT_FOUND&quot;</code>:</p><pre><code>ERR 3 &quot;NOT_FOUND&quot; &quot;breakpoint not found&quot; EOM
</code></pre><p>String error codes are easy to extend without conflicts like one has with a numbered sequence.</p><h3 id="change-callstack-entries-to-avoid-getter-invocations" tabindex="-1">Change callstack entries to avoid getter invocations <a class="header-anchor" href="#change-callstack-entries-to-avoid-getter-invocations" aria-label="Permalink to &quot;Change callstack entries to avoid getter invocations&quot;">​</a></h3><p>With heap walking in place callstack variable dump could provide the necessary information to distinguish data and accessor properties and let the debug client decide if getters are to be invoked.</p><p>Callstack primitives could also return the variable list in a format matching the GetHeapObjInfo command, i.e. as a key/value list which also provides support for artificial properties and property flags.</p><h3 id="replace-getbytecode-with-object-inspection" tabindex="-1">Replace GetBytecode with object inspection <a class="header-anchor" href="#replace-getbytecode-with-object-inspection" aria-label="Permalink to &quot;Replace GetBytecode with object inspection&quot;">​</a></h3><p>The GetBytecode command could be removed by providing a reference to the current function and then using object inspection to get the bytecode data currently returned in GetBytecode -- that is, the bytecode, constants, etc.</p><h3 id="improve-garbage-collection-behavior-during-paused-state" tabindex="-1">Improve garbage collection behavior during paused state <a class="header-anchor" href="#improve-garbage-collection-behavior-during-paused-state" aria-label="Permalink to &quot;Improve garbage collection behavior during paused state&quot;">​</a></h3><p>Current behavior: garbage generated during paused state (refzero or objects in reference loops) will both be left in the heap and collected eventually by mark-and-sweep.</p><p>Various improvements are possible, see discussion in <a href="https://github.com/svaarala/duktape/pull/617" target="_blank" rel="noreferrer">https://github.com/svaarala/duktape/pull/617</a>.</p>`,889),l=[n];function r(i,p,c,d,u,h){return t(),a("div",null,l)}const b=e(o,[["render",r]]);export{g as __pageData,b as default};
