import{_ as e,c as o,o as t,Q as a}from"./chunks/framework.44f152d8.js";const f=JSON.parse('{"title":"Duktapeバイトコード形式","description":"","frontmatter":{},"headers":[],"relativePath":"translation/duktape/doc/bytecode.md","lastUpdated":1676129847000}'),i={name:"translation/duktape/doc/bytecode.md"},n=a(`<h1 id="duktapeバイトコード形式" tabindex="-1">Duktapeバイトコード形式 <a class="header-anchor" href="#duktapeバイトコード形式" aria-label="Permalink to &quot;Duktapeバイトコード形式&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Duktape has API functions to dump a compiled function into bytecode and load (reinstantiate) a function from a bytecode dump. Bytecode dump/load allows code to be compiled offline, compiled code to be cached and reused, compiled code to be moved from one Duktape heap to another, etc. However, Duktape bytecode format is version specific so it is <em>not</em> a version neutral code distribution format like Java bytecode. (The term &quot;bytecode&quot; is used here and in other Duktape documentation even though it&#39;s a bit inaccurate: the serialization format includes many other fields besides bytecode instructions.)</p><p>Duktape bytecode is <strong>version specific</strong> and (potentially) <strong>config option specific</strong>, and may change arbitrarily even in minor releases (but is guaranteed not to change in a patch release, as long as config options are kept the same). In other words, the bytecode format is not part of the ordinary versioning guarantees. If you compile code into bytecode offline, you must ensure such code is recompiled whenever Duktape source is updated. In this sense Duktape bytecode differs fundamentally from e.g. Java bytecode which is used as a version neutral distribution format.</p><p>Duktape bytecode is <strong>unvalidated</strong> which means that loading untrusted or broken bytecode may cause a crash or other memory unsafe behavior, leading to potentially exploitable vulnerabilities. Calling code is responsible for ensuring that bytecode for a different Duktape version is not loaded, and that the bytecode input is not truncated or corrupted. (Validating bytecode is quite difficult, because one would also need to validate the actual bytecode which might otherwise refer to non-existent registers or constants, jump out of bounds, etc.)</p><p>The bytecode format is <strong>platform neutral</strong>, so that it&#39;s possible to compile the bytecode on one platform and load it on another, even if the platforms have different byte order. This is useful to support offline compilation in cross compilation.</p><p>There are a few limitations on what kind of functions can be dumped into bytecode, and what information is lost in the process. See separate section on limitations below. The following API test case provides concrete examples on usage and current limitations:</p><ul><li><code>api-testcases/test-dump-load-basic.c</code></li></ul><h2 id="working-with-bytecode" tabindex="-1">Working with bytecode <a class="header-anchor" href="#working-with-bytecode" aria-label="Permalink to &quot;Working with bytecode&quot;">​</a></h2><p>The <code>duk_dump_function()</code> API call is used to convert a function into a buffer containing bytecode:</p><pre><code>duk_eval_string(ctx, &quot;(function myfunc() { print(&#39;hello world&#39;); })&quot;);
duk_dump_function(ctx);
/* -&gt; stack top contains bytecode for &#39;myfunc&#39; */
</code></pre><p>The <code>duk_load_function()</code> API call does the reverse, converting a buffer containing bytecode into a function object:</p><pre><code>/* ... push bytecode to value stack top */
duk_load_function(ctx);
/* -&gt; stack top contains function */
</code></pre><p>The Duktape command line tool &quot;duk&quot; can also be used to compile a file into bytecode:</p><pre><code>./duk -c /tmp/program.bin program.js
</code></pre><p>The input source is compiled as an ECMAScript program and the bytecode will be for the &quot;program function&quot;. The command line tool doesn&#39;t support compiling individual functions, and is mostly useful for playing with bytecode.</p><p>The command line tool can also execute bytecode functions; it will just load a function and call it without arguments, as if a program function was being executed:</p><pre><code>./duk -b /tmp/program.bin
</code></pre><h2 id="when-to-use-bytecode-dump-load" tabindex="-1">When to use bytecode dump/load <a class="header-anchor" href="#when-to-use-bytecode-dump-load" aria-label="Permalink to &quot;When to use bytecode dump/load&quot;">​</a></h2><p>Generally speaking, there are two main motivations for using a bytecode dump/load mechanism:</p><ul><li>Performance</li><li>Obfuscation</li></ul><p>Duktape&#39;s bytecode format improves performance compared to compilation, but is not ideal for obfuscation as discussed in more detail below.</p><h3 id="performance" tabindex="-1">Performance <a class="header-anchor" href="#performance" aria-label="Permalink to &quot;Performance&quot;">​</a></h3><p>Whenever compilation performance is <em>not</em> an issue, it is nearly always preferable to compile functions from source rather than using bytecode dump/load. Compiling from source is memory safe, version compatible, and has no semantic limitations like bytecode.</p><p>There are some applications where compilation is a performance issue. For example, a certain function may be compiled and executed over and over again in short lived Duktape global contexts or even separate Duktape heaps (which prevents reusing a single function object). Caching the compiled function bytecode and instantiating the function by loading the bytecode is much faster than recompiling it for every execution.</p><h3 id="obfuscation" tabindex="-1">Obfuscation <a class="header-anchor" href="#obfuscation" aria-label="Permalink to &quot;Obfuscation&quot;">​</a></h3><p>Obfuscation is another common reason to use bytecode: it&#39;s more difficult to reverse engineer source code from bytecode than e.g. minified code. However, when doing so, you should note the following:</p><ul><li>Some minifiers support obfuscation which may be good enough and avoids the bytecode limitations and downsides.</li><li>For some targets source code encryption may be a better option than relying on bytecode for obfuscation.</li><li>Although Duktape bytecode doesn&#39;t currently store source code, it does store all variable names (<code>_Varmap</code>) and formal argument names (<code>_Formals</code>) which are needed in some functions. It may also be possible source code is included in bytecode at some point to support debugging. In other words, <strong>obfuscation is not a design goal for the bytecode format</strong>.</li></ul><p>That said, concrete issues to consider when using bytecode for obfuscation:</p><ul><li>Variable names in the <code>_Varmap</code> property: this cannot be easily avoided in general but a minifier may be able to rename variables.</li><li>Function name in the <code>name</code> property: this can be deleted or changed before dumping a function, but note that some functions (such as self-recursive functions) may depend on the property being present and correct.</li><li>Function filename in the <code>fileName</code> property: this can also be deleted or changed before dumping a function. You can avoid introducing a filename at all by using <code>duk_compile()</code> (rather than e.g. <code>duk_eval_string()</code>) to compile the function.</li><li>Line number information in the <code>_Pc2line</code> property: this can be deleted or changed, or you can configure Duktape not to store this information in the first place (using option <code>DUK_USE_PC2LINE</code>). Without line information tracebacks will of course be less useful.</li></ul><h2 id="when-not-to-use-bytecode-dump-load" tabindex="-1">When not to use bytecode dump/load <a class="header-anchor" href="#when-not-to-use-bytecode-dump-load" aria-label="Permalink to &quot;When not to use bytecode dump/load&quot;">​</a></h2><p>Duktape bytecode is <strong>not</strong> a good match for:</p><ul><li>Distributing code</li><li>Minimizing code size</li></ul><h3 id="distributing-code" tabindex="-1">Distributing code <a class="header-anchor" href="#distributing-code" aria-label="Permalink to &quot;Distributing code&quot;">​</a></h3><p>It&#39;s awkward to use a version specific bytecode format for code distribution. This is especially true for ECMAScript, because the language itself is otherwise well suited for writing backwards compatible code, detecting features at run-time, etc.</p><p>It&#39;s also awkward for code distribution that the bytecode load operation relies on calling code to ensure the loaded bytecode is trustworthy and uncorrupted. In practice this means e.g. cryptographic signatures are needed to avoid tampering.</p><h3 id="minimizing-code-size" tabindex="-1">Minimizing code size <a class="header-anchor" href="#minimizing-code-size" aria-label="Permalink to &quot;Minimizing code size&quot;">​</a></h3><p>The bytecode format is designed to be fast to dump and load, while still being platform neutral. It is <em>not</em> designed to be compact (and indeed is not).</p><p>For example, for a simple Mandelbrot function (<code>mandel()</code> in <code>dist-files/mandel.js</code>):</p><hr><p>Format Size (bytes) Gzipped size (bytes)</p><hr><p>Original source 884 371</p><p>Bytecode dump 809 504</p><h2 id="uglifyjs2-minified-source-364-267" tabindex="-1">UglifyJS2-minified source 364 267 <a class="header-anchor" href="#uglifyjs2-minified-source-364-267" aria-label="Permalink to &quot;UglifyJS2-minified source   364              267&quot;">​</a></h2><p>For minimizing code size, using a minifier and ordinary compression is a much better idea than relying on compressed or uncompressed bytecode.</p><h2 id="bytecode-limitations" tabindex="-1">Bytecode limitations <a class="header-anchor" href="#bytecode-limitations" aria-label="Permalink to &quot;Bytecode limitations&quot;">​</a></h2><h3 id="function-lexical-environment-is-lost" tabindex="-1">Function lexical environment is lost <a class="header-anchor" href="#function-lexical-environment-is-lost" aria-label="Permalink to &quot;Function lexical environment is lost&quot;">​</a></h3><p>A function loaded from bytecode always works as if it was defined in the global environment so that any variable lookups not bound in the function itself will be resolved through the global object. If you serialize <code>bar</code> created as:</p><pre><code>function foo() {
    var myValue = 123;

    function bar() {
        // myValue will be 123, looked up from &#39;foo&#39; scope

        print(myValue);
    }

    return bar;
}
</code></pre><p>and then load it back, it will behave as if it was originally created as:</p><pre><code>function bar() {
    // myValue will be read from global object

    print(myValue);
}
</code></pre><p>If the original function was established using a function declaration, the declaration itself is not restored when a function is loaded. This may be confusing. For example, if you serialize <code>foo</code> declared as:</p><pre><code>function foo() {
    // Prints &#39;function&#39; before dump/load; &#39;foo&#39; is looked up from
    // the global object.

    print(typeof foo);
}
</code></pre><p>and then load it back, it will behave as:</p><pre><code>var loadedFunc = (function() {
    // Prints &#39;undefined&#39; after dump/load; &#39;foo&#39; is looked up from
    // the global object.  Workaround is to assign loadedFunc to
    // globalObject.foo manually before calling to simulate declaration.

    print(typeof foo);
});
</code></pre><h3 id="no-function-name-binding-for-function-declarations" tabindex="-1">No function name binding for function declarations <a class="header-anchor" href="#no-function-name-binding-for-function-declarations" aria-label="Permalink to &quot;No function name binding for function declarations&quot;">​</a></h3><p>Function name binding for function expressions is supported, e.g. the following function would work:</p><pre><code>// Can dump and load this function, the reference to &#39;count&#39; will
// be resolved using the automatic function name lexical binding
// provided for function expressions.

var func = function count(n) { print(n); if (n &gt; 0) { count(n - 1); } };
</code></pre><p>However, for technical reasons functions that are established as global declarations work a bit differently:</p><pre><code>// Can dump and load this function, but the reference to &#39;count&#39;
// will lookup globalObject.count instead of automatically
// referencing the function itself.  Workaround is to assign
// the function to globalObject.count after loading.

function count(n) { print(n); if (n &gt; 0) { count(n - 1); } };
</code></pre><p>(The NAMEBINDING flag controls creation of a lexical environment which contains the function expression name binding. In Duktape 1.2 the flag is only set for function templates, not function instances; this was changed for Duktape 1.3 so that the NAMEBINDING flag could be detected when loading bytecode, and a lexical environment can then be created based on the flag.)</p><h3 id="custom-internal-prototype-is-lost" tabindex="-1">Custom internal prototype is lost <a class="header-anchor" href="#custom-internal-prototype-is-lost" aria-label="Permalink to &quot;Custom internal prototype is lost&quot;">​</a></h3><p>A custom internal prototype is lost, and <code>Function.prototype</code> is used on bytecode load.</p><h3 id="custom-external-prototype-is-lost" tabindex="-1">Custom external prototype is lost <a class="header-anchor" href="#custom-external-prototype-is-lost" aria-label="Permalink to &quot;Custom external prototype is lost&quot;">​</a></h3><p>A custom external prototype (<code>.prototype</code> property) is lost, and a default empty prototype is created on bytecode load.</p><h3 id="finalizer-on-the-function-is-lost" tabindex="-1">Finalizer on the function is lost <a class="header-anchor" href="#finalizer-on-the-function-is-lost" aria-label="Permalink to &quot;Finalizer on the function is lost&quot;">​</a></h3><p>A finalizer on the function being serialized is lost, no finalizer will exist after a bytecode load.</p><h3 id="only-specific-function-object-properties-are-kept" tabindex="-1">Only specific function object properties are kept <a class="header-anchor" href="#only-specific-function-object-properties-are-kept" aria-label="Permalink to &quot;Only specific function object properties are kept&quot;">​</a></h3><p>Only specific function object properties, i.e. those needed to correctly revive a function, are kept. These properties have type and value limitations:</p><ul><li>.length: uint32, non-number values replaced by 0</li><li>.name: string required, non-string values replaced by empty string</li><li>.fileName: string required, non-string values replaced by empty string</li><li>._Formals: internal property, value is an array of strings</li><li>._Varmap: internal property, value is an object mapping identifier names to register numbers</li></ul><h3 id="bound-functions-are-not-supported" tabindex="-1">Bound functions are not supported <a class="header-anchor" href="#bound-functions-are-not-supported" aria-label="Permalink to &quot;Bound functions are not supported&quot;">​</a></h3><p>Currently a <code>TypeError</code> is thrown when trying to serialize a bound function object.</p><h3 id="commonjs-modules-don-t-work-well-with-bytecode-dump-load" tabindex="-1">CommonJS modules don&#39;t work well with bytecode dump/load <a class="header-anchor" href="#commonjs-modules-don-t-work-well-with-bytecode-dump-load" aria-label="Permalink to &quot;CommonJS modules don\\&#39;t work well with bytecode dump/load&quot;">​</a></h3><p>CommonJS modules cannot be trivially serialized because they&#39;re normally evaluated by embedding the module source code inside a temporary function wrapper (see <code>modules.rst</code> for details). User code does not have access to the temporary wrapped function. This means that:</p><ul><li>If you compile and serialize the module source, the module will have incorrect scope semantics.</li><li>You could add the function wrapper and compile the wrapped function instead.</li><li>Module support for bytecode dump/load will probably need future work.</li></ul><h2 id="bytecode-format" tabindex="-1">Bytecode format <a class="header-anchor" href="#bytecode-format" aria-label="Permalink to &quot;Bytecode format&quot;">​</a></h2><p>A function is serialized into a platform neutral byte stream. Multibyte values are in network order (big endian), and don&#39;t have any alignment guarantees.</p><p>Because the exact format is version specific, it&#39;s not documented in full detail here. Doing so would mean tedious documentation updates whenever bytecode was changed, and documentation would then easily fall out of date. The exact format is ultimately defined by the source code, see:</p><ul><li><code>src-input/duk_api_bytecode.c</code></li><li><code>tools/dump_bytecode.py</code></li></ul><p>As a simplified summary of the bytecode format:</p><ul><li>A single 0xBF marker byte which never occurs in a valid extended UTF-8 string. (A version byte used to follow the marker; it was removed in Duktape 2.2 because it hadn&#39;t been bumped and because it really provided no version guarantees.)</li><li>The marker is followed by a serialized function. The function may contain inner functions which are serialized recursively (without duplicating the two-byte header).</li></ul><p>The function serialization format is tedious and best looked up directly from source code.</p><p>NOTE: The top level function is a function instance, but all inner functions are function templates. There are some difference between the two which must be taken into account in bytecode serialization code.</p><h2 id="security-and-memory-safety" tabindex="-1">Security and memory safety <a class="header-anchor" href="#security-and-memory-safety" aria-label="Permalink to &quot;Security and memory safety&quot;">​</a></h2><p>Duktape bytecode must only be loaded from a trusted source: loading broken or maliciously crafted bytecode may lead to memory unsafe behavior, even exploitable behavior.</p><p>Because bytecode is version specific, it is generally unsafe to load bytecode provided by a network peer -- unless you can somehow be certain the bytecode is specifically compiled for your Duktape version.</p><h2 id="design-notes" tabindex="-1">Design notes <a class="header-anchor" href="#design-notes" aria-label="Permalink to &quot;Design notes&quot;">​</a></h2><h3 id="eval-and-program-code" tabindex="-1">Eval and program code <a class="header-anchor" href="#eval-and-program-code" aria-label="Permalink to &quot;Eval and program code&quot;">​</a></h3><p>ECMAScript specification recognizes three different types of code: program code, eval code, and function code, with slightly different scope and variable binding semantics. The serialization mechanism supports all three types.</p><h3 id="version-specific-vs-version-neutral" tabindex="-1">Version specific vs. version neutral <a class="header-anchor" href="#version-specific-vs-version-neutral" aria-label="Permalink to &quot;Version specific vs. version neutral&quot;">​</a></h3><p>Duktape bytecode instruction format is already version specific and can change between even minor releases, so it&#39;s quite natural for the serialization format to also be version specific.</p><p>Providing a version neutral format would be possible when Duktape bytecode no longer changes in minor versions (not easy to see when this would be the case) or by doing some kind of recompilation for bytecode.</p><h3 id="config-option-specific" tabindex="-1">Config option specific <a class="header-anchor" href="#config-option-specific" aria-label="Permalink to &quot;Config option specific&quot;">​</a></h3><p>Some Duktape options may affect what function metadata is available. E.g. you can disable line number information (pc2line) which might then be left out of the bytecode dump altogether. Attempting to load such a dump in a Duktape environment compiled with line number information enabled might then fail due to a format error.</p><p>(In the initial master merge there are no config option specific format differences, but there may be such differences in later Duktape versions if it&#39;s convenient to do so.)</p><h3 id="endianness" tabindex="-1">Endianness <a class="header-anchor" href="#endianness" aria-label="Permalink to &quot;Endianness&quot;">​</a></h3><p>Network endian was chosen because it&#39;s also used elsewhere in Duktape (e.g. the debugger protocol) as the default, portable endianness.</p><p>Faster bytecode dump/load could be achieved by using native endianness and (if necessary) padding to achieve proper alignment. This additional speed improvement was considered less important than portability.</p><h3 id="platform-neutrality" tabindex="-1">Platform neutrality <a class="header-anchor" href="#platform-neutrality" aria-label="Permalink to &quot;Platform neutrality&quot;">​</a></h3><p>Supporting cross compilation is a useful feature so that bytecode generated on one platform can be loaded on another, as long as they run the same Duktape version.</p><p>The cost of being platform neutral is rather small. The essential features are normalizing endianness and avoiding alignment assumptions. Both can be quite easily accommodated with relatively little run-time cost.</p><h3 id="bytecode-header" tabindex="-1">Bytecode header <a class="header-anchor" href="#bytecode-header" aria-label="Permalink to &quot;Bytecode header&quot;">​</a></h3><p>The initial 0xBF byte is used because it can never appear in valid UTF-8 (even extended UTF-8) so that using a random string accidentally as bytecode input will fail.</p><h3 id="memory-safety-and-bytecode-validation" tabindex="-1">Memory safety and bytecode validation <a class="header-anchor" href="#memory-safety-and-bytecode-validation" aria-label="Permalink to &quot;Memory safety and bytecode validation&quot;">​</a></h3><p>The bytecode load primitive is memory unsafe, to the extent that trying to load corrupted (truncated and/or modified) bytecode may lead to memory unsafe behavior (even exploitable behavior). To keep bytecode loading fast and simple, there are even no bounds checks when parsing the input bytecode.</p><p>This might seem strange but is intentional: while it would be easy to do basic syntax validation for the serialized data when it is loaded, it still wouldn&#39;t guarantee memory safety. To do so one would also need to validate the bytecode opcodes, otherwise memory unsafe behavior may happen at run time.</p><p>Consider the following example: a function being loaded has <code>nregs</code> 100, so that 100 slots are allocated from the value stack for the function. If the function bytecode then executed:</p><pre><code>LDREG 1, 999   ; read reg 999, out of bounds
STREG 1, 999   ; write reg 999, out of bounds
</code></pre><p>Similar issues exist for constants; if the function has 100 constants:</p><pre><code>LDCONST 1, 999 ; read constant 999, out of bounds
</code></pre><p>In addition to direct out-of-bounds references there are also &quot;indirect&quot; opcodes which e.g. load a register index from another register. Validating these would be a lot more difficult and would need some basic control flow algorithm, etc.</p><p>Overall it would be quite difficult to implement bytecode validation that would correctly catch broken and perhaps maliciously crafted bytecode, and it&#39;s not very useful to have a partial solution in place.</p><p>Even so there is a very simple header signature for bytecode which ensures that obviously incorrect values are rejected early. The signature ensures that no ordinary string data can accidentally be loaded as byte code (the initial byte 0xBF is invalid extended UTF-8). Any bytes beyond the marker are unvalidated.</p><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><h3 id="full-value-serialization" tabindex="-1">Full value serialization <a class="header-anchor" href="#full-value-serialization" aria-label="Permalink to &quot;Full value serialization&quot;">​</a></h3><p>Bytecode dump/load is restricted to a subset of function values. It would be more elegant to support generic value dump/load. However, there are several practical issues:</p><ul><li>Arbitrary object graphs would need to be supported, which is quite challenging.</li><li>There&#39;d have to be some mechanism to &quot;revive&quot; any native values on load. For example, for a native object representing an open file, the revive operation would reopen the file and perhaps seek the file to the correct offset.</li></ul><h3 id="support-bound-functions" tabindex="-1">Support bound functions <a class="header-anchor" href="#support-bound-functions" aria-label="Permalink to &quot;Support bound functions&quot;">​</a></h3><p>Currently a TypeError is thrown for bound functions. As a first step, it&#39;s probably better to follow the bound chain and serialize the final target function instead, i.e. bound status would be lost during serialization. This is more in line with serializing with loss of some metadata rather than throwing an error.</p><p>As the second step, it would be nice to serialize the bound <code>this</code> and argument values. However, proper generic value serialization would be needed to do that.</p><h3 id="caching-commonjs-modules" tabindex="-1">Caching CommonJS modules <a class="header-anchor" href="#caching-commonjs-modules" aria-label="Permalink to &quot;Caching CommonJS modules&quot;">​</a></h3><p>Caching CommonJS modules would be very useful. Figure out how to do that when reworking the module mechanism.</p><h3 id="figure-out-debugger-overlap" tabindex="-1">Figure out debugger overlap <a class="header-anchor" href="#figure-out-debugger-overlap" aria-label="Permalink to &quot;Figure out debugger overlap&quot;">​</a></h3><p>The debugger protocol has its own value serialization format (with somewhat different goals):</p><ul><li>Would it be sensible to share value serialization format between dump/load and debugger protocol?</li><li>Should function values be serialized in the debugger protocol in the bytecode dump/load format? Would that be useful for the debugger (not immediately apparent why)?</li></ul>`,126),r=[n];function s(d,l,c,u,p,h){return t(),o("div",null,r)}const b=e(i,[["render",s]]);export{f as __pageData,b as default};
