import{_ as s,o as a,c as n,R as l}from"./chunks/framework.320df067.js";const A=JSON.parse('{"title":"C++","description":"","frontmatter":{},"headers":[],"relativePath":"translation/antlr/cpp-target.md","filePath":"translation/antlr/cpp-target.md","lastUpdated":null}'),e={name:"translation/antlr/cpp-target.md"},p=l(`<h1 id="c" tabindex="-1">C++ <a class="header-anchor" href="#c" aria-label="Permalink to &quot;C++&quot;">​</a></h1><p>C++ターゲットは、MS Visual Studio 2013（またはそれ以降）、XCode 7（またはそれ以降）、CMake（C++11が必要）のいずれかを実行できるすべてのプラットフォームをサポートしています。すべてのビルド・ツールで、スタティック・ライブラリまたはダイナミック・ライブラリを作成できます。さらに、XCodeはiOSライブラリを作成できます。Antlr4 for C++ with CMake: A practical exampleも参照してください。</p><h2 id="c-レキサーやパーサーを作成するには" tabindex="-1">C++レキサーやパーサーを作成するには？ <a class="header-anchor" href="#c-レキサーやパーサーを作成するには" aria-label="Permalink to &quot;C++レキサーやパーサーを作成するには？&quot;">​</a></h2><p>これは、例えば言語ターゲットを指定する必要があることを除けば、Javaレキサーやパーサーを作成するのとほとんど同じです：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">$ antlr4 -Dlanguage=Cpp MyGrammar.g4</span></span></code></pre></div><p>この呼び出しによって生成されたファイルが大量にあることがわかるだろう。visitorやlistenerが抑制されていない場合（これがデフォルト）、次のようになる：</p><ul><li>MyGrammarLexer.h + MyGrammarLexer.cpp</li><li>MyGrammarParser.h + MyGrammarParser.cpp</li><li>MyGrammarVisitor.h + MyGrammarVisitor.cpp</li><li>MyGrammarBaseVisitor.h + MyGrammarBaseVisitor.cpp</li><li>MyGrammarListener.h + MyGrammarListener.cpp</li><li>MyGrammarBaseListener.h + MyGrammarBaseListener.cpp</li></ul><h2 id="ランタイムはどこで入手できますか" tabindex="-1">ランタイムはどこで入手できますか？ <a class="header-anchor" href="#ランタイムはどこで入手できますか" aria-label="Permalink to &quot;ランタイムはどこで入手できますか？&quot;">​</a></h2><p>レキサーやパーサーのコードを生成したら、ランタイムをダウンロードまたはビルドする必要があります。Windows（Visual Studio 2013/2015）、OSX/macOS、iOS用のビルド済みC++ランタイムバイナリは、ANTLRウェブサイトで入手できます：</p><ul><li><a href="http://www.antlr.org" target="_blank" rel="noreferrer">http://www.antlr.org</a></li></ul><p>CMakeを使用してLinuxライブラリをビルドする（OSXでも動作するが、iOSライブラリでは動作しない）。</p><p>ビルド済みのバイナリをダウンロードする代わりに、OSXやWindows上で独自のライブラリを簡単にビルドすることもできる。XCodeまたはVisual Studio用に提供されているプロジェクトを使ってビルドするだけです。依存関係を追加することなく、すぐに動作するはずだ。</p><h2 id="生成されたレキサーやパーサーを実行するにはどうすればよいですか" tabindex="-1">生成されたレキサーやパーサーを実行するにはどうすればよいですか？ <a class="header-anchor" href="#生成されたレキサーやパーサーを実行するにはどうすればよいですか" aria-label="Permalink to &quot;生成されたレキサーやパーサーを実行するにはどうすればよいですか？&quot;">​</a></h2><p>パーサーを動作させるためにすべてをまとめるのはとても簡単です。簡単な例として、runtime/Cpp/demoフォルダを見てください。そこにあるREADMEには、OSX、Windows、Linux上でデモをビルドして実行する方法が簡単に説明されています。</p><div class="info custom-block"><p class="custom-block-title">ANTLR 4 C++ ターゲットのデモアプリケーション</p><p>このデモアプリケーションは、動的および静的ライブラリとしてANTLRランタイムを構築する方法と、簡単なデモ文法から生成されたパーサーを使用する方法を示しています。</p><p>これを動作させるにはいくつかのステップが必要です：</p><ul><li>現在のANTLR jarをダウンロードし、このフォルダに置きます。</li><li>お使いのプラットフォーム用の生成スクリプト（Windowsの場合はgenerate.cmd、*nix/OSXの場合はgenerate.sh）を開き、LOCATION varをダウンロードしたjarの実際の名前に更新します。</li><li>生成スクリプトを実行する。generated &quot;という名前のサブフォルダーに、テスト用のパーサーとレキサー、リスナーとビジターのクラスが生成されます。デモ・アプリケーションはここでこれらのファイルを探します。</li><li>あなたのシステムに合ったフォルダでプロジェクトを開いてください。</li><li>コンパイルして実行してください。</li></ul><p>コンパイルはruntime/cpp/readme.mdファイルに記述されているとおりに行う。</p></div><h2 id="カスタムリスナーを作成し、実行するには" tabindex="-1">カスタムリスナーを作成し、実行するには？ <a class="header-anchor" href="#カスタムリスナーを作成し、実行するには" aria-label="Permalink to &quot;カスタムリスナーを作成し、実行するには？&quot;">​</a></h2><p>上記の生成ステップでは、リスナーとベース・リスナー・クラスを作成しました。リスナー・クラスは抽象インターフェースで、各パーサー・ルールの入力メソッドと終了メソッドを宣言します。ベース・リスナーはこれらの抽象メソッドをすべて空のボディで実装するので、1つの関数を実装したいだけなら自分で実装する必要はありません。したがって、このベース・リスナーをカスタム・リスナーのベース・クラスとして使用します：</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">iostream</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">antlr4-runtime.h</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">MyGrammarLexer.h</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">MyGrammarParser.h</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">#include</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">MyGrammarBaseListener.h</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">using</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">namespace</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">antlr4</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">TreeShapeListener</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">public</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">MyGrammarBaseListener</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">void</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">enterKey</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">ParserRuleContext</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;font-style:italic;">ctx</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">override</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">	// キー・ルールを入力する際に何かをする。</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">argc</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">char*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">argv</span><span style="color:#89DDFF;">[])</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">ifstream stream</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  stream</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">argv</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#A6ACCD;">  ANTLRInputStream </span><span style="color:#82AAFF;">input</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">stream</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  MyGrammarLexer </span><span style="color:#82AAFF;">lexer</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">input</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  CommonTokenStream </span><span style="color:#82AAFF;">tokens</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">lexer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  MyGrammarParser </span><span style="color:#82AAFF;">parser</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">tokens</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">tree</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">ParseTree </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">tree </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> parser</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">key</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">  TreeShapeListener listener</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">tree</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ParseTreeWalker</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">DEFAULT</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">walk</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">listener</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> tree</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>この例では、<code>enterKey</code>関数が生成された<code>key</code>というパーサールールが文法に含まれていると仮定しています。</p><h2 id="このantlrターゲットの特殊なケース" tabindex="-1">このANTLRターゲットの特殊なケース <a class="header-anchor" href="#このantlrターゲットの特殊なケース" aria-label="Permalink to &quot;このANTLRターゲットの特殊なケース&quot;">​</a></h2><p>C++ ANTLRターゲットだけが扱わなければならないことがいくつかある。それらについて説明します。</p><h3 id="コード生成の側面" tabindex="-1">コード生成の側面 <a class="header-anchor" href="#コード生成の側面" aria-label="Permalink to &quot;コード生成の側面&quot;">​</a></h3><p>コード生成（ANTLR4 jarの実行）では、生成されたファイルをアプリケーションにうまく統合するために役立つと思われる2つの値を指定できます（どちらもオプションです）：</p><ul><li>名前空間: <code>-package</code>パラメーターを使用して、必要な名前空間を指定します。</li><li>エクスポートマクロ: 特にVC++では、DLLからクラスをエクスポートするために余分な作業が必要になります。これは通常、DLL を作成するかインポートするかによって異なる値を持つマクロによって実現される。ANTLR4 ランタイム自体も、クラスに対してマクロを使用します：</li></ul><div class="language-c++"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">#ifdef ANTLR4CPP_EXPORTS</span></span>
<span class="line"><span style="color:#A6ACCD;">    #define ANTLR4CPP_PUBLIC __declspec(dllexport)</span></span>
<span class="line"><span style="color:#A6ACCD;">  #else</span></span>
<span class="line"><span style="color:#A6ACCD;">    #ifdef ANTLR4CPP_STATIC</span></span>
<span class="line"><span style="color:#A6ACCD;">      #define ANTLR4CPP_PUBLIC</span></span>
<span class="line"><span style="color:#A6ACCD;">    #else</span></span>
<span class="line"><span style="color:#A6ACCD;">      #define ANTLR4CPP_PUBLIC __declspec(dllimport)</span></span>
<span class="line"><span style="color:#A6ACCD;">    #endif</span></span>
<span class="line"><span style="color:#A6ACCD;">  #endif</span></span></code></pre></div><p><code>ANTLR4CPP_PUBLIC</code>マクロのように、生成されるクラスに独自のマクロを指定するには、<code>-DexportMacro=...</code>コマンドラインパラメータを使用します。 文法ファイルのオプション <code>options {exportMacro=&#39;...&#39;;}</code> を使用して、生成されるクラスに独自のマクロを指定することができます。</p><p>Visual Studioでスタティックライブラリを作成するには、スタティックライブラリのプロジェクト設定に加えて、<code>ANTLR4CPP_STATIC</code>マクロを定義します（ランタイムを自分でコンパイルする場合）。</p><p>gccとclangでは、<code>-fvisibility=hidden</code>設定を使用することで、default-visibleに設定されているシンボル（ランタイムのすべてのパブリッククラスに対して定義されている）以外のすべてのシンボルを非表示にすることができます。</p><h3 id="コンパイル・アスペクト" tabindex="-1">コンパイル・アスペクト <a class="header-anchor" href="#コンパイル・アスペクト" aria-label="Permalink to &quot;コンパイル・アスペクト&quot;">​</a></h3><p>生成されたファイルをコンパイルするとき、必要に応じてコンパイルオプションを設定することができます（これもオプションです）：</p><ul><li>スレッドローカルの DFA マクロ：コンパイルオプションに <code>-DANTLR4_USE_THREAD_LOCAL_CACHE=1</code> を追加する。 を追加すると、スレッドローカルDFAキャッシュの使用が有効になる（デフォルトでは無効）。 これにより、スレッドローカルDFAを保存するためのメモリ使用量と、スレッドローカルDFAを構築するための冗長な計算量が増加します（それほど多くはありません）。 メリットは、複数のスレッドで実行する同時実行性能を向上させることができることだ。 つまり、コンカレント・スループットが十分でないと感じたら、このオプションをオンにすることを検討すべきである。</li></ul><h3 id="メモリ管理" tabindex="-1">メモリ管理 <a class="header-anchor" href="#メモリ管理" aria-label="Permalink to &quot;メモリ管理&quot;">​</a></h3><p>C++には組み込みのメモリー管理がないため、私たちは細心の注意を払う必要がある。そのために、私たちは主にスマート・ポインタに頼っているが、注意して使わないと、時間的ペナルティやメモリの副作用（巡回参照など）を引き起こす可能性がある。しかし現在のところ、メモリ・ハウスは非常に安定している。一般的に、コードの中で生のポインターを見かけたら、これは別の場所で管理されていると考えてください。そのようなポインターを管理しようとしてはいけません（削除、スマート・ポインターへの割り当てなど）。</p><p>したがって、構文解析ツリーはその構文解析ツリーの有効期間のみ有効である。パーサーはそのトークンストリームの寿命の間だけ有効で、元の <code>ANTLRInputStream</code>（または同等のもの）に戻ります。関数の呼び出しにまたがってツリーを保持するには、これらのすべてを作成して保存し、必要がなくなったらツリー以外のすべてを <code>delete</code> する必要があります。</p><h3 id="ユニコードのサポート" tabindex="-1">ユニコードのサポート <a class="header-anchor" href="#ユニコードのサポート" aria-label="Permalink to &quot;ユニコードのサポート&quot;">​</a></h3><p>つまり、レキサーがテキスト入力をレキサートークンに変換するときである。パーサーはエンコーディングをまったく意識しません。</p><p>C++ターゲットは常にUTF-8の入力（文字列またはストリーム）を期待し、それがUTF-32（char32_t配列）に変換されてレキサーに送られます。</p><h3 id="名前付きアクション" tabindex="-1">名前付きアクション <a class="header-anchor" href="#名前付きアクション" aria-label="Permalink to &quot;名前付きアクション&quot;">​</a></h3><p>生成ファイルのカスタマイズを助けるために、いわゆる名前付きアクションがいくつか追加されています。これらのアクションは生成されたコードの特定の領域にタイトで、カスタム（ターゲット固有）のコードを追加することができます。すべてのターゲットはこれらのアクションをサポートしています</p><ul><li>@parser::header</li><li>@parser::members</li><li>@lexer::header</li><li>@lexer::members</li></ul><p>(そのスコープレスの代替である <code>@header</code> と <code>@members</code> がある。) ここで、headerはC/C++のヘッダーファイルではなく、コードファイルの先頭を意味する。ヘッダーアクションの内容は、生成されたすべてのファイルの最初の行に表示されます。そのため、ライセンス/著作権情報のようなものに適しています。</p><p><em>members</em>アクションの内容は、レキサーやパーサーのクラス宣言のpublicセクションに置かれる。したがって、文法述語で使用されるパブリック変数や述語関数に使用することができます。すべてのターゲットは <em>header</em> + <em>members</em> をサポートしているので、他の言語の生成ファイルでも利用できるようにするための最適な場所です。</p><p>それに加えて、C++ターゲットでは、このような名前付きアクションがさらに多数サポートされている。残念ながら、新しいスコープ（たとえば、<em>parser</em>に加えて<em>listener</em>）を定義することはできないので、既存のスコープ（<em>lexer</em>または<em>parser</em>）の一部として定義する必要がある。デモアプリケーションの文法は、参考のため、すべての名前付きアクションを含んでいます。これがそのリストです：</p><ul><li><strong>@lexer::preinclude</strong> - 最初の#includeの直前に置かれる（例えば、最初に置かなければならないヘッダーや、システムヘッダーなどに適している）。lexer hとcppファイルの両方に現れます。</li><li><strong>@lexer::postinclude</strong> - 最後の#includeの直後で、クラス・コードの前に置かれる（例：名前空間の追加）。lexerのhファイルとcppファイルの両方に現れます。</li><li><strong>@lexer::context</strong> - レキサー・クラス宣言の直前に置く。追加型、エイリアス、前方宣言などに使用する。lexer hファイルに記述する。</li><li><strong>@lexer::declarations</strong> - レキサー宣言のprivateセクションに置きます（すべてのクラスで生成されるセクションは、public、protected、privateというパターンに上から下へと厳密に従います）。privateな変数などに使用します。</li><li><strong>@lexer::definitions</strong> - cppファイル内の他の実装の前に置く（ただし@postincludeの後）。プライベート型などを実装する場合に使用する。</li></ul><p>パーサーには、上記のレキサーと同じアクションがある。それに加えて、ビジター・クラスとリスナー・クラスのためのアクションがさらにあります：</p><ul><li><strong>@parser::listenerpreinclude</strong></li><li><strong>@parser::listenerpostinclude</strong></li><li><strong>@parser::listenerdeclarations</strong></li><li><strong>@parser::listenermembers</strong></li><li><strong>@parser::listenerdefinitions</strong></li><li></li><li><strong>@parser::baselistenerpreinclude</strong></li><li><strong>@parser::baselistenerpostinclude</strong></li><li><strong>@parser::baselistenerdeclarations</strong></li><li><strong>@parser::baselistenermembers</strong></li><li><strong>@parser::baselistenerdefinitions</strong></li><li></li><li><strong>@parser::visitorpreinclude</strong></li><li><strong>@parser::visitorpostinclude</strong></li><li><strong>@parser::visitordeclarations</strong></li><li><strong>@parser::visitormembers</strong></li><li><strong>@parser::visitordefinitions</strong></li><li></li><li><strong>@parser::basevisitorpreinclude</strong></li><li><strong>@parser::basevisitorpostinclude</strong></li><li><strong>@parser::basevisitordeclarations</strong></li><li><strong>@parser::basevisitormembers</strong></li><li><strong>@parser::basevisitordefinitions</strong></li></ul><p>で説明できる。注：リスナーや訪問者のためのコンテキストアクションはありません。なぜなら、それらは他のアクションよりも使われることが少なく、すでにたくさんあるからです。</p>`,47),o=[p];function r(t,i,c,y,D,C){return a(),n("div",null,o)}const d=s(e,[["render",r]]);export{A as __pageData,d as default};
