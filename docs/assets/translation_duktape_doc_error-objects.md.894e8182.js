import{_ as e,c as r,o as t,Q as o}from"./chunks/framework.44f152d8.js";const f=JSON.parse('{"title":"Error objects","description":"","frontmatter":{},"headers":[],"relativePath":"translation/duktape/doc/error-objects.md","lastUpdated":1682143322000}'),a={name:"translation/duktape/doc/error-objects.md"},n=o(`<h1 id="error-objects" tabindex="-1">Error objects <a class="header-anchor" href="#error-objects" aria-label="Permalink to &quot;Error objects&quot;">​</a></h1><p>Standard ECMAScript <code>Error</code> instances are quite barebones: they only contain a <code>name</code> and a <code>message</code>. Most ECMAScript implementations, including Duktape, provide additional error properties like file name, line number, and traceback. ECMAScript allows throwing of arbitrary values, although most user code throws objects inheriting from the <code>Error</code> constructor.</p><p>This document describes how Duktape creates and throws <code>Error</code> objects, what properties such objects have, and what error message verbosity levels are available. The internal traceback data format and the mechanism for providing human readable tracebacks is also covered.</p><p>Also see the user documentation which covers the exposed features in a more approachable way.</p><h2 id="error-message-verbosity-levels" tabindex="-1">Error message verbosity levels <a class="header-anchor" href="#error-message-verbosity-levels" aria-label="Permalink to &quot;Error message verbosity levels&quot;">​</a></h2><p>There are three levels of error message verbosity, controlled by indicated defines:</p><hr><p>DUK_USE_VERBOSE_ERRORS DUK_USE_PARANOID_ERRORS Description</p><hr><p>set not set Verbose messages with offending keys/values included, e.g. <code>number required, found &#39;xyzzy&#39; (index -3)</code>. This is the default behavior.</p><p>set set Verbose messages with offending keys/values not included, e.g. <code>number required, found string (index -3)</code>. Useful when keys/values in error messages are considered a potential security issue.</p><h2 id="not-set-ignored-error-objects-won-t-have-actual-errormessages-error-code-converted-to-a-string-isprovided-in-message-useful-for-very-lowmemory-targets" tabindex="-1">not set ignored Error objects won&#39;t have actual error messages; error code converted to a string is provided in <code>.message</code>. Useful for very low memory targets. <a class="header-anchor" href="#not-set-ignored-error-objects-won-t-have-actual-errormessages-error-code-converted-to-a-string-isprovided-in-message-useful-for-very-lowmemory-targets" aria-label="Permalink to &quot;not set                  ignored                   Error objects won\\&#39;t have actual error
                                                     messages; error code converted to a string is
                                                     provided in \`.message\`. Useful for very low
                                                     memory targets.&quot;">​</a></h2><p>Future work:</p><ul><li>It would be useful to have low memory error messages where error message strings were present, but there would be a minimal number of different message strings. For example, all errors from <code>duk_require_xxx()</code> type mismatches could result in <code>&quot;unexpected type&quot;</code> and all stack index errors could result in <code>&quot;invalid argument&quot;</code>.</li></ul><h2 id="error-augmentation-overview" tabindex="-1">Error augmentation overview <a class="header-anchor" href="#error-augmentation-overview" aria-label="Permalink to &quot;Error augmentation overview&quot;">​</a></h2><p>Duktape allows error objects to be augmented at (1) their creation, and (2) when they are just about the be thrown. Augmenting an error object at its creation time is usually preferable to augmenting it when it is being thrown: an object is only created once but can be thrown and rethrown multiple times (however, there are corner cases related to object creation too, see below for details).</p><p>When an instance of <code>Error</code> is created:</p><ul><li>Duktape first adds traceback or file/line information (depending on active config options) to the error object.</li><li>Then, if <code>Duktape.errCreate</code> is set, it is called to augment the error further or replace it completely. The callback is called an <strong>error handler</strong> inside the implementation. The user can set an error handler if desired, by default it is not set.</li></ul><p>Note that only error values which are instances of <code>Error</code> are augmented, other kinds of values (even objects) are left alone. A user error handler only gets called with <code>Error</code> instances.</p><p>When <strong>any value</strong> is thrown (or re-thrown):</p><ul><li>If <code>Duktape.errThrow</code> is set, it is called to augment or replace the value thrown. The user can set an error handler if desired, by default it is not set.</li></ul><p>Note that all values are given to <code>Duktape.errThrow</code> to process, not just <code>Error</code> instances, so the user error handler must be careful to handle all value types properly. The error handler also needs to handle re-throwing in whatever way is appropriate in the user context.</p><h2 id="error-object-creation" tabindex="-1">Error object creation <a class="header-anchor" href="#error-object-creation" aria-label="Permalink to &quot;Error object creation&quot;">​</a></h2><p>Errors can be created in multiple ways:</p><ul><li><p>From ECMAScript code by creating an error, usually (but not always) tied to a <code>throw</code> statement, e.g.:</p><pre><code>throw new Error(&#39;my error&#39;);
</code></pre><p>In this case the Error object should capture the file and line of the file creating the Error object (with <code>new Error(...)</code>).</p></li><li><p>From C code using the Duktape API, e.g.:</p><pre><code>duk_error(ctx, DUK_ERR_RANGE_ERROR, &quot;invalid argument: %d&quot;, argvalue);
</code></pre><p>In these cases the <code>__FILE__</code> and <code>__LINE__</code> of the throw site are very useful. API calls which create an error object are implemented as macros to capture <code>__FILE__</code> and <code>__LINE__</code> conveniently. This is very important to create useful tracebacks.</p></li><li><p>From inside the Duktape implementation, usually with the <code>DUK_ERROR()</code> macro, e.g.:</p><pre><code>DUK_ERROR(thr, DUK_ERR_TYPE_ERROR, &quot;invalid argument: %d&quot;, argvalue);
</code></pre><p>In these cases the <code>__FILE__</code> and <code>__LINE__</code> of the throw site are included in the stack trace, but are not &quot;blamed&quot; as the source of the error for the Error object&#39;s <code>.fileName</code> and <code>.lineNumber</code>: the file/line is Duktape internal and not the most useful for user code.</p><p>There are several helper macros for specific errors which work similarly to the basic <code>DUK_ERROR()</code> macro.</p></li></ul><p>When errors are thrown using the Duktape API or from inside the Duktape implementation, the value thrown is always an instance of <code>Error</code> and is therefore augmented. Error creation and throwing happens at the same time.</p><p>When errors are thrown from ECMAScript code the situation is different. There is nothing preventing user code from separating the error creation and error throwing from each other:</p><pre><code>var err = new Error(&#39;value too large&#39;);
if (arg &gt;= 100) {
    throw err;
}
</code></pre><p>In fact, the user may never intend to throw the error but may still want to access the traceback:</p><pre><code>var err = new Error(&#39;currently here&#39;);
print(&#39;debug: reached this point\\n&#39; + err.stack);
</code></pre><p>As discussed above, it&#39;s usually preferable to augment errors when they are created rather than when they are thrown: re-throwing an error might cause it to be augmented multiple times (overwriting previous values), and some errors may never even be thrown but would still benefit from having traceback information.</p><p>Duktape&#39;s built-in augmentation (essentially adding a traceback) happens at error creation time; optional error handlers allow user to additionally process errors both at their creation and just before they are thrown.</p><p>In more concrete terms, when a constructor call is made (i.e. <code>new Foo()</code>) the final result which is about to be returned to calling code is inspected. This is a change to the standard handling of constructor calls and applies uniformly whenever any object is created (and unfortunately carries some overhead). If the final value is an <code>Error</code> instance, i.e. its internal prototype chain contains <code>Error.prototype</code>:</p><ul><li>If the object is also extensible, the value gets augmented with error information (e.g. tracedata) by Duktape&#39;s built-in augmentation.</li><li>If <code>Duktape.errCreate</code> is set, the error gets further processed by a user callback; note that the object doesn&#39;t need to be extensible for this to happen, but it still must be an <code>Error</code> instance.</li></ul><p>Duktape refuses to add additional fields to the object if it already contains fields of the same name. For instance, if the created object has a <code>_Tracedata</code> field, it won&#39;t get overwritten by the augmentation process. (User error handler has no such restrictions, and it may replace the error value entirely.)</p><p>Although a particular object is never as such constructed twice, the current approach may lead to an error object being augmented twice during its creation in special cases. This can be achieved e.g. as follows:</p><pre><code>function Constructor() {
    return new Error(&#39;my error&#39;);
}

var e = new Constructor();
</code></pre><p>Here, error augmentation (including Duktape&#39;s own augmentation handling and a user error handler) would happen twice:</p><ol><li>When <code>new Error(&#39;my error&#39;)</code> executes, the result gets augmented. If a user error handler (<code>errCreate</code>) exists, it is called.</li><li>When the <code>new Constructor()</code> call returns, the returned error value replaces the default object given to the constructor. The replacement value (i.e. the result of <code>new Error(&#39;my error&#39;)</code>) gets augmented.</li></ol><p>To avoid issues with this behavior, Duktape&#39;s augmentation code refuses to add any field to an error if it&#39;s already present. This ensures that traceback data is not overwritten in step 2 above. A user <code>errCreate</code> error handler must also deal properly with multiple calls for the same error object. It is easiest to do something like:</p><pre><code>Duktape.errCreate = function (e) {
    if (&#39;timestamp&#39; in e) {
        return e;  // only touch once
    }
    e.timestamp = new Date();
    return e;
}
</code></pre><p>The downside of augmenting during creation is that the error information may not accurately reflect the actual <code>throw</code> statement which throws the error. In particular, user code may create an error value in a completely different place at a completely different time than where and when the error is actually thrown. User code may even throw the same error value multiple times.</p><p>Error objects can also be created by calling the <code>Error</code> constructor (or a constructor of a subclass) as a normal function. In the standard this is semantically equivalent to a constructor call. Duktape will also augment an error created by calling a built-in error constructor with a normal function call. However, any Error sub-classes created by the user don&#39;t exhibit this behavior. For instance:</p><pre><code>MyError = function(msg) { this.message = msg; this.name = &#39;MyError&#39;; return this; }
MyError.prototype = Error.prototype;

var e1 = new Error(&#39;test 1&#39;);    // augmented, constructor call
var e2 = Error(&#39;test 2&#39;);        // augmented, special handling
var e3 = new MyError(&#39;test 3&#39;);  // augmented, constructor call
var e4 = MyError(&#39;test 4&#39;);      // not augmented

print(e1.stack);
print(e2.stack);
print(e3.stack);
print(e4.stack);
</code></pre><p>Prints out:</p><pre><code>Error: test 1
        global test.js:4 preventsyield
Error: test 2
        Error (null) native strict preventsyield
        global test.js:5 preventsyield
MyError: test 3
        global test.js:6 preventsyield
undefined
</code></pre><p>Note that because of internal details, the traceback is different for the <code>Error</code> constructor when it is called as a normal function.</p><p>Fixing this behavior so that even user errors get augmented when called with a non-constructor call seems difficult. It would be difficult to detect when augmentation is appropriate and it would also add overhead to every normal function call.</p><h2 id="error-throwing" tabindex="-1">Error throwing <a class="header-anchor" href="#error-throwing" aria-label="Permalink to &quot;Error throwing&quot;">​</a></h2><p>When <strong>any error value</strong> is thrown, an optional user error handler set to <code>Duktape.errThrow</code> can process or replace the error value. This applies to all types, because any value can be thrown.</p><p>The user error handler must deal with the following:</p><ul><li>Restricting error value modification to only relevant values, e.g. only to <code>Error</code> instances.</li><li>Dealing with re-throwing properly.</li></ul><p>For example, the following would add a timestamp to an error object on their first throw:</p><pre><code>Duktape.errThrow = function (e) {
    if (!(e instanceof Error)) {
        return e;  // only touch errors
    }
    if (&#39;timestamp&#39; in e) {
        return e;  // only touch once
    }
    e.timestamp = new Date();
    return e;
}
</code></pre><h2 id="specifying-error-handlers" tabindex="-1">Specifying error handlers <a class="header-anchor" href="#specifying-error-handlers" aria-label="Permalink to &quot;Specifying error handlers&quot;">​</a></h2><h3 id="current-approach" tabindex="-1">Current approach <a class="header-anchor" href="#current-approach" aria-label="Permalink to &quot;Current approach&quot;">​</a></h3><p>The current create/throw error handlers are stored in <code>Duktape.errCreate</code> and <code>Duktape.errThrow</code>. This has several advantages:</p><ul><li>The <code>Duktape</code> object is easy to access from both C and ECMAScript code without additional API bindings.</li><li>It works relatively well with sandboxing: the <code>Duktape</code> object can be moved to a stash (not accessible from user code) during sandbox init, and error handlers can be controlled through the stash from C code.</li><li>The scope for the error handlers is all threads sharing the same <code>Duktape</code> built-in - i.e., threads sharing the same global environment. This means that the error handlers are automatically effective in resumed threads, for instance, which is probably a good default behavior.</li></ul><h3 id="design-alternatives" tabindex="-1">Design alternatives <a class="header-anchor" href="#design-alternatives" aria-label="Permalink to &quot;Design alternatives&quot;">​</a></h3><p>There are several alternatives to the current approach, though. One could store the error handler(s) in:</p><ul><li>Internal data structures, e.g. <code>thr-&gt;errcreate</code> and <code>thr-&gt;errthrow</code>. This would be stronger from a sandboxing point-of-view, but would require custom bindings to get/set the handlers. Also memory management would need to know about the fields.</li><li>Calling thread&#39;s value stack (in a caller&#39;s frame), only for the duration of a specific protected call. This model is used by Lua and was also used by Duktape up to 0.9.0. The downside is that protected calls need to manage error handlers which are quite rarely used.</li><li>Global object. This seems overall worse than using the <code>Duktape</code> object, as it would be worse for sandboxing with no apparent advantages.</li><li>Thread object. This would require some extra code to &quot;inherit&quot; error handler(s) to a resumed thread (as that seems like a good default behavior).</li><li>Global stash. Good for sandboxing, but would only be accessible from C code by default. This seems like one of the best alternatives for the current behavior.</li><li>Thread stash. Good for sandboxing, error handler &quot;inherit&quot; issue.</li></ul><h2 id="error-object-properties" tabindex="-1">Error object properties <a class="header-anchor" href="#error-object-properties" aria-label="Permalink to &quot;Error object properties&quot;">​</a></h2><p>The following table summarizes properties of <code>Error</code> objects constructed within the control of the implementation, with default Duktape config options (in particular, tracebacks enabled):</p><hr><p>Property Standard Inherited Description</p><hr><p>name yes yes e.g. <code>TypeError</code> for a TypeError (usually inherited)</p><p>message yes no message given when constructing (or empty) (own property)</p><p>fileName no yes name of the file where constructed (inherited accessor)</p><p>lineNumber no yes line of the file where constructed (inherited accessor)</p><p>stack no yes printable stack traceback string (inherited accessor)</p><h2 id="tracedata-no-no-stack-traceback-data-internal-rawformat-own-internal-property" tabindex="-1">_Tracedata no no stack traceback data, internal raw format (own, internal property) <a class="header-anchor" href="#tracedata-no-no-stack-traceback-data-internal-rawformat-own-internal-property" aria-label="Permalink to &quot;\\_Tracedata    no         no          stack traceback data, internal raw
                                        format (own, internal property)&quot;">​</a></h2><p>The <code>Error.prototype</code> contains the following non-standard properties:</p><hr><p>Property Standard Description</p><hr><p>stack no accessor property for getting a printable traceback based on _Tracedata</p><p>fileName no accessor property for getting a filename based on _Tracedata</p><h2 id="linenumber-no-accessor-property-for-getting-a-linenumberbased-on-tracedata" tabindex="-1">lineNumber no accessor property for getting a linenumber based on _Tracedata <a class="header-anchor" href="#linenumber-no-accessor-property-for-getting-a-linenumberbased-on-tracedata" aria-label="Permalink to &quot;lineNumber        no         accessor property for getting a linenumber
                               based on \\_Tracedata&quot;">​</a></h2><p>All of the accessors are in the prototype in case the object instance does not have an &quot;own&quot; property of the same name. This allows for flexibility in minimizing the property count of error instances while still making it possible to provide instance-specific values when appropriate. Note that the setters allow user code to write an instance-specific value as an &quot;own property&quot; of the error object, thus shadowing the accessors in later reads.</p><p>Notes:</p><ul><li>The <code>stack</code> property name is from V8 and behavior is close to V8. V8 allows user code to write to the <code>stack</code> property but does not create an own property of the same name. The written value is still visible when <code>stack</code> is read back later.</li><li>The <code>fileName</code> and <code>lineNumber</code> property names are from Rhino.</li><li>In Duktape 1.3.0 and prior user code couldn&#39;t directly write <code>.fileName</code>, <code>.lineNumber</code>, or <code>.stack</code> because the inherited setter would capture and ignore such writes. User code could use <code>Object.defineProperty()</code> or <code>duk_def_prop()</code> to create overriding properties. In Duktape 1.4.0 the setter was changed to make writes work transparently: they&#39;re still captured by the setter, but the setter automatically creates the own property.</li><li>The <code>_Tracedata</code> has an internal format which may change from version to version (even build to build). It should never be serialized or used outside the life cycle of a Duktape heap.</li><li>In size-optimized builds traceback information may be omitted. In such cases <code>fileName</code> and <code>lineNumber</code> are concrete own properties, and <code>.stack</code> is an inherited property which returns a <code>ToString()</code> coerced error string, e.g. <code>TypeError: my error message</code>.</li><li>In size-optimized builds errors created by the Duktape implementation will not have a useful <code>message</code> field. Instead, <code>message</code> is set to a string representation of the error <code>code</code>. Exceptions thrown from user code will carry <code>message</code> normally.</li><li>The <code>_Tracedata</code> property contains function references to functions in the current callstack. Because such references are a potential sandboxing concern, the tracedata is stored in an internal property.</li></ul><h2 id="choosing-filename-and-linenumber-to-blame-for-an-error" tabindex="-1">Choosing .fileName and .lineNumber to blame for an error <a class="header-anchor" href="#choosing-filename-and-linenumber-to-blame-for-an-error" aria-label="Permalink to &quot;Choosing .fileName and .lineNumber to blame for an error&quot;">​</a></h2><h3 id="overview-of-the-issue" tabindex="-1">Overview of the issue <a class="header-anchor" href="#overview-of-the-issue" aria-label="Permalink to &quot;Overview of the issue&quot;">​</a></h3><p>When an error is created/thrown, it&#39;s not always clear which file/line to &quot;blame&quot; as the source of the error: the <code>.fileName</code> and <code>.lineNumber</code> properties of the Error object should be useful for the application programmer to pinpoint the most likely cause of the error.</p><p>The relevant file/line pairs are:</p><ul><li><strong>The __FILE__ and __LINE__ of the C call site</strong>. While these often refer to a line in a Duktape/C function, it&#39;s possible for the Duktape/C function to call into a helper in a different file which throws the error. The C call site may also be inside Duktape, e.g. if user code calls <code>duk_require_xxx()</code> which then throws using the internal <code>DUK_ERROR()</code> macro. Finally, it&#39;s also possible to throw an error when no callstack entries are present; the C call site information will still be available.</li><li><strong>The file/line of a source text being compiled</strong>. This is only relevant for errors thrown during compilation (typically SyntaxErrors but may be other errors too).</li><li><strong>Actual callstack entries (activations) leading up to the error</strong>. These may be Duktape/C and ECMAScript functions. The functions have a varying set of properties: for example, ECMAScript functions have both a <code>.name</code> and a <code>.fileName</code> property by default, while Duktape/C functions don&#39;t. It&#39;s possible to add and remove properties after function creation.</li></ul><p>The following SyntaxError illustrates all the relevant file/line sources:</p><pre><code>duk&gt; try { eval(&#39;\\n\\nfoo=&#39;); } catch (e) { print(e.stack); print(e.fileName, e.lineNumber); }
SyntaxError: parse error (line 3)
        input:3                                        &lt;-- file/line of source text (SyntaxError)
        duk_js_compiler.c:3612                         &lt;-- __FILE__ / __LINE__ of DUK_ERROR() call site
        eval  native strict directeval preventsyield   &lt;-- innermost activation, eval() function
        global input:1 preventsyield                   &lt;-- second innermost activation, caller of eval()
input 3   &lt;-- .fileName and .lineNumber blames source text for SyntaxError
</code></pre><p>From the application point of view the most relevant file/line is usually the closest &quot;user function&quot;, as opposed to &quot;infrastructure function&quot;, in the callstack. The following are often not useful for blaming:</p><ul><li>Any Duktape/C or ECMAScript functions which are considered infrastructure functions, such as errors checkers, one-to-one system call wrappers, etc.</li><li>C call sites inside Duktape; these are essentially always infrastructure functions.</li><li>Any Duktape/C or ECMAScript functions missing a <code>.fileName</code> property. Such functions should be ignored even if they&#39;re user functions because the resulting file/line information would be pointless.</li></ul><p>For this ideal outcome to be possible, Duktape needs to be able to determine whether or not a function should be ignored for blaming. This is not yet possible; subsections below describe the current behavior.</p><p>Note that while file/line information is important for good error reporting, all the relevant information is always available in the stack trace anyway. Incorrect file/line blaming is annoying but usually not a critical issue.</p><h3 id="duktape-1-3-behavior" tabindex="-1">Duktape 1.3 behavior <a class="header-anchor" href="#duktape-1-3-behavior" aria-label="Permalink to &quot;Duktape 1.3 behavior&quot;">​</a></h3><p>The rules for blaming a certain file/line for an error are relatively simple in Duktape 1.3:</p><ul><li>For error thrown during compilation the source text file/line is always blamed. The compilation errors are typically SyntaxErrors, but may also be e.g. out-of-memory internal errors.</li><li>For errors thrown from Duktape internals (including Duktape API functions like <code>duk_require_xxx()</code>) the C call site is ignored, and the innermost activation is used for file/line information. This is the case even when the innermost activation&#39;s function has no <code>.fileName</code> property so that the error <code>.fileName</code> becomes <code>undefined</code>.</li><li>For errors created/thrown using the Duktape API (<code>duk_push_error_object()</code>, <code>duk_error()</code>, etc) the C call site is always blamed, so that the error&#39;s file/line information matches the C call site&#39;s <code>__FILE__</code>/<code>__LINE__</code>. This behavior is hardcoded; user code may override the behavior by defining <code>.fileName</code> and <code>.lineNumber</code> on the error object.</li></ul><p>These rules have a few shortcomings.</p><p>First, the C call site is blamed for all user-thrown errors which is often not the best behavior. For example:</p><pre><code>/* foo/bar/quux.c */

static duk_ret_t my_argument_validator(duk_context *ctx) {
        /* ... */

        /* The duk_error() call site&#39;s __FILE__ and __LINE__ will be
         * recorded into _Tracedata and will be provided when reading
         * .fileName and .lineNumber of the error, e.g.:
         *
         *     err.fileName   --&gt; &quot;foo/bar/quux.c&quot;
         *     err.lineNumber --&gt; 1234
         *
         * If this an &quot;infrastructure function&quot;, e.g. a validator for
         * an argument value, the file/line blamed is not very useful.
         */

        duk_error(ctx, DUK_ERR_RANGE_ERROR, &quot;argument out of range&quot;);

        /* ... */
}
</code></pre><p>Second, when the C call site is not blamed and the innermost activation does not have a <code>.fileName</code> property (which is the default for Duktape/C functions) the error&#39;s <code>.fileName</code> will be <code>undefined</code>. For example:</p><pre><code>((o) Duktape 1.3.0 (v1.3.0)
duk&gt; try { [1,2,3].forEach(123); } catch (e) { err = e; }
= TypeError: type error (rc -105)
duk&gt; err.fileName
= undefined
duk&gt; err.lineNumber
= 0
duk&gt; err.stack
= TypeError: type error (rc -105)
        forEach  native strict preventsyield
        global input:1 preventsyield
duk&gt; Array.prototype.forEach.name
= forEach
duk&gt; Array.prototype.forEach.fileName
= undefined
</code></pre><p>While <code>forEach()</code> has a <code>.name</code> property, it doesn&#39;t have a <code>.fileName</code> that <code>err.fileName</code> becomes <code>undefined</code>. This is obviously not very useful; it&#39;d be more useful to blame the error on <code>input</code>, which is the closest call site with a filename.</p><h3 id="duktape-1-4-0-behavior" tabindex="-1">Duktape 1.4.0 behavior <a class="header-anchor" href="#duktape-1-4-0-behavior" aria-label="Permalink to &quot;Duktape 1.4.0 behavior&quot;">​</a></h3><p>Duktape 1.4.0 improves the blaming behavior slightly when the C call site information is not blamed: instead of taking file/line information from the innermost activation, it is taken from the closest activation which has a <code>.fileName</code> property.</p><p>This improves file/line blaming for the <code>forEach()</code> example above:</p><pre><code>((o) Duktape 1.3.99 (v1.3.0-294-g386260d-dirty)
duk&gt; try { [1,2,3].forEach(123); } catch (e) { err = e; }
= TypeError: function required, found 123 (stack index 0)
duk&gt; err.fileName
= input
duk&gt; err.lineNumber
= 1
</code></pre><p>If <code>forEach()</code> is assigned a filename, it will get blamed instead:</p><pre><code>((o) Duktape 1.3.99 (v1.3.0-294-g386260d-dirty)
duk&gt; Array.prototype.forEach.fileName = &#39;dummyFilename.c&#39;;
= dummyFilename.c
duk&gt; try { [1,2,3].forEach(123); } catch (e) { err = e; }
= TypeError: function required, found 123 (stack index 0)
duk&gt; err.fileName
= dummyFilename.c
duk&gt; err.lineNumber
= 0
</code></pre><p>There&#39;s no change in behavior for errors thrown during compilation (typically SyntaxErrors).</p><p>There&#39;s also no change for the case where the C call site is blamed, e.g. for errors thrown explicitly using <code>duk_error()</code>. Because such error throws are possible from both infrastructure code and application code, there&#39;s not yet enough information to select the ideal file/line for such an error.</p><h3 id="replacing-the-filename-and-linenumber-accessors" tabindex="-1">Replacing the .fileName and .lineNumber accessors <a class="header-anchor" href="#replacing-the-filename-and-linenumber-accessors" aria-label="Permalink to &quot;Replacing the .fileName and .lineNumber accessors&quot;">​</a></h3><p>If the user application needs more control of file/line blaming, it&#39;s possible to replace the inherited <code>Error.prototype.fileName</code> and <code>Error.prototype.lineNumber</code> accessors and implement whatever logic suits the application best. For example, the application could filter functions based on a filename whitelist/blacklist or filename patterns.</p><p>The downside of this is that the application needs to decode <code>_Tracedata</code> whose format is version dependent.</p><h3 id="future-improvements" tabindex="-1">Future improvements <a class="header-anchor" href="#future-improvements" aria-label="Permalink to &quot;Future improvements&quot;">​</a></h3><h4 id="control-blaming-of-c-call-site" tabindex="-1">Control blaming of C call site <a class="header-anchor" href="#control-blaming-of-c-call-site" aria-label="Permalink to &quot;Control blaming of C call site&quot;">​</a></h4><p>Allow C code to indicate whether the C call site of an error create/throw should be considered relevant for file/line blaming. This change would allow user code to control the blaming on a per-error basis.</p><p>Duktape already does this internally by using a flag (<code>DUK_ERRCODE_FLAG_NOBLAME_FILELINE</code>) ORed with an error code to convey the intent. The flag could simply be exposed in the API, but there are other API design options too.</p><h4 id="control-error-blaming-of-compilation-errors" tabindex="-1">Control error blaming of compilation errors <a class="header-anchor" href="#control-error-blaming-of-compilation-errors" aria-label="Permalink to &quot;Control error blaming of compilation errors&quot;">​</a></h4><p>At the moment source text file/line is always blamed for errors thrown during compilation (typically SyntaxErrors).</p><p>Technically there might be compilation errors inside &quot;infrastructure code&quot; so that it may not always be correct to blame them. This could be easily fixed by adding a flag to the compilation API calls.</p><h4 id="control-error-blaming-of-functions" tabindex="-1">Control error blaming of functions <a class="header-anchor" href="#control-error-blaming-of-functions" aria-label="Permalink to &quot;Control error blaming of functions&quot;">​</a></h4><p>Allow Duktape/C and ECMAScript functions to provide a flag indicating if the function should be considered relevant for file/line blaming.</p><p>For Duktape 1.4.0 the <code>.fileName</code> property of a function serves this purpose to some extent: if a function is missing <code>.fileName</code> it is ignored for file/line blaming, i.e. treated as an infrastructure function. However, there may be infrastructure functions which have a <code>.fileName</code> or non-infrastructure functions which don&#39;t have a <code>.fileName</code>, so being able to control the blaming behavior explicitly would be useful.</p><p>The control flag could be implemented either as a <code>duk_hobject</code> flag or an (internal or external) property.</p><h4 id="handling-of-lightfuncs" tabindex="-1">Handling of lightfuncs <a class="header-anchor" href="#handling-of-lightfuncs" aria-label="Permalink to &quot;Handling of lightfuncs&quot;">​</a></h4><p>Should lightfuncs be blamed or not? Currently they are never blamed for file/line.</p><h2 id="cause-chains" tabindex="-1">Cause chains <a class="header-anchor" href="#cause-chains" aria-label="Permalink to &quot;Cause chains&quot;">​</a></h2><p>There is currently no support for cause chains: ECMAScript doesn&#39;t have a cause chain concept nor does there seem to be an unofficial standard for them either.</p><p>A custom cause chain could be easily supported by allowing a <code>cause</code> property to be set on an error, and making the traceback formatter obey it.</p><p>A custom mechanism for setting an error cause would need to be used. A very non-invasive approach would be something like:</p><pre><code>try {
    f();
} catch (e) {
    var e2 = new Error(&quot;something went wrong&quot;);  // line N
    e2.cause = e;                                // line N+1
    throw e2;                                    // line N+2
}
</code></pre><p>This is quite awkward and error line information is easily distorted. The line number issue can be mitigated by putting the error creation on a single line, at the cost of readability:</p><pre><code>try {
    f();
} catch (e) {
    var e2 = new Error(&quot;something went wrong&quot;); e2.cause = e; throw e2;
}
</code></pre><p>One could also extend the error constructor to allow a cause to be specified in a constructor call. This would mimic how Java works and would be nice to use, but would have more potential to interfere with standard semantics:</p><pre><code>try {
    f();
} catch (e) {
    throw new Error(&quot;something went wrong&quot;, e);
}
</code></pre><p>Using a setter method inherited from <code>Error.prototype</code> would be a very bad idea as any such calls would be non-portable and cause errors to be thrown when used in other ECMAScript engines:</p><pre><code>try {
    f();
} catch (e) {
    var e2 = new Error(&quot;something went wrong&quot;, e);
    e2.setCause(e);  // throws error if setCause is undefined!
    throw e2;
}
</code></pre><p>Since errors are also created (and thrown) from C code using the Duktape API and from inside the Duktape implementation, cause handling would need to be considered for these too.</p><p>Because the <code>cause</code> property can be set to anything, the implementation would need to tolerate e.g.:</p><pre><code>// non-Error causes (print reasonably in a traceback)
e.cause = 1;

// cause loops (detect or sanity depth limit traceback)
e1.cause = e2;
e2.cause = e1;
</code></pre><h2 id="traceback-format-tracedata" tabindex="-1">Traceback format (_Tracedata) <a class="header-anchor" href="#traceback-format-tracedata" aria-label="Permalink to &quot;Traceback format (\\_Tracedata)&quot;">​</a></h2><h3 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h3><p>The purpose of the <code>_Tracedata</code> value is to capture the relevant callstack information very quickly before the callstack is unwound by error handling. In many cases the traceback information is not used at all, so it should be recorded in a compact and cheap manner.</p><p>To fulfill these requirements, the current format, described below, is a bit arcane. The format is version dependent, and is not intended to be accessed directly by user code.</p><p>The <code>_Tracedata</code> value is a flat array, populated with values describing: (1) a possible compilation error site, (2) a possible C call site, and (3) the contents of the callstack, starting from the callstack top and working downwards until either the callstack bottom or the maximum traceback depth is reached.</p><p>The tracedata is processed only by Duktape internal functions:</p><ul><li>The <code>Error.prototype.stack</code> accessor converts tracedata into a human readable, printable traceback string.</li><li>The <code>Error.prototype.fileName</code> and <code>Error.prototype.lineNumber</code> accessors provide a file/line &quot;blaming&quot; for the error based on the tracedata.</li><li>Currently (as of Duktape 1.4) there are no exposed helpers to decode tracedata in a user application. However, user code can inspect the current callstack using <code>Duktape.act()</code> in the <code>errCreate</code> and <code>errThrow</code> hooks.</li></ul><p>Example of the concrete tracedata in Duktape 1.4.0:</p><pre><code>((o) Duktape 1.3.99 (v1.3.0-294-g72447fe)
duk&gt; try { eval(&#39;\\n\\nfoo=&#39;); } catch (e) { err = e; }
= SyntaxError: parse error (line 3)
duk&gt; err.stack
= SyntaxError: parse error (line 3)
        input:3
        duk_js_compiler.c:3655
        eval  native strict directeval preventsyield
        global input:1 preventsyield
duk&gt; Duktape.enc(&#39;jx&#39;, err[Duktape.dec(&#39;hex&#39;, &#39;ff&#39;) + &#39;Tracedata&#39;], null, 4)
= [
    &quot;input&quot;,                \\  compilation error site
    3,                      /
    &quot;duk_js_compiler.c&quot;,    \\  C call site
    4294970951,             /
    {_func:true},           \\
    107374182400,           |  callstack entries
    {_func:true},           |
    34359738375             /
]
</code></pre><h3 id="tracedata-parts" tabindex="-1">Tracedata parts <a class="header-anchor" href="#tracedata-parts" aria-label="Permalink to &quot;Tracedata parts&quot;">​</a></h3><h4 id="compilation-error" tabindex="-1">Compilation error <a class="header-anchor" href="#compilation-error" aria-label="Permalink to &quot;Compilation error&quot;">​</a></h4><p>If the error is thrown during compilation (typically a SyntaxError) the file/line in the source text is pushed to <code>_Tracedata</code>:</p><ul><li>The source filename as a string.</li><li>The offending linenumber as a number (double).</li></ul><h4 id="c-call-site" tabindex="-1">C call site <a class="header-anchor" href="#c-call-site" aria-label="Permalink to &quot;C call site&quot;">​</a></h4><p>If a call has a related C call site, the call site is pushed to <code>_Tracedata</code>:</p><ul><li><p>The <code>__FILE__</code> value as a string.</p></li><li><p>A number (double) containing the expression:</p><pre><code>(flags &lt;&lt; 32) + (__LINE__)
</code></pre><p>The only current flag indicates whether or not the <code>__FILE__</code> / <code>__LINE__</code> pair should be &quot;blamed&quot; as the error location when the user requests for a <code>fileName</code> or <code>lineNumber</code> related to the error.</p></li></ul><h4 id="callstack-entries" tabindex="-1">Callstack entries <a class="header-anchor" href="#callstack-entries" aria-label="Permalink to &quot;Callstack entries&quot;">​</a></h4><p>After that, for each callstack element, the array entries appended to <code>_Tracedata</code> are pairs consisting of:</p><ul><li><p>The function object of the activation. The function object contains the function type and name. It also contains the filename (or equivalent, like &quot;global&quot; or &quot;eval&quot;) and possibly PC-to-line debug information. These are needed to create a printable traceback.</p></li><li><p>A number (double) containing the expression:</p><pre><code>(activation_flags &lt;&lt; 32) + (activation_pc)
</code></pre><p>For C functions, the program counter value is zero. Activation flag values are defined in <code>duk_hthread.h</code>. The PC value can be converted to a line number with debug information in the function object. The flags allow e.g. tail calls to be noted in the traceback.</p></li></ul><h3 id="notes" tabindex="-1">Notes <a class="header-anchor" href="#notes" aria-label="Permalink to &quot;Notes&quot;">​</a></h3><ul><li>An IEEE double can hold a 53-bit integer accurately so there is space for plenty of flags in the current representation. Flags must be in the low end of the flags field though (bit 20 or lower)</li><li>The number of elements appended to the <code>_Tracedata</code> array for each activation does not need to constant, as long as the value can be decoded starting from the beginning of the array (in other words, random access is not important at the moment).</li><li>The <code>this</code> binding, if any, is not currently recorded.</li><li>The variable values of activation records are not recorded. They would actually be available because the callstack can be inspected and register maps (if defined) would provide a way to map identifier names to registers. This is definitely future work and may be needed for better debugging support.</li><li>The <code>_Tracedata</code> value is currently an array, but it may later be changed into an internal type of its own right to optimize memory usage and performance. The internal type would then basically be a typed buffer which garbage collection would know how to visit.</li></ul>`,161),i=[n];function s(c,l,d,h,u,p){return t(),r("div",null,i)}const b=e(a,[["render",s]]);export{f as __pageData,b as default};
